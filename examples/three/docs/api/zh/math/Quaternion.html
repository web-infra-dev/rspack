<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<base href="../../../" />
		<script src="list.js"></script>
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>[name]</h1>

		<p class="desc">
			Implementation of a [link:http://en.wikipedia.org/wiki/Quaternion quaternion].
			This is used for [link:https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation rotating things]
			without encountering the dreaded
			[link:http://en.wikipedia.org/wiki/Gimbal_lock gimbal lock] issue, amongst other
			advantages.
		</p>


		<h2>Example</h2>

		<code>
		var quaternion = new THREE.Quaternion();
		quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );

		var vector = new THREE.Vector3( 1, 0, 0 );
		vector.applyQuaternion( quaternion );
		</code>


		<h2>Constructor</h2>


		<h3>[name]( [param:Float x], [param:Float y], [param:Float z], [param:Float w] )</h3>
		<p>
		[page:Float x] - x coordinate<br />
		[page:Float y] - y coordinate<br />
		[page:Float z] - z coordinate<br />
		[page:Float w] - w coordinate
		</p>


		<h2>Properties</h2>

		<h3>[property:Boolean isQuaternion]</h3>
		<p>
			Used to check whether this or derived classes are Quaternions. Default is *true*.<br /><br />

			You should not change this, as it is used internally for optimisation.
		</p>

		<h3>[property:Float x]</h3>

		<h3>[property:Float y]</h3>

		<h3>[property:Float z]</h3>

		<h3>[property:Float w]</h3>


		<h2>Methods</h2>

		<h3>[method:Float angleTo]( [param:Quaternion q] )</h3>
		<p>
			Returns the angle between this quaternion and quaternion [page:Quaternion q] in radians.
		</p>

		<h3>[method:Quaternion clone]()</h3>
		<p>
			Creates a new Quaternion with identical [page:.x x], [page:.y y],
			[page:.z z] and [page:.w w] properties to this one.
		</p>

		<h3>[method:Quaternion conjugate]()</h3>
		<p>
		Returns the rotational conjugate of this quaternion. The conjugate of a quaternion
		represents the same rotation in the opposite direction about the rotational axis.
		</p>

		<h3>[method:Quaternion copy]( [param:Quaternion q] )</h3>
		<p>
			Copies the [page:.x x], [page:.y y],	[page:.z z] and [page:.w w] properties
			of [page:Quaternion q] into this quaternion.
		</p>

		<h3>[method:Boolean equals]( [param:Quaternion v] )</h3>
		<p>
		[page:Quaternion v] - Quaternion that this quaternion will be compared to.<br /><br />

		Compares the [page:.x x], [page:.y y],	[page:.z z] and [page:.w w] properties of
		[page:Quaternion v] to the equivalent properties of this quaternion to determine if they
		represent the same rotation.
		</p>

		<h3>[method:Float dot]( [param:Quaternion v] )</h3>
		<p>
			Calculates the [link:https://en.wikipedia.org/wiki/Dot_product dot product] of
			quaternions [page:Quaternion v] and this one.
		</p>

		<h3>[method:Quaternion fromArray]( [param:Array array], [param:Integer offset] )</h3>
		<p>
		[page:Array array] - array of format (x, y, z, w) used to construct the quaternion.<br />
		[page:Integer offset] - (optional) an offset into the array.<br /><br />

		Sets this quaternion's [page:.x x], [page:.y y],	[page:.z z] and [page:.w w] properties
		from an array.
		</p>

		<h3>[method:Quaternion inverse]()</h3>
		<p>
			Inverts this quaternion - calculates the [page:.conjugate conjugate]. The quaternion is assumed to have unit length.
		</p>

		<h3>[method:Float length]()</h3>
		<p>Computes the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length]
		(straight-line length) of this quaternion, considered as a 4 dimensional vector.</p>

		<h3>[method:Float lengthSq]()</h3>
		<p>
			Computes the [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length]
			(straight-line length) of this quaternion, considered as a 4 dimensional
			vector. This can be useful if you are comparing the lengths of two quaternions,
			as this is a slightly more efficient calculation than [page:.length length]().
		</p>

		<h3>[method:Quaternion normalize]()</h3>
		<p>
			[link:https://en.wikipedia.org/wiki/Normalized_vector Normalizes] this quaternion - that is,
		calculated the quaternion that performs the same rotation as this one, but has  [page:.length length]
		equal to *1*.
		</p>

		<h3>[method:Quaternion multiply]( [param:Quaternion q] )</h3>
		<p>Multiplies this quaternion by [page:Quaternion q].</p>

		<h3>[method:Quaternion multiplyQuaternions]( [param:Quaternion a], [param:Quaternion b] )</h3>
		<p>
		Sets this quaternion to [page:Quaternion a] x [page:Quaternion b].<br />
		Adapted from the method outlined [link:http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm here].
		</p>

		<h3>[method:Quaternion premultiply]( [param:Quaternion q] )</h3>
		<p>Pre-multiplies this quaternion by [page:Quaternion q].</p>

		<h3>[method:Quaternion rotateTowards]( [param:Quaternion q], [param:Float step] )</h3>
		<p>
			[page:Quaternion q] - The target quaternion.<br />
			[page:float step] - The angular step in radians.<br /><br />

			Rotates this quaternion by a given angular step to the defined quaternion *q*.
			The method ensures that the final quaternion will not overshoot *q*.
		</p>

		<h3>[method:Quaternion slerp]( [param:Quaternion qb], [param:float t] )</h3>
		<p>
			[page:Quaternion qb] - The other quaternion rotation<br />
			[page:float t] - interpolation factor in the closed interval [0, 1].<br /><br />

			Handles the spherical linear interpolation between quaternions. [page:float t] represents the
			amount of rotation between this quaternion (where [page:float t] is 0) and [page:Quaternion qb] (where
			[page:float t] is 1). This quaternion is set to the result. Also see the static version of the
			*slerp* below.

			<code>
			// rotate a mesh towards a target quaternion
			mesh.quaternion.slerp( endQuaternion, 0.01 );
			</code>
		</p>

		<h3>[method:Quaternion set]( [param:Float x], [param:Float y], [param:Float z], [param:Float w] )</h3>
		<p>Sets [page:.x x], [page:.y y], [page:.z z], [page:.w w] properties of this quaternion.</p>

		<h3>[method:Quaternion setFromAxisAngle]( [param:Vector3 axis], [param:Float angle] )</h3>
		<p>
		Sets this quaternion from rotation specified by [page:Vector3 axis] and [page:Float angle].<br />
		Adapted from the method [link:http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm here].<br />
		*Axis* is assumed to be normalized, *angle* is in radians.
		</p>

		<h3>[method:Quaternion setFromEuler]( [param:Euler euler] )</h3>
		<p>Sets this quaternion from the rotation specified by [page:Euler] angle.</p>

		<h3>[method:Quaternion setFromRotationMatrix]( [param:Matrix4 m] )</h3>
		<p>
		Sets this quaternion from rotation component of [page:Matrix4 m].<br />
		Adapted from the method [link:http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm here].
		</p>

		<h3>[method:Quaternion setFromUnitVectors]( [param:Vector3 vFrom], [param:Vector3 vTo] )</h3>
		<p>
		Sets this quaternion to the rotation required to rotate direction vector [page:Vector3 vFrom] to
		direction vector [page:Vector3 vTo].<br />
		Adapted from the method [link:http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors here].<br />
		[page:Vector3 vFrom] and [page:Vector3 vTo] are assumed to be normalized.
		</p>

		<h3>[method:Array toArray]( [param:Array array], [param:Integer offset] )</h3>
		<p>
		[page:Array array] - An optional array to store the quaternion. If not specified, a new array will be created.<br/>
		[page:Integer offset] - (optional) if specified, the result will be copied
		into this [page:Array].<br /><br />

		Returns the numerical elements of this quaternion in an array of format [x, y, z, w].
		</p>

		<h2>Static Methods</h2>

		<p>
			Static methods (as opposed to instance methods) are designed to be called directly from the class,
			rather than from a specific instance. So to use the static version of, call it like so:
			<code>
THREE.Quaternion.slerp( qStart, qEnd, qTarget, t );
			</code>
			By contrast, to call the 'normal' or instanced slerp method, you would do the following:
			<code>
//instantiate a quaternion with default values
var q = new THREE.Quaternion();

//call the instanced slerp method
q.slerp( qb, t )
			</code>

		</p>

		<h3>[method:Quaternion slerp]( [param:Quaternion qStart], [param:Quaternion qEnd], [param:Quaternion qTarget], [param:Float t] )</h3>
		<p>
			[page:Quaternion qStart] - The starting quaternion (where [page:Float t] is 0)<br />
			[page:Quaternion qEnd] - The ending quaternion (where [page:Float t] is 1)<br />
			[page:Quaternion qTarget] - The target quaternion that gets set with the result<br />
			[page:float t] - interpolation factor in the closed interval [0, 1].<br /><br />

			Unlike the normal method, the static version of slerp sets a target quaternion to the result of the slerp operation.
			<code>
			// Code setup
			var startQuaternion = new THREE.Quaternion().set( 0, 0, 0, 1 ).normalize();
			var endQuaternion = new THREE.Quaternion().set( 1, 1, 1, 1 ).normalize();
			var t = 0;

			// Update a mesh's rotation in the loop
			t = ( t + 0.01 ) % 1; // constant angular momentum
			THREE.Quaternion.slerp( startQuaternion, endQuaternion, mesh.quaternion, t );
			</code>
		</p>


		<h3>[method:null slerpFlat]( [param:Array dst], [param:Integer dstOffset], [param:Array src0], [param:Integer srcOffset0], [param:Array src1], [param:Integer srcOffset1], [param:Float t] )</h3>
		<p>
		[page:Array dst] - The output array.<br />
		[page:Integer dstOffset] - An offset into the output array.<br />
		[page:Array src0] - The source array of the starting quaternion.<br />
		[page:Integer srcOffset0] - An offset into the array *src0*.<br />
		[page:Array src1] - The source array of the target quatnerion.<br />
		[page:Integer srcOffset1] - An offset into the array *src1*.<br />
		[page:float t] - Normalized interpolation factor (between 0 and 1).<br /><br />
		</p>
		<p>
		Like the static *slerp* method above, but operates directly on flat arrays of numbers.
		</p>

		<!-- Note: Do not add non-static methods to the bottom of this page. Put them above the <h2>Static Methods</h2> -->

		<h2>Source</h2>

		<p>
			[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
		</p>
	</body>
</html>
