Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    APP_BOOTSTRAP_LISTENER: function() {
        return APP_BOOTSTRAP_LISTENER;
    },
    APP_ID: function() {
        return APP_ID;
    },
    APP_INITIALIZER: function() {
        return APP_INITIALIZER;
    },
    ApplicationModule: function() {
        return ApplicationModule;
    },
    ApplicationRef: function() {
        return ApplicationRef;
    },
    CSP_NONCE: function() {
        return CSP_NONCE;
    },
    ChangeDetectorRef: function() {
        return ChangeDetectorRef;
    },
    Compiler: function() {
        return Compiler;
    },
    DEFAULT_CURRENCY_CODE: function() {
        return DEFAULT_CURRENCY_CODE;
    },
    ENVIRONMENT_INITIALIZER: function() {
        return ENVIRONMENT_INITIALIZER;
    },
    ElementRef: function() {
        return ElementRef;
    },
    EnvironmentInjector: function() {
        return EnvironmentInjector;
    },
    ErrorHandler: function() {
        return ErrorHandler;
    },
    EventEmitter: function() {
        return EventEmitter;
    },
    InjectFlags: function() {
        return InjectFlags;
    },
    InjectionToken: function() {
        return InjectionToken;
    },
    Injector: function() {
        return Injector;
    },
    IterableDiffers: function() {
        return IterableDiffers;
    },
    KeyValueDiffers: function() {
        return KeyValueDiffers;
    },
    LOCALE_ID: function() {
        return LOCALE_ID;
    },
    NgModuleFactory: function() {
        return NgModuleFactory$1;
    },
    NgModuleRef: function() {
        return NgModuleRef$1;
    },
    NgProbeToken: function() {
        return NgProbeToken;
    },
    NgZone: function() {
        return NgZone;
    },
    Optional: function() {
        return Optional;
    },
    PLATFORM_ID: function() {
        return PLATFORM_ID;
    },
    PLATFORM_INITIALIZER: function() {
        return PLATFORM_INITIALIZER;
    },
    Renderer2: function() {
        return Renderer2;
    },
    RendererFactory2: function() {
        return RendererFactory2;
    },
    RendererStyleFlags2: function() {
        return RendererStyleFlags2;
    },
    SecurityContext: function() {
        return SecurityContext;
    },
    SkipSelf: function() {
        return SkipSelf;
    },
    TemplateRef: function() {
        return TemplateRef;
    },
    Testability: function() {
        return Testability;
    },
    TestabilityRegistry: function() {
        return TestabilityRegistry;
    },
    TransferState: function() {
        return TransferState;
    },
    Version: function() {
        return Version;
    },
    ViewContainerRef: function() {
        return ViewContainerRef;
    },
    ViewEncapsulation: function() {
        return ViewEncapsulation$1;
    },
    createEnvironmentInjector: function() {
        return createEnvironmentInjector;
    },
    createNgModule: function() {
        return createNgModule;
    },
    createPlatformFactory: function() {
        return createPlatformFactory;
    },
    inject: function() {
        return inject;
    },
    isStandalone: function() {
        return isStandalone;
    },
    makeStateKey: function() {
        return makeStateKey;
    },
    platformCore: function() {
        return platformCore;
    },
    reflectComponentType: function() {
        return reflectComponentType;
    },
    ɵConsole: function() {
        return Console;
    },
    ɵINJECTOR_SCOPE: function() {
        return INJECTOR_SCOPE;
    },
    ɵInitialRenderPendingTasks: function() {
        return InitialRenderPendingTasks;
    },
    ɵLocaleDataIndex: function() {
        return LocaleDataIndex;
    },
    ɵRuntimeError: function() {
        return RuntimeError;
    },
    ɵTESTABILITY: function() {
        return TESTABILITY;
    },
    ɵTESTABILITY_GETTER: function() {
        return TESTABILITY_GETTER;
    },
    ɵXSS_SECURITY_URL: function() {
        return XSS_SECURITY_URL;
    },
    ɵ_sanitizeHtml: function() {
        return _sanitizeHtml;
    },
    ɵ_sanitizeUrl: function() {
        return _sanitizeUrl;
    },
    ɵallowSanitizationBypassAndThrow: function() {
        return allowSanitizationBypassAndThrow;
    },
    ɵbypassSanitizationTrustHtml: function() {
        return bypassSanitizationTrustHtml;
    },
    ɵbypassSanitizationTrustResourceUrl: function() {
        return bypassSanitizationTrustResourceUrl;
    },
    ɵbypassSanitizationTrustScript: function() {
        return bypassSanitizationTrustScript;
    },
    ɵbypassSanitizationTrustStyle: function() {
        return bypassSanitizationTrustStyle;
    },
    ɵbypassSanitizationTrustUrl: function() {
        return bypassSanitizationTrustUrl;
    },
    ɵcoerceToBoolean: function() {
        return coerceToBoolean;
    },
    ɵfindLocaleData: function() {
        return findLocaleData;
    },
    ɵformatRuntimeError: function() {
        return formatRuntimeError;
    },
    ɵgetLocalePluralCase: function() {
        return getLocalePluralCase;
    },
    ɵglobal: function() {
        return _global;
    },
    ɵisInjectable: function() {
        return isInjectable;
    },
    ɵisNgModule: function() {
        return isNgModule;
    },
    ɵisPromise: function() {
        return isPromise;
    },
    ɵisSubscribable: function() {
        return isSubscribable;
    },
    ɵsetDocument: function() {
        return setDocument;
    },
    ɵstringify: function() {
        return stringify;
    },
    ɵunwrapSafeValue: function() {
        return unwrapSafeValue;
    },
    ɵɵNgOnChangesFeature: function() {
        return ɵɵNgOnChangesFeature;
    },
    ɵɵStandaloneFeature: function() {
        return ɵɵStandaloneFeature;
    },
    ɵɵadvance: function() {
        return ɵɵadvance;
    },
    ɵɵattribute: function() {
        return ɵɵattribute;
    },
    ɵɵcontentQuery: function() {
        return ɵɵcontentQuery;
    },
    ɵɵdefineComponent: function() {
        return ɵɵdefineComponent;
    },
    ɵɵdefineDirective: function() {
        return ɵɵdefineDirective;
    },
    ɵɵdefineInjectable: function() {
        return ɵɵdefineInjectable;
    },
    ɵɵdefineInjector: function() {
        return ɵɵdefineInjector;
    },
    ɵɵdefineNgModule: function() {
        return ɵɵdefineNgModule;
    },
    ɵɵdefinePipe: function() {
        return ɵɵdefinePipe;
    },
    ɵɵdirectiveInject: function() {
        return ɵɵdirectiveInject;
    },
    ɵɵelement: function() {
        return ɵɵelement;
    },
    ɵɵelementEnd: function() {
        return ɵɵelementEnd;
    },
    ɵɵelementStart: function() {
        return ɵɵelementStart;
    },
    ɵɵgetCurrentView: function() {
        return ɵɵgetCurrentView;
    },
    ɵɵgetInheritedFactory: function() {
        return ɵɵgetInheritedFactory;
    },
    ɵɵinject: function() {
        return ɵɵinject;
    },
    ɵɵinjectAttribute: function() {
        return ɵɵinjectAttribute;
    },
    ɵɵinvalidFactory: function() {
        return ɵɵinvalidFactory;
    },
    ɵɵlistener: function() {
        return ɵɵlistener;
    },
    ɵɵloadQuery: function() {
        return ɵɵloadQuery;
    },
    ɵɵnamespaceHTML: function() {
        return ɵɵnamespaceHTML;
    },
    ɵɵnamespaceSVG: function() {
        return ɵɵnamespaceSVG;
    },
    ɵɵproperty: function() {
        return ɵɵproperty;
    },
    ɵɵqueryRefresh: function() {
        return ɵɵqueryRefresh;
    },
    ɵɵreference: function() {
        return ɵɵreference;
    },
    ɵɵresetView: function() {
        return ɵɵresetView;
    },
    ɵɵrestoreView: function() {
        return ɵɵrestoreView;
    },
    ɵɵsanitizeUrlOrResourceUrl: function() {
        return ɵɵsanitizeUrlOrResourceUrl;
    },
    ɵɵstyleProp: function() {
        return ɵɵstyleProp;
    },
    ɵɵtemplate: function() {
        return ɵɵtemplate;
    },
    ɵɵtext: function() {
        return ɵɵtext;
    },
    ɵɵtextInterpolate1: function() {
        return ɵɵtextInterpolate1;
    }
});
var _object_spread = __webpack_require__("../../node_modules/@swc/helpers/esm/_object_spread.js");
var _object_spread_props = __webpack_require__("../../node_modules/@swc/helpers/esm/_object_spread_props.js");
var _index = __webpack_require__("../../node_modules/rxjs/dist/esm5/index.js");
var _index1 = __webpack_require__("../../node_modules/rxjs/dist/esm5/operators/index.js");
function getClosureSafeProperty(objWithPropertyToExtract) {
    for(let key in objWithPropertyToExtract){
        if (objWithPropertyToExtract[key] === getClosureSafeProperty) return key;
    }
    throw Error('Could not find renamed property on target object.');
}
function fillProperties(target, source) {
    for(const key in source)if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) target[key] = source[key];
}
function stringify(token) {
    if (typeof token === 'string') return token;
    if (Array.isArray(token)) return '[' + token.map(stringify).join(', ') + ']';
    if (token == null) return '' + token;
    if (token.overriddenName) return `${token.overriddenName}`;
    if (token.name) return `${token.name}`;
    const res = token.toString();
    if (res == null) return '' + res;
    const newLineIndex = res.indexOf('\n');
    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}
function concatStringsWithSpace(before, after) {
    return before == null || before === '' ? after === null ? '' : after : after == null || after === '' ? before : before + ' ' + after;
}
const __forward_ref__ = getClosureSafeProperty({
    __forward_ref__: getClosureSafeProperty
});
function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function() {
        return stringify(this());
    };
    return forwardRefFn;
}
function resolveForwardRef(type) {
    return isForwardRef(type) ? type() : type;
}
function isForwardRef(fn) {
    return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
}
function isEnvironmentProviders(value) {
    return value && !!value.ɵproviders;
}
const ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';
const XSS_SECURITY_URL = 'https://g.co/ng/security#xss';
class RuntimeError extends Error {
    constructor(code, message){
        super(formatRuntimeError(code, message));
        this.code = code;
    }
}
function formatRuntimeError(code, message) {
    const fullCode = `NG0${Math.abs(code)}`;
    let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;
    if (ngDevMode && code < 0) {
        const addPeriodSeparator = !errorMessage.match(/[.,;!?\n]$/);
        const separator = addPeriodSeparator ? '.' : '';
        errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
    }
    return errorMessage;
}
function renderStringify(value) {
    if (typeof value === 'string') return value;
    if (value == null) return '';
    return String(value);
}
function stringifyForError(value) {
    if (typeof value === 'function') return value.name || value.toString();
    if (typeof value === 'object' && value != null && typeof value.type === 'function') return value.type.name || value.type.toString();
    return renderStringify(value);
}
function throwCyclicDependencyError(token, path) {
    const depPath = path ? `. Dependency path: ${path.join(' > ')} > ${token}` : '';
    throw new RuntimeError(-200, `Circular dependency in DI detected for ${token}${depPath}`);
}
function throwMixedMultiProviderError() {
    throw new Error(`Cannot mix multi providers and regular providers`);
}
function throwInvalidProviderError(ngModuleType, providers, provider) {
    if (ngModuleType && providers) {
        const providerDetail = providers.map((v)=>v == provider ? '?' + provider + '?' : '...');
        throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);
    } else if (isEnvironmentProviders(provider)) {
        if (provider.ɵfromNgModule) throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);
        else throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);
    } else throw new Error('Invalid provider');
}
function throwProviderNotFoundError(token, injectorName) {
    const injectorDetails = injectorName ? ` in ${injectorName}` : '';
    throw new RuntimeError(-201, ngDevMode && `No provider for ${stringifyForError(token)} found${injectorDetails}`);
}
function assertNumber(actual, msg) {
    if (!(typeof actual === 'number')) throwError(msg, typeof actual, 'number', '===');
}
function assertNumberInRange(actual, minInclusive, maxInclusive) {
    assertNumber(actual, 'Expected a number');
    assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');
    assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');
}
function assertString(actual, msg) {
    if (!(typeof actual === 'string')) throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');
}
function assertFunction(actual, msg) {
    if (!(typeof actual === 'function')) throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');
}
function assertEqual(actual, expected, msg) {
    if (!(actual == expected)) throwError(msg, actual, expected, '==');
}
function assertNotEqual(actual, expected, msg) {
    if (!(actual != expected)) throwError(msg, actual, expected, '!=');
}
function assertSame(actual, expected, msg) {
    if (!(actual === expected)) throwError(msg, actual, expected, '===');
}
function assertNotSame(actual, expected, msg) {
    if (!(actual !== expected)) throwError(msg, actual, expected, '!==');
}
function assertLessThan(actual, expected, msg) {
    if (!(actual < expected)) throwError(msg, actual, expected, '<');
}
function assertLessThanOrEqual(actual, expected, msg) {
    if (!(actual <= expected)) throwError(msg, actual, expected, '<=');
}
function assertGreaterThan(actual, expected, msg) {
    if (!(actual > expected)) throwError(msg, actual, expected, '>');
}
function assertGreaterThanOrEqual(actual, expected, msg) {
    if (!(actual >= expected)) throwError(msg, actual, expected, '>=');
}
function assertDefined(actual, msg) {
    if (actual == null) throwError(msg, actual, null, '!=');
}
function throwError(msg, actual, expected, comparison) {
    throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
}
function assertDomNode(node) {
    if (!(typeof Node !== 'undefined' && node instanceof Node) && !(typeof node === 'object' && node != null && node.constructor.name === 'WebWorkerRenderNode')) throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
}
function assertIndexInRange(arr, index) {
    assertDefined(arr, 'Array must be defined.');
    const maxLen = arr.length;
    if (index < 0 || index >= maxLen) throwError(`Index expected to be less than ${maxLen} but got ${index}`);
}
function assertOneOf(value, ...validValues) {
    if (validValues.indexOf(value) !== -1) return true;
    throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
}
function ɵɵdefineInjectable(opts) {
    return {
        token: opts.token,
        providedIn: opts.providedIn || null,
        factory: opts.factory,
        value: undefined
    };
}
function ɵɵdefineInjector(options) {
    return {
        providers: options.providers || [],
        imports: options.imports || []
    };
}
function getInjectableDef(type) {
    return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);
}
function isInjectable(type) {
    return getInjectableDef(type) !== null;
}
function getOwnDefinition(type, field) {
    return type.hasOwnProperty(field) ? type[field] : null;
}
function getInheritedInjectableDef(type) {
    const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);
    if (def) {
        ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.\n` + `This will become an error in a future version of Angular. Please add @Injectable() to the "${type.name}" class.`);
        return def;
    } else return null;
}
function getInjectorDef(type) {
    return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;
}
const NG_PROV_DEF = getClosureSafeProperty({
    ɵprov: getClosureSafeProperty
});
const NG_INJ_DEF = getClosureSafeProperty({
    ɵinj: getClosureSafeProperty
});
const NG_INJECTABLE_DEF = getClosureSafeProperty({
    ngInjectableDef: getClosureSafeProperty
});
const NG_INJECTOR_DEF = getClosureSafeProperty({
    ngInjectorDef: getClosureSafeProperty
});
var InjectFlags = (()=>{
    InjectFlags = InjectFlags || {};
    InjectFlags[InjectFlags["Default"] = 0] = "Default";
    InjectFlags[InjectFlags["Host"] = 1] = "Host";
    InjectFlags[InjectFlags["Self"] = 2] = "Self";
    InjectFlags[InjectFlags["SkipSelf"] = 4] = "SkipSelf";
    InjectFlags[InjectFlags["Optional"] = 8] = "Optional";
    return InjectFlags;
})();
let _injectImplementation;
function getInjectImplementation() {
    return _injectImplementation;
}
function setInjectImplementation(impl) {
    const previous = _injectImplementation;
    _injectImplementation = impl;
    return previous;
}
function injectRootLimpMode(token, notFoundValue, flags) {
    const injectableDef = getInjectableDef(token);
    if (injectableDef && injectableDef.providedIn == 'root') return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() : injectableDef.value;
    if (flags & InjectFlags.Optional) return null;
    if (notFoundValue !== undefined) return notFoundValue;
    throwProviderNotFoundError(stringify(token), 'Injector');
}
function assertInjectImplementationNotEqual(fn) {
    ngDevMode && assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');
}
const _global = (()=>typeof globalThis !== 'undefined' && globalThis || typeof global !== 'undefined' && global || typeof window !== 'undefined' && window || typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self)();
function ngDevModeResetPerfCounters() {
    const locationString = typeof location !== 'undefined' ? location.toString() : '';
    const newCounters = {
        namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,
        firstCreatePass: 0,
        tNode: 0,
        tView: 0,
        rendererCreateTextNode: 0,
        rendererSetText: 0,
        rendererCreateElement: 0,
        rendererAddEventListener: 0,
        rendererSetAttribute: 0,
        rendererRemoveAttribute: 0,
        rendererSetProperty: 0,
        rendererSetClassName: 0,
        rendererAddClass: 0,
        rendererRemoveClass: 0,
        rendererSetStyle: 0,
        rendererRemoveStyle: 0,
        rendererDestroy: 0,
        rendererDestroyNode: 0,
        rendererMoveNode: 0,
        rendererRemoveNode: 0,
        rendererAppendChild: 0,
        rendererInsertBefore: 0,
        rendererCreateComment: 0,
        hydratedNodes: 0,
        hydratedComponents: 0,
        dehydratedViewsRemoved: 0,
        dehydratedViewsCleanupRuns: 0,
        componentsSkippedHydration: 0
    };
    const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;
    _global['ngDevMode'] = allowNgDevModeTrue && newCounters;
    return newCounters;
}
function initNgDevMode() {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
        if (typeof ngDevMode !== 'object') ngDevModeResetPerfCounters();
        return typeof ngDevMode !== 'undefined' && !!ngDevMode;
    }
    return false;
}
const _THROW_IF_NOT_FOUND = {};
const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
const DI_DECORATOR_FLAG = '__NG_DI_FLAG__';
const NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';
const NG_TOKEN_PATH = 'ngTokenPath';
const NEW_LINE = /\n/gm;
const NO_NEW_LINE = 'ɵ';
const SOURCE = '__source';
let _currentInjector = undefined;
function setCurrentInjector(injector) {
    const former = _currentInjector;
    _currentInjector = injector;
    return former;
}
function injectInjectorOnly(token, flags = InjectFlags.Default) {
    if (_currentInjector === undefined) throw new RuntimeError(-203, ngDevMode && `inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \`runInInjectionContext\`.`);
    else if (_currentInjector === null) return injectRootLimpMode(token, undefined, flags);
    else return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);
}
function ɵɵinject(token, flags = InjectFlags.Default) {
    return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
}
function ɵɵinvalidFactoryDep(index) {
    throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);
}
function inject(token, flags = InjectFlags.Default) {
    return ɵɵinject(token, convertToBitFlags(flags));
}
function convertToBitFlags(flags) {
    if (typeof flags === 'undefined' || typeof flags === 'number') return flags;
    return 0 | (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);
}
function injectArgs(types) {
    const args = [];
    for(let i = 0; i < types.length; i++){
        const arg = resolveForwardRef(types[i]);
        if (Array.isArray(arg)) {
            if (arg.length === 0) throw new RuntimeError(900, ngDevMode && 'Arguments array must have arguments.');
            let type = undefined;
            let flags = InjectFlags.Default;
            for(let j = 0; j < arg.length; j++){
                const meta = arg[j];
                const flag = getInjectFlag(meta);
                if (typeof flag === 'number') {
                    if (flag === -1) type = meta.token;
                    else flags |= flag;
                } else type = meta;
            }
            args.push(ɵɵinject(type, flags));
        } else args.push(ɵɵinject(arg));
    }
    return args;
}
function attachInjectFlag(decorator, flag) {
    decorator[DI_DECORATOR_FLAG] = flag;
    decorator.prototype[DI_DECORATOR_FLAG] = flag;
    return decorator;
}
function getInjectFlag(token) {
    return token[DI_DECORATOR_FLAG];
}
function catchInjectorError(e, token, injectorErrorName, source) {
    const tokenPath = e[NG_TEMP_TOKEN_PATH];
    if (token[SOURCE]) tokenPath.unshift(token[SOURCE]);
    e.message = formatError('\n' + e.message, tokenPath, injectorErrorName, source);
    e[NG_TOKEN_PATH] = tokenPath;
    e[NG_TEMP_TOKEN_PATH] = null;
    throw e;
}
function formatError(text, obj, injectorErrorName, source = null) {
    text = text && text.charAt(0) === '\n' && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;
    let context = stringify(obj);
    if (Array.isArray(obj)) context = obj.map(stringify).join(' -> ');
    else if (typeof obj === 'object') {
        let parts = [];
        for(let key in obj)if (obj.hasOwnProperty(key)) {
            let value = obj[key];
            parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));
        }
        context = `{${parts.join(', ')}}`;
    }
    return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\n  ')}`;
}
function noSideEffects(fn) {
    return ({
        toString: fn
    }).toString();
}
var ChangeDetectionStrategy = (()=>{
    ChangeDetectionStrategy = ChangeDetectionStrategy || {};
    ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
    ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
    return ChangeDetectionStrategy;
})();
var ViewEncapsulation$1 = (()=>{
    (function(ViewEncapsulation) {
        ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
        ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
        ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));
    return ViewEncapsulation$1;
})();
const EMPTY_OBJ = {};
const EMPTY_ARRAY = [];
if ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {
    Object.freeze(EMPTY_OBJ);
    Object.freeze(EMPTY_ARRAY);
}
const NG_COMP_DEF = getClosureSafeProperty({
    ɵcmp: getClosureSafeProperty
});
const NG_DIR_DEF = getClosureSafeProperty({
    ɵdir: getClosureSafeProperty
});
const NG_PIPE_DEF = getClosureSafeProperty({
    ɵpipe: getClosureSafeProperty
});
const NG_MOD_DEF = getClosureSafeProperty({
    ɵmod: getClosureSafeProperty
});
const NG_FACTORY_DEF = getClosureSafeProperty({
    ɵfac: getClosureSafeProperty
});
const NG_ELEMENT_ID = getClosureSafeProperty({
    __NG_ELEMENT_ID__: getClosureSafeProperty
});
const NG_ENV_ID = getClosureSafeProperty({
    __NG_ENV_ID__: getClosureSafeProperty
});
function classIndexOf(className, classToSearch, startingIndex) {
    ngDevMode && assertNotEqual(classToSearch, '', 'can not look for "" string.');
    let end = className.length;
    while(true){
        const foundIndex = className.indexOf(classToSearch, startingIndex);
        if (foundIndex === -1) return foundIndex;
        if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
            const length = classToSearch.length;
            if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) return foundIndex;
        }
        startingIndex = foundIndex + 1;
    }
}
function setUpAttributes(renderer, native, attrs) {
    let i = 0;
    while(i < attrs.length){
        const value = attrs[i];
        if (typeof value === 'number') {
            if (value !== 0) break;
            i++;
            const namespaceURI = attrs[i++];
            const attrName = attrs[i++];
            const attrVal = attrs[i++];
            ngDevMode && ngDevMode.rendererSetAttribute++;
            renderer.setAttribute(native, attrName, attrVal, namespaceURI);
        } else {
            const attrName = value;
            const attrVal = attrs[++i];
            ngDevMode && ngDevMode.rendererSetAttribute++;
            if (isAnimationProp(attrName)) renderer.setProperty(native, attrName, attrVal);
            else renderer.setAttribute(native, attrName, attrVal);
            i++;
        }
    }
    return i;
}
function isNameOnlyAttributeMarker(marker) {
    return marker === 3 || marker === 4 || marker === 6;
}
function isAnimationProp(name) {
    return name.charCodeAt(0) === 64;
}
function mergeHostAttrs(dst, src) {
    if (src === null || src.length === 0) ;
    else if (dst === null || dst.length === 0) dst = src.slice();
    else {
        let srcMarker = -1;
        for(let i = 0; i < src.length; i++){
            const item = src[i];
            if (typeof item === 'number') srcMarker = item;
            else {
                if (srcMarker === 0) ;
                else if (srcMarker === -1 || srcMarker === 2) mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
                else mergeHostAttribute(dst, srcMarker, item, null, null);
            }
        }
    }
    return dst;
}
function mergeHostAttribute(dst, marker, key1, key2, value) {
    let i = 0;
    let markerInsertPosition = dst.length;
    if (marker === -1) markerInsertPosition = -1;
    else while(i < dst.length){
        const dstValue = dst[i++];
        if (typeof dstValue === 'number') {
            if (dstValue === marker) {
                markerInsertPosition = -1;
                break;
            } else if (dstValue > marker) {
                markerInsertPosition = i - 1;
                break;
            }
        }
    }
    while(i < dst.length){
        const item = dst[i];
        if (typeof item === 'number') break;
        else if (item === key1) {
            if (key2 === null) {
                if (value !== null) dst[i + 1] = value;
                return;
            } else if (key2 === dst[i + 1]) {
                dst[i + 2] = value;
                return;
            }
        }
        i++;
        if (key2 !== null) i++;
        if (value !== null) i++;
    }
    if (markerInsertPosition !== -1) {
        dst.splice(markerInsertPosition, 0, marker);
        i = markerInsertPosition + 1;
    }
    dst.splice(i++, 0, key1);
    if (key2 !== null) dst.splice(i++, 0, key2);
    if (value !== null) dst.splice(i++, 0, value);
}
const NG_TEMPLATE_SELECTOR = 'ng-template';
function isCssClassMatching(attrs, cssClassToMatch, isProjectionMode) {
    ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), 'Class name expected to be lowercase.');
    let i = 0;
    let isImplicitAttrsSection = true;
    while(i < attrs.length){
        let item = attrs[i++];
        if (typeof item === 'string' && isImplicitAttrsSection) {
            const value = attrs[i++];
            if (isProjectionMode && item === 'class') {
                if (classIndexOf(value.toLowerCase(), cssClassToMatch, 0) !== -1) return true;
            }
        } else if (item === 1) {
            while(i < attrs.length && typeof (item = attrs[i++]) == 'string'){
                if (item.toLowerCase() === cssClassToMatch) return true;
            }
            return false;
        } else if (typeof item === 'number') isImplicitAttrsSection = false;
    }
    return false;
}
function isInlineTemplate(tNode) {
    return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
}
function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
    const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
    return currentSelector === tagNameToCompare;
}
function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
    ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');
    let mode = 4;
    const nodeAttrs = tNode.attrs || [];
    const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);
    let skipToNextSelector = false;
    for(let i = 0; i < selector.length; i++){
        const current = selector[i];
        if (typeof current === 'number') {
            if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) return false;
            if (skipToNextSelector && isPositive(current)) continue;
            skipToNextSelector = false;
            mode = current | mode & 1;
            continue;
        }
        if (skipToNextSelector) continue;
        if (mode & 4) {
            mode = 2 | mode & 1;
            if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === '' && selector.length === 1) {
                if (isPositive(mode)) return false;
                skipToNextSelector = true;
            }
        } else {
            const selectorAttrValue = mode & 8 ? current : selector[++i];
            if (mode & 8 && tNode.attrs !== null) {
                if (!isCssClassMatching(tNode.attrs, selectorAttrValue, isProjectionMode)) {
                    if (isPositive(mode)) return false;
                    skipToNextSelector = true;
                }
                continue;
            }
            const attrName = mode & 8 ? 'class' : current;
            const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
            if (attrIndexInNode === -1) {
                if (isPositive(mode)) return false;
                skipToNextSelector = true;
                continue;
            }
            if (selectorAttrValue !== '') {
                let nodeAttrValue;
                if (attrIndexInNode > nameOnlyMarkerIdx) nodeAttrValue = '';
                else {
                    ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0, 'We do not match directives on namespaced attributes');
                    nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
                }
                const compareAgainstClassName = mode & 8 ? nodeAttrValue : null;
                if (compareAgainstClassName && classIndexOf(compareAgainstClassName, selectorAttrValue, 0) !== -1 || mode & 2 && selectorAttrValue !== nodeAttrValue) {
                    if (isPositive(mode)) return false;
                    skipToNextSelector = true;
                }
            }
        }
    }
    return isPositive(mode) || skipToNextSelector;
}
function isPositive(mode) {
    return (mode & 1) === 0;
}
function findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {
    if (attrs === null) return -1;
    let i = 0;
    if (isProjectionMode || !isInlineTemplate) {
        let bindingsMode = false;
        while(i < attrs.length){
            const maybeAttrName = attrs[i];
            if (maybeAttrName === name) return i;
            else if (maybeAttrName === 3 || maybeAttrName === 6) bindingsMode = true;
            else if (maybeAttrName === 1 || maybeAttrName === 2) {
                let value = attrs[++i];
                while(typeof value === 'string')value = attrs[++i];
                continue;
            } else if (maybeAttrName === 4) break;
            else if (maybeAttrName === 0) {
                i += 4;
                continue;
            }
            i += bindingsMode ? 1 : 2;
        }
        return -1;
    } else return matchTemplateAttribute(attrs, name);
}
function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
    for(let i = 0; i < selector.length; i++){
        if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) return true;
    }
    return false;
}
function getProjectAsAttrValue(tNode) {
    const nodeAttrs = tNode.attrs;
    if (nodeAttrs != null) {
        const ngProjectAsAttrIdx = nodeAttrs.indexOf(5);
        if ((ngProjectAsAttrIdx & 1) === 0) return nodeAttrs[ngProjectAsAttrIdx + 1];
    }
    return null;
}
function getNameOnlyMarkerIndex(nodeAttrs) {
    for(let i = 0; i < nodeAttrs.length; i++){
        const nodeAttr = nodeAttrs[i];
        if (isNameOnlyAttributeMarker(nodeAttr)) return i;
    }
    return nodeAttrs.length;
}
function matchTemplateAttribute(attrs, name) {
    let i = attrs.indexOf(4);
    if (i > -1) {
        i++;
        while(i < attrs.length){
            const attr = attrs[i];
            if (typeof attr === 'number') return -1;
            if (attr === name) return i;
            i++;
        }
    }
    return -1;
}
function isSelectorInSelectorList(selector, list) {
    selectorListLoop: for(let i = 0; i < list.length; i++){
        const currentSelectorInList = list[i];
        if (selector.length !== currentSelectorInList.length) continue;
        for(let j = 0; j < selector.length; j++){
            if (selector[j] !== currentSelectorInList[j]) continue selectorListLoop;
        }
        return true;
    }
    return false;
}
function maybeWrapInNotSelector(isNegativeMode, chunk) {
    return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;
}
function stringifyCSSSelector(selector) {
    let result = selector[0];
    let i = 1;
    let mode = 2;
    let currentChunk = '';
    let isNegativeMode = false;
    while(i < selector.length){
        let valueOrMarker = selector[i];
        if (typeof valueOrMarker === 'string') {
            if (mode & 2) {
                const attrValue = selector[++i];
                currentChunk += '[' + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : '') + ']';
            } else if (mode & 8) currentChunk += '.' + valueOrMarker;
            else if (mode & 4) currentChunk += ' ' + valueOrMarker;
        } else {
            if (currentChunk !== '' && !isPositive(valueOrMarker)) {
                result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
                currentChunk = '';
            }
            mode = valueOrMarker;
            isNegativeMode = isNegativeMode || !isPositive(mode);
        }
        i++;
    }
    if (currentChunk !== '') result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
    return result;
}
function stringifyCSSSelectorList(selectorList) {
    return selectorList.map(stringifyCSSSelector).join(',');
}
function extractAttrsAndClassesFromSelector(selector) {
    const attrs = [];
    const classes = [];
    let i = 1;
    let mode = 2;
    while(i < selector.length){
        let valueOrMarker = selector[i];
        if (typeof valueOrMarker === 'string') {
            if (mode === 2) {
                if (valueOrMarker !== '') attrs.push(valueOrMarker, selector[++i]);
            } else if (mode === 8) classes.push(valueOrMarker);
        } else {
            if (!isPositive(mode)) break;
            mode = valueOrMarker;
        }
        i++;
    }
    return {
        attrs,
        classes
    };
}
function ɵɵdefineComponent(componentDefinition) {
    return noSideEffects(()=>{
        (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();
        const baseDef = getNgDirectiveDef(componentDefinition);
        const def = _object_spread_props._(_object_spread._({}, baseDef), {
            decls: componentDefinition.decls,
            vars: componentDefinition.vars,
            template: componentDefinition.template,
            consts: componentDefinition.consts || null,
            ngContentSelectors: componentDefinition.ngContentSelectors,
            onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
            directiveDefs: null,
            pipeDefs: null,
            dependencies: baseDef.standalone && componentDefinition.dependencies || null,
            getStandaloneInjector: null,
            data: componentDefinition.data || {},
            encapsulation: componentDefinition.encapsulation || ViewEncapsulation$1.Emulated,
            styles: componentDefinition.styles || EMPTY_ARRAY,
            _: null,
            schemas: componentDefinition.schemas || null,
            tView: null,
            id: ''
        });
        initFeatures(def);
        const dependencies = componentDefinition.dependencies;
        def.directiveDefs = extractDefListOrFactory(dependencies, false);
        def.pipeDefs = extractDefListOrFactory(dependencies, true);
        def.id = getComponentId(def);
        return def;
    });
}
function ɵɵsetComponentScope(type, directives, pipes) {
    const def = type.ɵcmp;
    def.directiveDefs = extractDefListOrFactory(directives, false);
    def.pipeDefs = extractDefListOrFactory(pipes, true);
}
function extractDirectiveDef(type) {
    return getComponentDef(type) || getDirectiveDef(type);
}
function nonNull(value) {
    return value !== null;
}
function ɵɵdefineNgModule(def) {
    return noSideEffects(()=>{
        const res = {
            type: def.type,
            bootstrap: def.bootstrap || EMPTY_ARRAY,
            declarations: def.declarations || EMPTY_ARRAY,
            imports: def.imports || EMPTY_ARRAY,
            exports: def.exports || EMPTY_ARRAY,
            transitiveCompileScopes: null,
            schemas: def.schemas || null,
            id: def.id || null
        };
        return res;
    });
}
function ɵɵsetNgModuleScope(type, scope) {
    return noSideEffects(()=>{
        const ngModuleDef = getNgModuleDef(type, true);
        ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;
        ngModuleDef.imports = scope.imports || EMPTY_ARRAY;
        ngModuleDef.exports = scope.exports || EMPTY_ARRAY;
    });
}
function invertObject(obj, secondary) {
    if (obj == null) return EMPTY_OBJ;
    const newLookup = {};
    for(const minifiedKey in obj)if (obj.hasOwnProperty(minifiedKey)) {
        let publicName = obj[minifiedKey];
        let declaredName = publicName;
        if (Array.isArray(publicName)) {
            declaredName = publicName[1];
            publicName = publicName[0];
        }
        newLookup[publicName] = minifiedKey;
        if (secondary) secondary[publicName] = declaredName;
    }
    return newLookup;
}
function ɵɵdefineDirective(directiveDefinition) {
    return noSideEffects(()=>{
        const def = getNgDirectiveDef(directiveDefinition);
        initFeatures(def);
        return def;
    });
}
function ɵɵdefinePipe(pipeDef) {
    return {
        type: pipeDef.type,
        name: pipeDef.name,
        factory: null,
        pure: pipeDef.pure !== false,
        standalone: pipeDef.standalone === true,
        onDestroy: pipeDef.type.prototype.ngOnDestroy || null
    };
}
function getComponentDef(type) {
    return type[NG_COMP_DEF] || null;
}
function getDirectiveDef(type) {
    return type[NG_DIR_DEF] || null;
}
function getPipeDef$1(type) {
    return type[NG_PIPE_DEF] || null;
}
function isStandalone(type) {
    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
    return def !== null ? def.standalone : false;
}
function getNgModuleDef(type, throwNotFound) {
    const ngModuleDef = type[NG_MOD_DEF] || null;
    if (!ngModuleDef && throwNotFound === true) throw new Error(`Type ${stringify(type)} does not have 'ɵmod' property.`);
    return ngModuleDef;
}
function getNgDirectiveDef(directiveDefinition) {
    const declaredInputs = {};
    return {
        type: directiveDefinition.type,
        providersResolver: null,
        factory: null,
        hostBindings: directiveDefinition.hostBindings || null,
        hostVars: directiveDefinition.hostVars || 0,
        hostAttrs: directiveDefinition.hostAttrs || null,
        contentQueries: directiveDefinition.contentQueries || null,
        declaredInputs,
        exportAs: directiveDefinition.exportAs || null,
        standalone: directiveDefinition.standalone === true,
        selectors: directiveDefinition.selectors || EMPTY_ARRAY,
        viewQuery: directiveDefinition.viewQuery || null,
        features: directiveDefinition.features || null,
        setInput: null,
        findHostDirectiveDefs: null,
        hostDirectives: null,
        inputs: invertObject(directiveDefinition.inputs, declaredInputs),
        outputs: invertObject(directiveDefinition.outputs)
    };
}
function initFeatures(definition) {
    var _definition_features;
    (_definition_features = definition.features) === null || _definition_features === void 0 || _definition_features.forEach((fn)=>fn(definition));
}
function extractDefListOrFactory(dependencies, pipeDef) {
    if (!dependencies) return null;
    const defExtractor = pipeDef ? getPipeDef$1 : extractDirectiveDef;
    return ()=>(typeof dependencies === 'function' ? dependencies() : dependencies).map((dep)=>defExtractor(dep)).filter(nonNull);
}
const GENERATED_COMP_IDS = new Map();
function getComponentId(componentDef) {
    let hash = 0;
    const hashSelectors = [
        componentDef.selectors,
        componentDef.ngContentSelectors,
        componentDef.hostVars,
        componentDef.hostAttrs,
        componentDef.consts,
        componentDef.vars,
        componentDef.decls,
        componentDef.encapsulation,
        componentDef.standalone,
        Object.getOwnPropertyNames(componentDef.type.prototype),
        !!componentDef.contentQueries,
        !!componentDef.viewQuery
    ].join('|');
    for (const char of hashSelectors)hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
    hash += 2147483648;
    const compId = 'c' + hash;
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
        if (GENERATED_COMP_IDS.has(compId)) {
            const previousCompDefType = GENERATED_COMP_IDS.get(compId);
            if (previousCompDefType !== componentDef.type) console.warn(formatRuntimeError(-912, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));
        } else GENERATED_COMP_IDS.set(compId, componentDef.type);
    }
    return compId;
}
const HOST = 0;
const TVIEW = 1;
const FLAGS = 2;
const PARENT = 3;
const NEXT = 4;
const DESCENDANT_VIEWS_TO_REFRESH = 5;
const T_HOST = 6;
const CLEANUP = 7;
const CONTEXT = 8;
const INJECTOR$1 = 9;
const ENVIRONMENT = 10;
const RENDERER = 11;
const CHILD_HEAD = 12;
const CHILD_TAIL = 13;
const DECLARATION_VIEW = 14;
const DECLARATION_COMPONENT_VIEW = 15;
const DECLARATION_LCONTAINER = 16;
const PREORDER_HOOK_FLAGS = 17;
const QUERIES = 18;
const ID = 19;
const EMBEDDED_VIEW_INJECTOR = 20;
const ON_DESTROY_HOOKS = 21;
const HYDRATION = 22;
const REACTIVE_TEMPLATE_CONSUMER = 23;
const REACTIVE_HOST_BINDING_CONSUMER = 24;
const HEADER_OFFSET = 25;
const TYPE = 1;
const HAS_TRANSPLANTED_VIEWS = 2;
const NATIVE = 7;
const VIEW_REFS = 8;
const MOVED_VIEWS = 9;
const CONTAINER_HEADER_OFFSET = 11;
function isLView(value) {
    return Array.isArray(value) && typeof value[TYPE] === 'object';
}
function isLContainer(value) {
    return Array.isArray(value) && value[TYPE] === true;
}
function isContentQueryHost(tNode) {
    return (tNode.flags & 4) !== 0;
}
function isComponentHost(tNode) {
    return tNode.componentOffset > -1;
}
function isDirectiveHost(tNode) {
    return (tNode.flags & 1) === 1;
}
function isComponentDef(def) {
    return !!def.template;
}
function isRootView(target) {
    return (target[FLAGS] & 512) !== 0;
}
function assertTNodeForLView(tNode, lView) {
    assertTNodeForTView(tNode, lView[TVIEW]);
}
function assertTNodeForTView(tNode, tView) {
    assertTNode(tNode);
    tNode.hasOwnProperty('tView_') && assertEqual(tNode.tView_, tView, 'This TNode does not belong to this TView.');
}
function assertTNode(tNode) {
    assertDefined(tNode, 'TNode must be defined');
    if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) throwError('Not of type TNode, got: ' + tNode);
}
function assertTIcu(tIcu) {
    assertDefined(tIcu, 'Expected TIcu to be defined');
    if (!(typeof tIcu.currentCaseLViewIndex === 'number')) throwError('Object is not of TIcu type.');
}
function assertComponentType(actual, msg = 'Type passed in is not ComponentType, it does not have \'ɵcmp\' property.') {
    if (!getComponentDef(actual)) throwError(msg);
}
function assertNgModuleType(actual, msg = 'Type passed in is not NgModuleType, it does not have \'ɵmod\' property.') {
    if (!getNgModuleDef(actual)) throwError(msg);
}
function assertHasParent(tNode) {
    assertDefined(tNode, 'currentTNode should exist!');
    assertDefined(tNode.parent, 'currentTNode should have a parent');
}
function assertLContainer(value) {
    assertDefined(value, 'LContainer must be defined');
    assertEqual(isLContainer(value), true, 'Expecting LContainer');
}
function assertLViewOrUndefined(value) {
    value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');
}
function assertLView(value) {
    assertDefined(value, 'LView must be defined');
    assertEqual(isLView(value), true, 'Expecting LView');
}
function assertFirstCreatePass(tView, errMessage) {
    assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');
}
function assertFirstUpdatePass(tView, errMessage) {
    assertEqual(tView.firstUpdatePass, true, errMessage || 'Should only be called in first update pass.');
}
function assertDirectiveDef(obj) {
    if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
}
function assertIndexInDeclRange(lView, index) {
    const tView = lView[1];
    assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
}
function assertIndexInExpandoRange(lView, index) {
    const tView = lView[1];
    assertBetween(tView.expandoStartIndex, lView.length, index);
}
function assertBetween(lower, upper, index) {
    if (!(lower <= index && index < upper)) throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
}
function assertProjectionSlots(lView, errMessage) {
    assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');
    assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage || 'Components with projection nodes (<ng-content>) must have projection slots defined.');
}
function assertParentView(lView, errMessage) {
    assertDefined(lView, errMessage || 'Component views should always have a parent view (component\'s host view)');
}
function assertNodeInjector(lView, injectorIndex) {
    assertIndexInExpandoRange(lView, injectorIndex);
    assertIndexInExpandoRange(lView, injectorIndex + 8);
    assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');
    assertNumber(lView[injectorIndex + 8], 'injectorIndex should point to parent injector');
}
function getFactoryDef(type, throwNotFound) {
    const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
    if (!hasFactoryDef && throwNotFound === true && ngDevMode) throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);
    return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
}
Symbol('SIGNAL');
class LeakyRef {
    deref() {
        return this.ref;
    }
    constructor(ref){
        this.ref = ref;
    }
}
var _global_WeakRef;
let WeakRefImpl = (_global_WeakRef = _global['WeakRef']) !== null && _global_WeakRef !== void 0 ? _global_WeakRef : LeakyRef;
function newWeakRef(value) {
    if (typeof ngDevMode !== 'undefined' && ngDevMode && WeakRefImpl === undefined) throw new Error(`Angular requires a browser which supports the 'WeakRef' API`);
    return new WeakRefImpl(value);
}
let _nextReactiveId = 0;
let activeConsumer = null;
let inNotificationPhase = false;
function setActiveConsumer(consumer) {
    const prev = activeConsumer;
    activeConsumer = consumer;
    return prev;
}
class ReactiveNode {
    consumerPollProducersForChange() {
        for (const [producerId, edge] of this.producers){
            const producer = edge.producerNode.deref();
            if (producer === undefined || edge.atTrackingVersion !== this.trackingVersion) {
                this.producers.delete(producerId);
                producer === null || producer === void 0 || producer.consumers.delete(this.id);
                continue;
            }
            if (producer.producerPollStatus(edge.seenValueVersion)) return true;
        }
        return false;
    }
    producerMayHaveChanged() {
        const prev = inNotificationPhase;
        inNotificationPhase = true;
        try {
            for (const [consumerId, edge] of this.consumers){
                const consumer = edge.consumerNode.deref();
                if (consumer === undefined || consumer.trackingVersion !== edge.atTrackingVersion) {
                    this.consumers.delete(consumerId);
                    consumer === null || consumer === void 0 || consumer.producers.delete(this.id);
                    continue;
                }
                consumer.onConsumerDependencyMayHaveChanged();
            }
        } finally{
            inNotificationPhase = prev;
        }
    }
    producerAccessed() {
        if (inNotificationPhase) throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');
        if (activeConsumer === null) return;
        let edge = activeConsumer.producers.get(this.id);
        if (edge === undefined) {
            edge = {
                consumerNode: activeConsumer.ref,
                producerNode: this.ref,
                seenValueVersion: this.valueVersion,
                atTrackingVersion: activeConsumer.trackingVersion
            };
            activeConsumer.producers.set(this.id, edge);
            this.consumers.set(activeConsumer.id, edge);
        } else {
            edge.seenValueVersion = this.valueVersion;
            edge.atTrackingVersion = activeConsumer.trackingVersion;
        }
    }
    get hasProducers() {
        return this.producers.size > 0;
    }
    get producerUpdatesAllowed() {
        return (activeConsumer === null || activeConsumer === void 0 ? void 0 : activeConsumer.consumerAllowSignalWrites) !== false;
    }
    producerPollStatus(lastSeenValueVersion) {
        if (this.valueVersion !== lastSeenValueVersion) return true;
        this.onProducerUpdateValueVersion();
        return this.valueVersion !== lastSeenValueVersion;
    }
    constructor(){
        this.id = _nextReactiveId++;
        this.ref = newWeakRef(this);
        this.producers = new Map();
        this.consumers = new Map();
        this.trackingVersion = 0;
        this.valueVersion = 0;
    }
}
Symbol('UNSET');
Symbol('COMPUTING');
Symbol('ERRORED');
function setThrowInvalidWriteToSignalError(fn) {
    fn;
}
const NOOP_CLEANUP_FN = ()=>{};
class Watch extends ReactiveNode {
    notify() {
        if (!this.dirty) this.schedule(this);
        this.dirty = true;
    }
    onConsumerDependencyMayHaveChanged() {
        this.notify();
    }
    onProducerUpdateValueVersion() {}
    run() {
        this.dirty = false;
        if (this.trackingVersion !== 0 && !this.consumerPollProducersForChange()) return;
        const prevConsumer = setActiveConsumer(this);
        this.trackingVersion++;
        try {
            this.cleanupFn();
            this.cleanupFn = NOOP_CLEANUP_FN;
            this.watch(this.registerOnCleanup);
        } finally{
            setActiveConsumer(prevConsumer);
        }
    }
    cleanup() {
        this.cleanupFn();
    }
    constructor(watch, schedule, allowSignalWrites){
        super();
        this.watch = watch;
        this.schedule = schedule;
        this.dirty = false;
        this.cleanupFn = NOOP_CLEANUP_FN;
        this.registerOnCleanup = (cleanupFn)=>{
            this.cleanupFn = cleanupFn;
        };
        this.consumerAllowSignalWrites = allowSignalWrites;
    }
}
class SimpleChange {
    isFirstChange() {
        return this.firstChange;
    }
    constructor(previousValue, currentValue, firstChange){
        this.previousValue = previousValue;
        this.currentValue = currentValue;
        this.firstChange = firstChange;
    }
}
function ɵɵNgOnChangesFeature() {
    return NgOnChangesFeatureImpl;
}
function NgOnChangesFeatureImpl(definition) {
    if (definition.type.prototype.ngOnChanges) definition.setInput = ngOnChangesSetInput;
    return rememberChangeHistoryAndInvokeOnChangesHook;
}
ɵɵNgOnChangesFeature.ngInherit = true;
function rememberChangeHistoryAndInvokeOnChangesHook() {
    const simpleChangesStore = getSimpleChangesStore(this);
    const current = simpleChangesStore === null || simpleChangesStore === void 0 ? void 0 : simpleChangesStore.current;
    if (current) {
        const previous = simpleChangesStore.previous;
        if (previous === EMPTY_OBJ) simpleChangesStore.previous = current;
        else for(let key in current)previous[key] = current[key];
        simpleChangesStore.current = null;
        this.ngOnChanges(current);
    }
}
function ngOnChangesSetInput(instance, value, publicName, privateName) {
    const declaredName = this.declaredInputs[publicName];
    ngDevMode && assertString(declaredName, 'Name of input in ngOnChanges has to be a string');
    const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, {
        previous: EMPTY_OBJ,
        current: null
    });
    const current = simpleChangesStore.current || (simpleChangesStore.current = {});
    const previous = simpleChangesStore.previous;
    const previousChange = previous[declaredName];
    current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);
    instance[privateName] = value;
}
const SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';
function getSimpleChangesStore(instance) {
    return instance[SIMPLE_CHANGES_STORE] || null;
}
function setSimpleChangesStore(instance, store) {
    return instance[SIMPLE_CHANGES_STORE] = store;
}
let profilerCallback = null;
const setProfiler = (profiler)=>{
    profilerCallback = profiler;
};
const profiler = function(event, instance, hookOrListener) {
    if (profilerCallback != null) profilerCallback(event, instance, hookOrListener);
};
const SVG_NAMESPACE = 'svg';
const MATH_ML_NAMESPACE = 'math';
function unwrapRNode(value) {
    while(Array.isArray(value))value = value[HOST];
    return value;
}
function unwrapLView(value) {
    while(Array.isArray(value)){
        if (typeof value[TYPE] === 'object') return value;
        value = value[HOST];
    }
    return null;
}
function getNativeByIndex(index, lView) {
    ngDevMode && assertIndexInRange(lView, index);
    ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');
    return unwrapRNode(lView[index]);
}
function getNativeByTNode(tNode, lView) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    ngDevMode && assertIndexInRange(lView, tNode.index);
    const node = unwrapRNode(lView[tNode.index]);
    return node;
}
function getTNode(tView, index) {
    ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');
    ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');
    const tNode = tView.data[index];
    ngDevMode && tNode !== null && assertTNode(tNode);
    return tNode;
}
function load(view, index) {
    ngDevMode && assertIndexInRange(view, index);
    return view[index];
}
function getComponentLViewByIndex(nodeIndex, hostView) {
    ngDevMode && assertIndexInRange(hostView, nodeIndex);
    const slotValue = hostView[nodeIndex];
    const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
    return lView;
}
function isCreationMode(view) {
    return (view[FLAGS] & 4) === 4;
}
function viewAttachedToChangeDetector(view) {
    return (view[FLAGS] & 128) === 128;
}
function viewAttachedToContainer(view) {
    return isLContainer(view[PARENT]);
}
function getConstant(consts, index) {
    if (index === null || index === undefined) return null;
    ngDevMode && assertIndexInRange(consts, index);
    return consts[index];
}
function resetPreOrderHookFlags(lView) {
    lView[PREORDER_HOOK_FLAGS] = 0;
}
function markViewForRefresh(lView) {
    if ((lView[FLAGS] & 1024) === 0) {
        lView[FLAGS] |= 1024;
        updateViewsToRefresh(lView, 1);
    }
}
function clearViewRefreshFlag(lView) {
    if (lView[FLAGS] & 1024) {
        lView[FLAGS] &= -1025;
        updateViewsToRefresh(lView, -1);
    }
}
function updateViewsToRefresh(lView, amount) {
    let parent = lView[PARENT];
    if (parent === null) return;
    parent[DESCENDANT_VIEWS_TO_REFRESH] += amount;
    let viewOrContainer = parent;
    parent = parent[PARENT];
    while(parent !== null && (amount === 1 && viewOrContainer[DESCENDANT_VIEWS_TO_REFRESH] === 1 || amount === -1 && viewOrContainer[DESCENDANT_VIEWS_TO_REFRESH] === 0)){
        parent[DESCENDANT_VIEWS_TO_REFRESH] += amount;
        viewOrContainer = parent;
        parent = parent[PARENT];
    }
}
function storeLViewOnDestroy(lView, onDestroyCallback) {
    if ((lView[FLAGS] & 256) === 256) throw new RuntimeError(911, ngDevMode && 'View has already been destroyed.');
    if (lView[ON_DESTROY_HOOKS] === null) lView[ON_DESTROY_HOOKS] = [];
    lView[ON_DESTROY_HOOKS].push(onDestroyCallback);
}
function removeLViewOnDestroy(lView, onDestroyCallback) {
    if (lView[ON_DESTROY_HOOKS] === null) return;
    const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);
    if (destroyCBIdx !== -1) lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);
}
const instructionState = {
    lFrame: createLFrame(null),
    bindingsEnabled: true,
    skipHydrationRootTNode: null
};
let _isInCheckNoChangesMode = false;
function getElementDepthCount() {
    return instructionState.lFrame.elementDepthCount;
}
function increaseElementDepthCount() {
    instructionState.lFrame.elementDepthCount++;
}
function decreaseElementDepthCount() {
    instructionState.lFrame.elementDepthCount--;
}
function getBindingsEnabled() {
    return instructionState.bindingsEnabled;
}
function isInSkipHydrationBlock$1() {
    return instructionState.skipHydrationRootTNode !== null;
}
function isSkipHydrationRootTNode(tNode) {
    return instructionState.skipHydrationRootTNode === tNode;
}
function ɵɵenableBindings() {
    instructionState.bindingsEnabled = true;
}
function ɵɵdisableBindings() {
    instructionState.bindingsEnabled = false;
}
function leaveSkipHydrationBlock() {
    instructionState.skipHydrationRootTNode = null;
}
function getLView() {
    return instructionState.lFrame.lView;
}
function getTView() {
    return instructionState.lFrame.tView;
}
function ɵɵrestoreView(viewToRestore) {
    instructionState.lFrame.contextLView = viewToRestore;
    return viewToRestore[CONTEXT];
}
function ɵɵresetView(value) {
    instructionState.lFrame.contextLView = null;
    return value;
}
function getCurrentTNode() {
    let currentTNode = getCurrentTNodePlaceholderOk();
    while(currentTNode !== null && currentTNode.type === 64)currentTNode = currentTNode.parent;
    return currentTNode;
}
function getCurrentTNodePlaceholderOk() {
    return instructionState.lFrame.currentTNode;
}
function getCurrentParentTNode() {
    const lFrame = instructionState.lFrame;
    const currentTNode = lFrame.currentTNode;
    return lFrame.isParent ? currentTNode : currentTNode.parent;
}
function setCurrentTNode(tNode, isParent) {
    ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
    const lFrame = instructionState.lFrame;
    lFrame.currentTNode = tNode;
    lFrame.isParent = isParent;
}
function isCurrentTNodeParent() {
    return instructionState.lFrame.isParent;
}
function setCurrentTNodeAsNotParent() {
    instructionState.lFrame.isParent = false;
}
function getContextLView() {
    const contextLView = instructionState.lFrame.contextLView;
    ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');
    return contextLView;
}
function isInCheckNoChangesMode() {
    !ngDevMode && throwError('Must never be called in production mode');
    return _isInCheckNoChangesMode;
}
function setIsInCheckNoChangesMode(mode) {
    !ngDevMode && throwError('Must never be called in production mode');
    _isInCheckNoChangesMode = mode;
}
function getBindingRoot() {
    const lFrame = instructionState.lFrame;
    let index = lFrame.bindingRootIndex;
    if (index === -1) index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
    return index;
}
function getBindingIndex() {
    return instructionState.lFrame.bindingIndex;
}
function setBindingIndex(value) {
    return instructionState.lFrame.bindingIndex = value;
}
function nextBindingIndex() {
    return instructionState.lFrame.bindingIndex++;
}
function incrementBindingIndex(count) {
    const lFrame = instructionState.lFrame;
    const index = lFrame.bindingIndex;
    lFrame.bindingIndex = lFrame.bindingIndex + count;
    return index;
}
function isInI18nBlock() {
    return instructionState.lFrame.inI18n;
}
function setInI18nBlock(isInI18nBlock) {
    instructionState.lFrame.inI18n = isInI18nBlock;
}
function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
    const lFrame = instructionState.lFrame;
    lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
    setCurrentDirectiveIndex(currentDirectiveIndex);
}
function getCurrentDirectiveIndex() {
    return instructionState.lFrame.currentDirectiveIndex;
}
function setCurrentDirectiveIndex(currentDirectiveIndex) {
    instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
}
function getCurrentDirectiveDef(tData) {
    const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
    return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
}
function getCurrentQueryIndex() {
    return instructionState.lFrame.currentQueryIndex;
}
function setCurrentQueryIndex(value) {
    instructionState.lFrame.currentQueryIndex = value;
}
function getDeclarationTNode(lView) {
    const tView = lView[TVIEW];
    if (tView.type === 2) {
        ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');
        return tView.declTNode;
    }
    if (tView.type === 1) return lView[T_HOST];
    return null;
}
function enterDI(lView, tNode, flags) {
    ngDevMode && assertLViewOrUndefined(lView);
    if (flags & InjectFlags.SkipSelf) {
        ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
        let parentTNode = tNode;
        let parentLView = lView;
        while(true){
            ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');
            parentTNode = parentTNode.parent;
            if (parentTNode === null && !(flags & InjectFlags.Host)) {
                parentTNode = getDeclarationTNode(parentLView);
                if (parentTNode === null) break;
                ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');
                parentLView = parentLView[DECLARATION_VIEW];
                if (parentTNode.type & 10) break;
            } else break;
        }
        if (parentTNode === null) return false;
        else {
            tNode = parentTNode;
            lView = parentLView;
        }
    }
    ngDevMode && assertTNodeForLView(tNode, lView);
    const lFrame = instructionState.lFrame = allocLFrame();
    lFrame.currentTNode = tNode;
    lFrame.lView = lView;
    return true;
}
function enterView(newView) {
    ngDevMode && assertNotEqual(newView[0], newView[1], '????');
    ngDevMode && assertLViewOrUndefined(newView);
    const newLFrame = allocLFrame();
    if (ngDevMode) {
        assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');
        assertEqual(newLFrame.lView, null, 'Expected clean LFrame');
        assertEqual(newLFrame.tView, null, 'Expected clean LFrame');
        assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');
        assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');
        assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');
        assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');
        assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');
        assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');
    }
    const tView = newView[TVIEW];
    instructionState.lFrame = newLFrame;
    ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
    newLFrame.currentTNode = tView.firstChild;
    newLFrame.lView = newView;
    newLFrame.tView = tView;
    newLFrame.contextLView = newView;
    newLFrame.bindingIndex = tView.bindingStartIndex;
    newLFrame.inI18n = false;
}
function allocLFrame() {
    const currentLFrame = instructionState.lFrame;
    const childLFrame = currentLFrame === null ? null : currentLFrame.child;
    const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
    return newLFrame;
}
function createLFrame(parent) {
    const lFrame = {
        currentTNode: null,
        isParent: true,
        lView: null,
        tView: null,
        selectedIndex: -1,
        contextLView: null,
        elementDepthCount: 0,
        currentNamespace: null,
        currentDirectiveIndex: -1,
        bindingRootIndex: -1,
        bindingIndex: -1,
        currentQueryIndex: 0,
        parent: parent,
        child: null,
        inI18n: false
    };
    parent !== null && (parent.child = lFrame);
    return lFrame;
}
function leaveViewLight() {
    const oldLFrame = instructionState.lFrame;
    instructionState.lFrame = oldLFrame.parent;
    oldLFrame.currentTNode = null;
    oldLFrame.lView = null;
    return oldLFrame;
}
const leaveDI = leaveViewLight;
function leaveView() {
    const oldLFrame = leaveViewLight();
    oldLFrame.isParent = true;
    oldLFrame.tView = null;
    oldLFrame.selectedIndex = -1;
    oldLFrame.contextLView = null;
    oldLFrame.elementDepthCount = 0;
    oldLFrame.currentDirectiveIndex = -1;
    oldLFrame.currentNamespace = null;
    oldLFrame.bindingRootIndex = -1;
    oldLFrame.bindingIndex = -1;
    oldLFrame.currentQueryIndex = 0;
}
function nextContextImpl(level) {
    const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
    return contextLView[CONTEXT];
}
function walkUpViews(nestingLevel, currentView) {
    while(nestingLevel > 0){
        ngDevMode && assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');
        currentView = currentView[DECLARATION_VIEW];
        nestingLevel--;
    }
    return currentView;
}
function getSelectedIndex() {
    return instructionState.lFrame.selectedIndex;
}
function setSelectedIndex(index) {
    ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');
    ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, 'Can\'t set index passed end of LView');
    instructionState.lFrame.selectedIndex = index;
}
function getSelectedTNode() {
    const lFrame = instructionState.lFrame;
    return getTNode(lFrame.tView, lFrame.selectedIndex);
}
function ɵɵnamespaceSVG() {
    instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
}
function ɵɵnamespaceMathML() {
    instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
}
function ɵɵnamespaceHTML() {
    namespaceHTMLInternal();
}
function namespaceHTMLInternal() {
    instructionState.lFrame.currentNamespace = null;
}
function getNamespace$1() {
    return instructionState.lFrame.currentNamespace;
}
let _wasLastNodeCreated = true;
function wasLastNodeCreated() {
    return _wasLastNodeCreated;
}
function lastNodeWasCreated(flag) {
    _wasLastNodeCreated = flag;
}
function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
    ngDevMode && assertFirstCreatePass(tView);
    const { ngOnChanges , ngOnInit , ngDoCheck  } = directiveDef.type.prototype;
    if (ngOnChanges) {
        var _tView, _tView1;
        const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
        var _preOrderHooks;
        ((_preOrderHooks = (_tView = tView).preOrderHooks) !== null && _preOrderHooks !== void 0 ? _preOrderHooks : _tView.preOrderHooks = []).push(directiveIndex, wrappedOnChanges);
        var _preOrderCheckHooks;
        ((_preOrderCheckHooks = (_tView1 = tView).preOrderCheckHooks) !== null && _preOrderCheckHooks !== void 0 ? _preOrderCheckHooks : _tView1.preOrderCheckHooks = []).push(directiveIndex, wrappedOnChanges);
    }
    if (ngOnInit) {
        var _tView2;
        var _preOrderHooks1;
        ((_preOrderHooks1 = (_tView2 = tView).preOrderHooks) !== null && _preOrderHooks1 !== void 0 ? _preOrderHooks1 : _tView2.preOrderHooks = []).push(0 - directiveIndex, ngOnInit);
    }
    if (ngDoCheck) {
        var _tView3, _tView4;
        var _preOrderHooks2;
        ((_preOrderHooks2 = (_tView3 = tView).preOrderHooks) !== null && _preOrderHooks2 !== void 0 ? _preOrderHooks2 : _tView3.preOrderHooks = []).push(directiveIndex, ngDoCheck);
        var _preOrderCheckHooks1;
        ((_preOrderCheckHooks1 = (_tView4 = tView).preOrderCheckHooks) !== null && _preOrderCheckHooks1 !== void 0 ? _preOrderCheckHooks1 : _tView4.preOrderCheckHooks = []).push(directiveIndex, ngDoCheck);
    }
}
function registerPostOrderHooks(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView);
    for(let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++){
        const directiveDef = tView.data[i];
        ngDevMode && assertDefined(directiveDef, 'Expecting DirectiveDef');
        const lifecycleHooks = directiveDef.type.prototype;
        const { ngAfterContentInit , ngAfterContentChecked , ngAfterViewInit , ngAfterViewChecked , ngOnDestroy  } = lifecycleHooks;
        if (ngAfterContentInit) {
            var _tView;
            var _contentHooks;
            ((_contentHooks = (_tView = tView).contentHooks) !== null && _contentHooks !== void 0 ? _contentHooks : _tView.contentHooks = []).push(-i, ngAfterContentInit);
        }
        if (ngAfterContentChecked) {
            var _tView1, _tView2;
            var _contentHooks1;
            ((_contentHooks1 = (_tView1 = tView).contentHooks) !== null && _contentHooks1 !== void 0 ? _contentHooks1 : _tView1.contentHooks = []).push(i, ngAfterContentChecked);
            var _contentCheckHooks;
            ((_contentCheckHooks = (_tView2 = tView).contentCheckHooks) !== null && _contentCheckHooks !== void 0 ? _contentCheckHooks : _tView2.contentCheckHooks = []).push(i, ngAfterContentChecked);
        }
        if (ngAfterViewInit) {
            var _tView3;
            var _viewHooks;
            ((_viewHooks = (_tView3 = tView).viewHooks) !== null && _viewHooks !== void 0 ? _viewHooks : _tView3.viewHooks = []).push(-i, ngAfterViewInit);
        }
        if (ngAfterViewChecked) {
            var _tView4, _tView5;
            var _viewHooks1;
            ((_viewHooks1 = (_tView4 = tView).viewHooks) !== null && _viewHooks1 !== void 0 ? _viewHooks1 : _tView4.viewHooks = []).push(i, ngAfterViewChecked);
            var _viewCheckHooks;
            ((_viewCheckHooks = (_tView5 = tView).viewCheckHooks) !== null && _viewCheckHooks !== void 0 ? _viewCheckHooks : _tView5.viewCheckHooks = []).push(i, ngAfterViewChecked);
        }
        if (ngOnDestroy != null) {
            var _tView6;
            var _destroyHooks;
            ((_destroyHooks = (_tView6 = tView).destroyHooks) !== null && _destroyHooks !== void 0 ? _destroyHooks : _tView6.destroyHooks = []).push(i, ngOnDestroy);
        }
    }
}
function executeCheckHooks(lView, hooks, nodeIndex) {
    callHooks(lView, hooks, 3, nodeIndex);
}
function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
    ngDevMode && assertNotEqual(initPhase, 3, 'Init pre-order hooks should not be called more than once');
    if ((lView[FLAGS] & 3) === initPhase) callHooks(lView, hooks, initPhase, nodeIndex);
}
function incrementInitPhaseFlags(lView, initPhase) {
    ngDevMode && assertNotEqual(initPhase, 3, 'Init hooks phase should not be incremented after all init hooks have been run.');
    let flags = lView[FLAGS];
    if ((flags & 3) === initPhase) {
        flags &= 4095;
        flags += 1;
        lView[FLAGS] = flags;
    }
}
function callHooks(currentView, arr, initPhase, currentNodeIndex) {
    ngDevMode && assertEqual(isInCheckNoChangesMode(), false, 'Hooks should never be run when in check no changes mode.');
    const startIndex = currentNodeIndex !== undefined ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;
    const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
    const max = arr.length - 1;
    let lastNodeIndexFound = 0;
    for(let i = startIndex; i < max; i++){
        const hook = arr[i + 1];
        if (typeof hook === 'number') {
            lastNodeIndexFound = arr[i];
            if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) break;
        } else {
            const isInitHook = arr[i] < 0;
            if (isInitHook) currentView[PREORDER_HOOK_FLAGS] += 65536;
            if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
                callHook(currentView, initPhase, arr, i);
                currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
            }
            i++;
        }
    }
}
function callHookInternal(directive, hook) {
    profiler(4, directive, hook);
    const prevConsumer = setActiveConsumer(null);
    try {
        hook.call(directive);
    } finally{
        setActiveConsumer(prevConsumer);
        profiler(5, directive, hook);
    }
}
function callHook(currentView, initPhase, arr, i) {
    const isInitHook = arr[i] < 0;
    const hook = arr[i + 1];
    const directiveIndex = isInitHook ? -arr[i] : arr[i];
    const directive = currentView[directiveIndex];
    if (isInitHook) {
        const indexWithintInitPhase = currentView[FLAGS] >> 12;
        if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 && (currentView[FLAGS] & 3) === initPhase) {
            currentView[FLAGS] += 4096;
            callHookInternal(directive, hook);
        }
    } else callHookInternal(directive, hook);
}
const NO_PARENT_INJECTOR = -1;
class NodeInjectorFactory {
    constructor(factory, isViewProvider, injectImplementation){
        this.factory = factory;
        this.resolving = false;
        ngDevMode && assertDefined(factory, 'Factory not specified');
        ngDevMode && assertEqual(typeof factory, 'function', 'Expected factory function.');
        this.canSeeViewProviders = isViewProvider;
        this.injectImpl = injectImplementation;
    }
}
function isFactory(obj) {
    return obj instanceof NodeInjectorFactory;
}
function toTNodeTypeAsString(tNodeType) {
    let text = '';
    tNodeType & 1 && (text += '|Text');
    tNodeType & 2 && (text += '|Element');
    tNodeType & 4 && (text += '|Container');
    tNodeType & 8 && (text += '|ElementContainer');
    tNodeType & 16 && (text += '|Projection');
    tNodeType & 32 && (text += '|IcuContainer');
    tNodeType & 64 && (text += '|Placeholder');
    return text.length > 0 ? text.substring(1) : text;
}
function hasClassInput(tNode) {
    return (tNode.flags & 8) !== 0;
}
function hasStyleInput(tNode) {
    return (tNode.flags & 16) !== 0;
}
function assertTNodeType(tNode, expectedTypes, message) {
    assertDefined(tNode, 'should be called with a TNode');
    if ((tNode.type & expectedTypes) === 0) throwError(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
}
function assertPureTNodeType(type) {
    if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 || type === 64)) throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
}
function hasParentInjector(parentLocation) {
    return parentLocation !== NO_PARENT_INJECTOR;
}
function getParentInjectorIndex(parentLocation) {
    ngDevMode && assertNumber(parentLocation, 'Number expected');
    ngDevMode && assertNotEqual(parentLocation, -1, 'Not a valid state.');
    const parentInjectorIndex = parentLocation & 32767;
    ngDevMode && assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, 'Parent injector must be pointing past HEADER_OFFSET.');
    return parentLocation & 32767;
}
function getParentInjectorViewOffset(parentLocation) {
    return parentLocation >> 16;
}
function getParentInjectorView(location1, startView) {
    let viewOffset = getParentInjectorViewOffset(location1);
    let parentView = startView;
    while(viewOffset > 0){
        parentView = parentView[DECLARATION_VIEW];
        viewOffset--;
    }
    return parentView;
}
let includeViewProviders = true;
function setIncludeViewProviders(v) {
    const oldValue = includeViewProviders;
    includeViewProviders = v;
    return oldValue;
}
const BLOOM_SIZE = 256;
const BLOOM_MASK = BLOOM_SIZE - 1;
const BLOOM_BUCKET_BITS = 5;
let nextNgElementId = 0;
const NOT_FOUND = {};
function bloomAdd(injectorIndex, tView, type) {
    ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');
    let id;
    if (typeof type === 'string') id = type.charCodeAt(0) || 0;
    else if (type.hasOwnProperty(NG_ELEMENT_ID)) id = type[NG_ELEMENT_ID];
    if (id == null) id = type[NG_ELEMENT_ID] = nextNgElementId++;
    const bloomHash = id & BLOOM_MASK;
    const mask = 1 << bloomHash;
    tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
}
function getOrCreateNodeInjectorForNode(tNode, lView) {
    const existingInjectorIndex = getInjectorIndex(tNode, lView);
    if (existingInjectorIndex !== -1) return existingInjectorIndex;
    const tView = lView[TVIEW];
    if (tView.firstCreatePass) {
        tNode.injectorIndex = lView.length;
        insertBloom(tView.data, tNode);
        insertBloom(lView, null);
        insertBloom(tView.blueprint, null);
    }
    const parentLoc = getParentInjectorLocation(tNode, lView);
    const injectorIndex = tNode.injectorIndex;
    if (hasParentInjector(parentLoc)) {
        const parentIndex = getParentInjectorIndex(parentLoc);
        const parentLView = getParentInjectorView(parentLoc, lView);
        const parentData = parentLView[TVIEW].data;
        for(let i = 0; i < 8; i++)lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
    }
    lView[injectorIndex + 8] = parentLoc;
    return injectorIndex;
}
function insertBloom(arr, footer) {
    arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
}
function getInjectorIndex(tNode, lView) {
    if (tNode.injectorIndex === -1 || tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || lView[tNode.injectorIndex + 8] === null) return -1;
    else {
        ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);
        return tNode.injectorIndex;
    }
}
function getParentInjectorLocation(tNode, lView) {
    if (tNode.parent && tNode.parent.injectorIndex !== -1) return tNode.parent.injectorIndex;
    let declarationViewOffset = 0;
    let parentTNode = null;
    let lViewCursor = lView;
    while(lViewCursor !== null){
        parentTNode = getTNodeFromLView(lViewCursor);
        if (parentTNode === null) return NO_PARENT_INJECTOR;
        ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);
        declarationViewOffset++;
        lViewCursor = lViewCursor[DECLARATION_VIEW];
        if (parentTNode.injectorIndex !== -1) return parentTNode.injectorIndex | declarationViewOffset << 16;
    }
    return NO_PARENT_INJECTOR;
}
function diPublicInInjector(injectorIndex, tView, token) {
    bloomAdd(injectorIndex, tView, token);
}
function injectAttributeImpl(tNode, attrNameToInject) {
    ngDevMode && assertTNodeType(tNode, 15);
    ngDevMode && assertDefined(tNode, 'expecting tNode');
    if (attrNameToInject === 'class') return tNode.classes;
    if (attrNameToInject === 'style') return tNode.styles;
    const attrs = tNode.attrs;
    if (attrs) {
        const attrsLength = attrs.length;
        let i = 0;
        while(i < attrsLength){
            const value = attrs[i];
            if (isNameOnlyAttributeMarker(value)) break;
            if (value === 0) i = i + 2;
            else if (typeof value === 'number') {
                i++;
                while(i < attrsLength && typeof attrs[i] === 'string')i++;
            } else if (value === attrNameToInject) return attrs[i + 1];
            else i = i + 2;
        }
    }
    return null;
}
function notFoundValueOrThrow(notFoundValue, token, flags) {
    if (flags & InjectFlags.Optional || notFoundValue !== undefined) return notFoundValue;
    else throwProviderNotFoundError(token, 'NodeInjector');
}
function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
    if (flags & InjectFlags.Optional && notFoundValue === undefined) notFoundValue = null;
    if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
        const moduleInjector = lView[INJECTOR$1];
        const previousInjectImplementation = setInjectImplementation(undefined);
        try {
            if (moduleInjector) return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
            else return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
        } finally{
            setInjectImplementation(previousInjectImplementation);
        }
    }
    return notFoundValueOrThrow(notFoundValue, token, flags);
}
function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
    if (tNode !== null) {
        if (lView[FLAGS] & 2048) {
            const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);
            if (embeddedInjectorValue !== NOT_FOUND) return embeddedInjectorValue;
        }
        const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);
        if (value !== NOT_FOUND) return value;
    }
    return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
}
function lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {
    const bloomHash = bloomHashBitOrFactory(token);
    if (typeof bloomHash === 'function') {
        if (!enterDI(lView, tNode, flags)) return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
        try {
            const value = bloomHash(flags);
            if (value == null && !(flags & InjectFlags.Optional)) throwProviderNotFoundError(token);
            else return value;
        } finally{
            leaveDI();
        }
    } else if (typeof bloomHash === 'number') {
        let previousTView = null;
        let injectorIndex = getInjectorIndex(tNode, lView);
        let parentLocation = NO_PARENT_INJECTOR;
        let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
        if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
            parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + 8];
            if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) injectorIndex = -1;
            else {
                previousTView = lView[TVIEW];
                injectorIndex = getParentInjectorIndex(parentLocation);
                lView = getParentInjectorView(parentLocation, lView);
            }
        }
        while(injectorIndex !== -1){
            ngDevMode && assertNodeInjector(lView, injectorIndex);
            const tView = lView[TVIEW];
            ngDevMode && assertTNodeForLView(tView.data[injectorIndex + 8], lView);
            if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
                const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
                if (instance !== NOT_FOUND) return instance;
            }
            parentLocation = lView[injectorIndex + 8];
            if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + 8] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
                previousTView = tView;
                injectorIndex = getParentInjectorIndex(parentLocation);
                lView = getParentInjectorView(parentLocation, lView);
            } else injectorIndex = -1;
        }
    }
    return notFoundValue;
}
function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
    const currentTView = lView[TVIEW];
    const tNode = currentTView.data[injectorIndex + 8];
    const canAccessViewProviders = previousTView == null ? isComponentHost(tNode) && includeViewProviders : previousTView != currentTView && (tNode.type & 3) !== 0;
    const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;
    const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
    if (injectableIdx !== null) return getNodeInjectable(lView, currentTView, injectableIdx, tNode);
    else return NOT_FOUND;
}
function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
    const nodeProviderIndexes = tNode.providerIndexes;
    const tInjectables = tView.data;
    const injectablesStart = nodeProviderIndexes & 1048575;
    const directivesStart = tNode.directiveStart;
    const directiveEnd = tNode.directiveEnd;
    const cptViewProvidersCount = nodeProviderIndexes >> 20;
    const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
    const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
    for(let i = startingIndex; i < endIndex; i++){
        const providerTokenOrDef = tInjectables[i];
        if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) return i;
    }
    if (isHostSpecialCase) {
        const dirDef = tInjectables[directivesStart];
        if (dirDef && isComponentDef(dirDef) && dirDef.type === token) return directivesStart;
    }
    return null;
}
function getNodeInjectable(lView, tView, index, tNode) {
    let value = lView[index];
    const tData = tView.data;
    if (isFactory(value)) {
        const factory = value;
        if (factory.resolving) throwCyclicDependencyError(stringifyForError(tData[index]));
        const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
        factory.resolving = true;
        const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
        const success = enterDI(lView, tNode, InjectFlags.Default);
        ngDevMode && assertEqual(success, true, 'Because flags do not contain \`SkipSelf\' we expect this to always succeed.');
        try {
            value = lView[index] = factory.factory(undefined, tData, lView, tNode);
            if (tView.firstCreatePass && index >= tNode.directiveStart) {
                ngDevMode && assertDirectiveDef(tData[index]);
                registerPreOrderHooks(index, tData[index], tView);
            }
        } finally{
            previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);
            setIncludeViewProviders(previousIncludeViewProviders);
            factory.resolving = false;
            leaveDI();
        }
    }
    return value;
}
function bloomHashBitOrFactory(token) {
    ngDevMode && assertDefined(token, 'token must be defined');
    if (typeof token === 'string') return token.charCodeAt(0) || 0;
    const tokenId = token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : undefined;
    if (typeof tokenId === 'number') {
        if (tokenId >= 0) return tokenId & BLOOM_MASK;
        else {
            ngDevMode && assertEqual(tokenId, -1, 'Expecting to get Special Injector Id');
            return createNodeInjector;
        }
    } else return tokenId;
}
function bloomHasToken(bloomHash, injectorIndex, injectorView) {
    const mask = 1 << bloomHash;
    const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
    return !!(value & mask);
}
function shouldSearchParent(flags, isFirstHostTNode) {
    return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
}
class NodeInjector {
    get(token, notFoundValue, flags) {
        return getOrCreateInjectable(this._tNode, this._lView, token, convertToBitFlags(flags), notFoundValue);
    }
    constructor(_tNode, _lView){
        this._tNode = _tNode;
        this._lView = _lView;
    }
}
function createNodeInjector() {
    return new NodeInjector(getCurrentTNode(), getLView());
}
function ɵɵgetInheritedFactory(type) {
    return noSideEffects(()=>{
        const ownConstructor = type.prototype.constructor;
        const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
        const objectPrototype = Object.prototype;
        let parent = Object.getPrototypeOf(type.prototype).constructor;
        while(parent && parent !== objectPrototype){
            const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);
            if (factory && factory !== ownFactory) return factory;
            parent = Object.getPrototypeOf(parent);
        }
        return (t)=>new t();
    });
}
function getFactoryOf(type) {
    if (isForwardRef(type)) return ()=>{
        const factory = getFactoryOf(resolveForwardRef(type));
        return factory && factory();
    };
    return getFactoryDef(type);
}
function lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {
    let currentTNode = tNode;
    let currentLView = lView;
    while(currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 2048 && !(currentLView[FLAGS] & 512)){
        ngDevMode && assertTNodeForLView(currentTNode, currentLView);
        const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);
        if (nodeInjectorValue !== NOT_FOUND) return nodeInjectorValue;
        let parentTNode = currentTNode.parent;
        if (!parentTNode) {
            const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];
            if (embeddedViewInjector) {
                const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);
                if (embeddedViewInjectorValue !== NOT_FOUND) return embeddedViewInjectorValue;
            }
            parentTNode = getTNodeFromLView(currentLView);
            currentLView = currentLView[DECLARATION_VIEW];
        }
        currentTNode = parentTNode;
    }
    return notFoundValue;
}
function getTNodeFromLView(lView) {
    const tView = lView[TVIEW];
    const tViewType = tView.type;
    if (tViewType === 2) {
        ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');
        return tView.declTNode;
    } else if (tViewType === 1) return lView[T_HOST];
    return null;
}
function ɵɵinjectAttribute(attrNameToInject) {
    return injectAttributeImpl(getCurrentTNode(), attrNameToInject);
}
const ANNOTATIONS = '__annotations__';
const PARAMETERS = '__parameters__';
const PROP_METADATA = '__prop__metadata__';
function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
    return noSideEffects(()=>{
        const metaCtor = makeMetadataCtor(props);
        function DecoratorFactory(...args) {
            if (this instanceof DecoratorFactory) {
                metaCtor.call(this, ...args);
                return this;
            }
            const annotationInstance = new DecoratorFactory(...args);
            return function TypeDecorator(cls) {
                if (typeFn) typeFn(cls, ...args);
                const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {
                    value: []
                })[ANNOTATIONS];
                annotations.push(annotationInstance);
                if (additionalProcessing) additionalProcessing(cls);
                return cls;
            };
        }
        if (parentClass) DecoratorFactory.prototype = Object.create(parentClass.prototype);
        DecoratorFactory.prototype.ngMetadataName = name;
        DecoratorFactory.annotationCls = DecoratorFactory;
        return DecoratorFactory;
    });
}
function makeMetadataCtor(props) {
    return function ctor(...args) {
        if (props) {
            const values = props(...args);
            for(const propName in values)this[propName] = values[propName];
        }
    };
}
function makeParamDecorator(name, props, parentClass) {
    return noSideEffects(()=>{
        const metaCtor = makeMetadataCtor(props);
        function ParamDecoratorFactory(...args) {
            if (this instanceof ParamDecoratorFactory) {
                metaCtor.apply(this, args);
                return this;
            }
            const annotationInstance = new ParamDecoratorFactory(...args);
            ParamDecorator.annotation = annotationInstance;
            return ParamDecorator;
            function ParamDecorator(cls, unusedKey, index) {
                const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
                    value: []
                })[PARAMETERS];
                while(parameters.length <= index)parameters.push(null);
                (parameters[index] = parameters[index] || []).push(annotationInstance);
                return cls;
            }
        }
        if (parentClass) ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
        ParamDecoratorFactory.prototype.ngMetadataName = name;
        ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
        return ParamDecoratorFactory;
    });
}
function makePropDecorator(name, props, parentClass, additionalProcessing) {
    return noSideEffects(()=>{
        const metaCtor = makeMetadataCtor(props);
        function PropDecoratorFactory(...args) {
            if (this instanceof PropDecoratorFactory) {
                metaCtor.apply(this, args);
                return this;
            }
            const decoratorInstance = new PropDecoratorFactory(...args);
            function PropDecorator(target, name) {
                if (target === undefined) throw new Error('Standard Angular field decorators are not supported in JIT mode.');
                const constructor = target.constructor;
                const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {
                    value: {}
                })[PROP_METADATA];
                meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
                meta[name].unshift(decoratorInstance);
                if (additionalProcessing) additionalProcessing(target, name, ...args);
            }
            return PropDecorator;
        }
        if (parentClass) PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
        PropDecoratorFactory.prototype.ngMetadataName = name;
        PropDecoratorFactory.annotationCls = PropDecoratorFactory;
        return PropDecoratorFactory;
    });
}
const Attribute = makeParamDecorator('Attribute', (attributeName)=>({
        attributeName,
        __NG_ELEMENT_ID__: ()=>ɵɵinjectAttribute(attributeName)
    }));
const emitDistinctChangesOnlyDefaultValue = true;
class Query {
}
makePropDecorator('ContentChildren', (selector, data = {})=>_object_spread._({
        selector,
        first: false,
        isViewQuery: false,
        descendants: false,
        emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
    }, data), Query);
makePropDecorator('ContentChild', (selector, data = {})=>_object_spread._({
        selector,
        first: true,
        isViewQuery: false,
        descendants: true
    }, data), Query);
makePropDecorator('ViewChildren', (selector, data = {})=>_object_spread._({
        selector,
        first: false,
        isViewQuery: true,
        descendants: true,
        emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
    }, data), Query);
makePropDecorator('ViewChild', (selector, data)=>_object_spread._({
        selector,
        first: true,
        isViewQuery: true,
        descendants: true
    }, data), Query);
var FactoryTarget = (()=>{
    FactoryTarget = FactoryTarget || {};
    FactoryTarget[FactoryTarget["Directive"] = 0] = "Directive";
    FactoryTarget[FactoryTarget["Component"] = 1] = "Component";
    FactoryTarget[FactoryTarget["Injectable"] = 2] = "Injectable";
    FactoryTarget[FactoryTarget["Pipe"] = 3] = "Pipe";
    FactoryTarget[FactoryTarget["NgModule"] = 4] = "NgModule";
    return FactoryTarget;
})();
var R3TemplateDependencyKind = (()=>{
    R3TemplateDependencyKind = R3TemplateDependencyKind || {};
    R3TemplateDependencyKind[R3TemplateDependencyKind["Directive"] = 0] = "Directive";
    R3TemplateDependencyKind[R3TemplateDependencyKind["Pipe"] = 1] = "Pipe";
    R3TemplateDependencyKind[R3TemplateDependencyKind["NgModule"] = 2] = "NgModule";
    return R3TemplateDependencyKind;
})();
var ViewEncapsulation = (()=>{
    ViewEncapsulation = ViewEncapsulation || {};
    ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
    ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
    ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
    return ViewEncapsulation;
})();
function getCompilerFacade(request) {
    const globalNg = _global['ng'];
    if (globalNg && globalNg.ɵcompilerFacade) return globalNg.ɵcompilerFacade;
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
        console.error(`JIT compilation failed for ${request.kind}`, request.type);
        let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\n\n`;
        if (request.usage === 1) {
            message += `The ${request.kind} is part of a library that has been partially compiled.\n`;
            message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\n`;
            message += '\n';
            message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\n`;
        } else message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\n`;
        message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\n`;
        message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
        throw new Error(message);
    } else throw new Error('JIT compiler unavailable');
}
const Type = Function;
function isType(v) {
    return typeof v === 'function';
}
function arrayEquals(a, b, identityAccessor) {
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; i++){
        let valueA = a[i];
        let valueB = b[i];
        if (identityAccessor) {
            valueA = identityAccessor(valueA);
            valueB = identityAccessor(valueB);
        }
        if (valueB !== valueA) return false;
    }
    return true;
}
function flatten(list) {
    return list.flat(Number.POSITIVE_INFINITY);
}
function deepForEach(input, fn) {
    input.forEach((value)=>Array.isArray(value) ? deepForEach(value, fn) : fn(value));
}
function addToArray(arr, index, value) {
    if (index >= arr.length) arr.push(value);
    else arr.splice(index, 0, value);
}
function removeFromArray(arr, index) {
    if (index >= arr.length - 1) return arr.pop();
    else return arr.splice(index, 1)[0];
}
function newArray(size, value) {
    const list = [];
    for(let i = 0; i < size; i++)list.push(value);
    return list;
}
function arrayInsert2(array, index, value1, value2) {
    ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\'t insert past array end.');
    let end = array.length;
    if (end == index) array.push(value1, value2);
    else if (end === 1) {
        array.push(value2, array[0]);
        array[0] = value1;
    } else {
        end--;
        array.push(array[end - 1], array[end]);
        while(end > index){
            const previousEnd = end - 2;
            array[end] = array[previousEnd];
            end--;
        }
        array[index] = value1;
        array[index + 1] = value2;
    }
}
function keyValueArraySet(keyValueArray, key, value) {
    let index = keyValueArrayIndexOf(keyValueArray, key);
    if (index >= 0) keyValueArray[index | 1] = value;
    else {
        index = ~index;
        arrayInsert2(keyValueArray, index, key, value);
    }
    return index;
}
function keyValueArrayGet(keyValueArray, key) {
    const index = keyValueArrayIndexOf(keyValueArray, key);
    if (index >= 0) return keyValueArray[index | 1];
    return undefined;
}
function keyValueArrayIndexOf(keyValueArray, key) {
    return _arrayIndexOfSorted(keyValueArray, key, 1);
}
function _arrayIndexOfSorted(array, value, shift) {
    ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');
    let start = 0;
    let end = array.length >> shift;
    while(end !== start){
        const middle = start + (end - start >> 1);
        const current = array[middle << shift];
        if (value === current) return middle << shift;
        else if (current > value) end = middle;
        else start = middle + 1;
    }
    return ~(end << shift);
}
const ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
const ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
const ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
const ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
function isDelegateCtor(typeStr) {
    return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
}
class ReflectionCapabilities {
    factory(t) {
        return (...args)=>new t(...args);
    }
    _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
        let result;
        if (typeof paramTypes === 'undefined') result = newArray(paramAnnotations.length);
        else result = newArray(paramTypes.length);
        for(let i = 0; i < result.length; i++){
            if (typeof paramTypes === 'undefined') result[i] = [];
            else if (paramTypes[i] && paramTypes[i] != Object) result[i] = [
                paramTypes[i]
            ];
            else result[i] = [];
            if (paramAnnotations && paramAnnotations[i] != null) result[i] = result[i].concat(paramAnnotations[i]);
        }
        return result;
    }
    _ownParameters(type, parentCtor) {
        const typeStr = type.toString();
        if (isDelegateCtor(typeStr)) return null;
        if (type.parameters && type.parameters !== parentCtor.parameters) return type.parameters;
        const tsickleCtorParams = type.ctorParameters;
        if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
            const ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;
            const paramTypes = ctorParameters.map((ctorParam)=>ctorParam && ctorParam.type);
            const paramAnnotations = ctorParameters.map((ctorParam)=>ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
            return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
        }
        const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
        const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata('design:paramtypes', type);
        if (paramTypes || paramAnnotations) return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
        return newArray(type.length);
    }
    parameters(type) {
        if (!isType(type)) return [];
        const parentCtor = getParentCtor(type);
        let parameters = this._ownParameters(type, parentCtor);
        if (!parameters && parentCtor !== Object) parameters = this.parameters(parentCtor);
        return parameters || [];
    }
    _ownAnnotations(typeOrFunc, parentCtor) {
        if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
            let annotations = typeOrFunc.annotations;
            if (typeof annotations === 'function' && annotations.annotations) annotations = annotations.annotations;
            return annotations;
        }
        if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
        if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) return typeOrFunc[ANNOTATIONS];
        return null;
    }
    annotations(typeOrFunc) {
        if (!isType(typeOrFunc)) return [];
        const parentCtor = getParentCtor(typeOrFunc);
        const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
        const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
        return parentAnnotations.concat(ownAnnotations);
    }
    _ownPropMetadata(typeOrFunc, parentCtor) {
        if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
            let propMetadata = typeOrFunc.propMetadata;
            if (typeof propMetadata === 'function' && propMetadata.propMetadata) propMetadata = propMetadata.propMetadata;
            return propMetadata;
        }
        if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
            const propDecorators = typeOrFunc.propDecorators;
            const propMetadata = {};
            Object.keys(propDecorators).forEach((prop)=>{
                propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
            });
            return propMetadata;
        }
        if (typeOrFunc.hasOwnProperty(PROP_METADATA)) return typeOrFunc[PROP_METADATA];
        return null;
    }
    propMetadata(typeOrFunc) {
        if (!isType(typeOrFunc)) return {};
        const parentCtor = getParentCtor(typeOrFunc);
        const propMetadata = {};
        if (parentCtor !== Object) {
            const parentPropMetadata = this.propMetadata(parentCtor);
            Object.keys(parentPropMetadata).forEach((propName)=>{
                propMetadata[propName] = parentPropMetadata[propName];
            });
        }
        const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
        if (ownPropMetadata) Object.keys(ownPropMetadata).forEach((propName)=>{
            const decorators = [];
            if (propMetadata.hasOwnProperty(propName)) decorators.push(...propMetadata[propName]);
            decorators.push(...ownPropMetadata[propName]);
            propMetadata[propName] = decorators;
        });
        return propMetadata;
    }
    ownPropMetadata(typeOrFunc) {
        if (!isType(typeOrFunc)) return {};
        return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
    }
    hasLifecycleHook(type, lcProperty) {
        return type instanceof Type && lcProperty in type.prototype;
    }
    constructor(reflect){
        this._reflect = reflect || _global['Reflect'];
    }
}
function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
    if (!decoratorInvocations) return [];
    return decoratorInvocations.map((decoratorInvocation)=>{
        const decoratorType = decoratorInvocation.type;
        const annotationCls = decoratorType.annotationCls;
        const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
        return new annotationCls(...annotationArgs);
    });
}
function getParentCtor(ctor) {
    const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
    const parentCtor = parentProto ? parentProto.constructor : null;
    return parentCtor || Object;
}
const Inject = attachInjectFlag(makeParamDecorator('Inject', (token)=>({
        token
    })), -1);
const Optional = attachInjectFlag(makeParamDecorator('Optional'), 8);
const Self = attachInjectFlag(makeParamDecorator('Self'), 2);
const SkipSelf = attachInjectFlag(makeParamDecorator('SkipSelf'), 4);
const Host = attachInjectFlag(makeParamDecorator('Host'), 1);
let _reflect = null;
function getReflect() {
    return _reflect = _reflect || new ReflectionCapabilities();
}
function reflectDependencies(type) {
    return convertDependencies(getReflect().parameters(type));
}
function convertDependencies(deps) {
    return deps.map((dep)=>reflectDependency(dep));
}
function reflectDependency(dep) {
    const meta = {
        token: null,
        attribute: null,
        host: false,
        optional: false,
        self: false,
        skipSelf: false
    };
    if (Array.isArray(dep) && dep.length > 0) for(let j = 0; j < dep.length; j++){
        const param = dep[j];
        if (param === undefined) continue;
        const proto = Object.getPrototypeOf(param);
        if (param instanceof Optional || proto.ngMetadataName === 'Optional') meta.optional = true;
        else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') meta.skipSelf = true;
        else if (param instanceof Self || proto.ngMetadataName === 'Self') meta.self = true;
        else if (param instanceof Host || proto.ngMetadataName === 'Host') meta.host = true;
        else if (param instanceof Inject) meta.token = param.token;
        else if (param instanceof Attribute) {
            if (param.attributeName === undefined) throw new RuntimeError(204, ngDevMode && `Attribute name must be defined.`);
            meta.attribute = param.attributeName;
        } else meta.token = param;
    }
    else if (dep === undefined || Array.isArray(dep) && dep.length === 0) meta.token = null;
    else meta.token = dep;
    return meta;
}
function resolveComponentResources(resourceResolver) {
    const componentResolved = [];
    const urlMap = new Map();
    function cachedResourceResolve(url) {
        let promise = urlMap.get(url);
        if (!promise) {
            const resp = resourceResolver(url);
            urlMap.set(url, promise = resp.then(unwrapResponse));
        }
        return promise;
    }
    componentResourceResolutionQueue.forEach((component, type)=>{
        const promises = [];
        if (component.templateUrl) promises.push(cachedResourceResolve(component.templateUrl).then((template)=>{
            component.template = template;
        }));
        const styleUrls = component.styleUrls;
        const styles = component.styles || (component.styles = []);
        const styleOffset = component.styles.length;
        styleUrls && styleUrls.forEach((styleUrl, index)=>{
            styles.push('');
            promises.push(cachedResourceResolve(styleUrl).then((style)=>{
                styles[styleOffset + index] = style;
                styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
                if (styleUrls.length == 0) component.styleUrls = undefined;
            }));
        });
        const fullyResolved = Promise.all(promises).then(()=>componentDefResolved(type));
        componentResolved.push(fullyResolved);
    });
    clearResolutionOfComponentResourcesQueue();
    return Promise.all(componentResolved).then(()=>undefined);
}
let componentResourceResolutionQueue = new Map();
const componentDefPendingResolution = new Set();
function maybeQueueResolutionOfComponentResources(type, metadata) {
    if (componentNeedsResolution(metadata)) {
        componentResourceResolutionQueue.set(type, metadata);
        componentDefPendingResolution.add(type);
    }
}
function componentNeedsResolution(component) {
    return !!(component.templateUrl && !component.hasOwnProperty('template') || component.styleUrls && component.styleUrls.length);
}
function clearResolutionOfComponentResourcesQueue() {
    const old = componentResourceResolutionQueue;
    componentResourceResolutionQueue = new Map();
    return old;
}
function isComponentResourceResolutionQueueEmpty() {
    return componentResourceResolutionQueue.size === 0;
}
function unwrapResponse(response) {
    return typeof response == 'string' ? response : response.text();
}
function componentDefResolved(type) {
    componentDefPendingResolution.delete(type);
}
const modules = new Map();
let checkForDuplicateNgModules = true;
function assertSameOrNotExisting(id, type, incoming) {
    if (type && type !== incoming && checkForDuplicateNgModules) throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);
}
function registerNgModuleType(ngModuleType, id) {
    const existing = modules.get(id) || null;
    assertSameOrNotExisting(id, existing, ngModuleType);
    modules.set(id, ngModuleType);
}
const CUSTOM_ELEMENTS_SCHEMA = {
    name: 'custom-elements'
};
const NO_ERRORS_SCHEMA = {
    name: 'no-errors-schema'
};
let shouldThrowErrorOnUnknownElement = false;
let shouldThrowErrorOnUnknownProperty = false;
function validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {
    if (schemas === null) return;
    if (!hasDirectives && tagName !== null) {
        const isUnknown = typeof HTMLUnknownElement !== 'undefined' && HTMLUnknownElement && element instanceof HTMLUnknownElement || typeof customElements !== 'undefined' && tagName.indexOf('-') > -1 && !customElements.get(tagName);
        if (isUnknown && !matchingSchemas(schemas, tagName)) {
            const isHostStandalone = isHostComponentStandalone(lView);
            const templateLocation = getTemplateLocationDetails(lView);
            const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;
            let message = `'${tagName}' is not a known element${templateLocation}:\n`;
            message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? 'included in the \'@Component.imports\' of this component' : 'a part of an @NgModule where this component is declared'}.\n`;
            if (tagName && tagName.indexOf('-') > -1) message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
            else message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
            if (shouldThrowErrorOnUnknownElement) throw new RuntimeError(304, message);
            else console.error(formatRuntimeError(304, message));
        }
    }
}
function isPropertyValid(element, propName, tagName, schemas) {
    if (schemas === null) return true;
    if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) return true;
    return typeof Node === 'undefined' || Node === null || !(element instanceof Node);
}
function handleUnknownPropertyError(propName, tagName, nodeType, lView) {
    if (!tagName && nodeType === 4) tagName = 'ng-template';
    const isHostStandalone = isHostComponentStandalone(lView);
    const templateLocation = getTemplateLocationDetails(lView);
    let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;
    const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;
    const importLocation = isHostStandalone ? 'included in the \'@Component.imports\' of this component' : 'a part of an @NgModule where this component is declared';
    if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {
        const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);
        message += `\nIf the '${propName}' is an Angular control flow directive, ` + `please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;
    } else {
        message += `\n1. If '${tagName}' is an Angular component and it has the ` + `'${propName}' input, then verify that it is ${importLocation}.`;
        if (tagName && tagName.indexOf('-') > -1) {
            message += `\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' ` + `to the ${schemas} of this component to suppress this message.`;
            message += `\n3. To allow any property add 'NO_ERRORS_SCHEMA' to ` + `the ${schemas} of this component.`;
        } else message += `\n2. To allow any property add 'NO_ERRORS_SCHEMA' to ` + `the ${schemas} of this component.`;
    }
    reportUnknownPropertyError(message);
}
function reportUnknownPropertyError(message) {
    if (shouldThrowErrorOnUnknownProperty) throw new RuntimeError(303, message);
    else console.error(formatRuntimeError(303, message));
}
function getDeclarationComponentDef(lView) {
    !ngDevMode && throwError('Must never be called in production mode');
    const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
    const context = declarationLView[CONTEXT];
    if (!context) return null;
    return context.constructor ? getComponentDef(context.constructor) : null;
}
function isHostComponentStandalone(lView) {
    !ngDevMode && throwError('Must never be called in production mode');
    const componentDef = getDeclarationComponentDef(lView);
    return !!(componentDef === null || componentDef === void 0 ? void 0 : componentDef.standalone);
}
function getTemplateLocationDetails(lView) {
    var _hostComponentDef_type;
    !ngDevMode && throwError('Must never be called in production mode');
    const hostComponentDef = getDeclarationComponentDef(lView);
    const componentClassName = hostComponentDef === null || hostComponentDef === void 0 ? void 0 : (_hostComponentDef_type = hostComponentDef.type) === null || _hostComponentDef_type === void 0 ? void 0 : _hostComponentDef_type.name;
    return componentClassName ? ` (used in the '${componentClassName}' component template)` : '';
}
const KNOWN_CONTROL_FLOW_DIRECTIVES = new Map([
    [
        'ngIf',
        'NgIf'
    ],
    [
        'ngFor',
        'NgFor'
    ],
    [
        'ngSwitchCase',
        'NgSwitchCase'
    ],
    [
        'ngSwitchDefault',
        'NgSwitchDefault'
    ]
]);
function matchingSchemas(schemas, tagName) {
    if (schemas !== null) for(let i = 0; i < schemas.length; i++){
        const schema = schemas[i];
        if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) return true;
    }
    return false;
}
var RendererStyleFlags2 = (()=>{
    RendererStyleFlags2 = RendererStyleFlags2 || {};
    RendererStyleFlags2[RendererStyleFlags2["Important"] = 1] = "Important";
    RendererStyleFlags2[RendererStyleFlags2["DashCase"] = 2] = "DashCase";
    return RendererStyleFlags2;
})();
const COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
const COMMENT_DELIMITER = /(<|>)/;
const COMMENT_DELIMITER_ESCAPED = '\u200B$1\u200B';
function escapeCommentText(value) {
    return value.replace(COMMENT_DISALLOWED, (text)=>text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
}
const TRACKED_LVIEWS = new Map();
let uniqueIdCounter = 0;
function getUniqueLViewId() {
    return uniqueIdCounter++;
}
function registerLView(lView) {
    ngDevMode && assertNumber(lView[ID], 'LView must have an ID in order to be registered');
    TRACKED_LVIEWS.set(lView[ID], lView);
}
function getLViewById(id) {
    ngDevMode && assertNumber(id, 'ID used for LView lookup must be a number');
    return TRACKED_LVIEWS.get(id) || null;
}
function unregisterLView(lView) {
    ngDevMode && assertNumber(lView[ID], 'Cannot stop tracking an LView that does not have an ID');
    TRACKED_LVIEWS.delete(lView[ID]);
}
class LContext {
    get lView() {
        return getLViewById(this.lViewId);
    }
    constructor(lViewId, nodeIndex, native){
        this.lViewId = lViewId;
        this.nodeIndex = nodeIndex;
        this.native = native;
    }
}
function getLContext(target) {
    let mpValue = readPatchedData(target);
    if (mpValue) {
        if (isLView(mpValue)) {
            const lView = mpValue;
            let nodeIndex;
            let component = undefined;
            let directives = undefined;
            if (isComponentInstance(target)) {
                nodeIndex = findViaComponent(lView, target);
                if (nodeIndex == -1) throw new Error('The provided component was not found in the application');
                component = target;
            } else if (isDirectiveInstance(target)) {
                nodeIndex = findViaDirective(lView, target);
                if (nodeIndex == -1) throw new Error('The provided directive was not found in the application');
                directives = getDirectivesAtNodeIndex(nodeIndex, lView);
            } else {
                nodeIndex = findViaNativeElement(lView, target);
                if (nodeIndex == -1) return null;
            }
            const native = unwrapRNode(lView[nodeIndex]);
            const existingCtx = readPatchedData(native);
            const context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
            if (component && context.component === undefined) {
                context.component = component;
                attachPatchData(context.component, context);
            }
            if (directives && context.directives === undefined) {
                context.directives = directives;
                for(let i = 0; i < directives.length; i++)attachPatchData(directives[i], context);
            }
            attachPatchData(context.native, context);
            mpValue = context;
        }
    } else {
        const rElement = target;
        ngDevMode && assertDomNode(rElement);
        let parent = rElement;
        while(parent = parent.parentNode){
            const parentContext = readPatchedData(parent);
            if (parentContext) {
                const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;
                if (!lView) return null;
                const index = findViaNativeElement(lView, rElement);
                if (index >= 0) {
                    const native = unwrapRNode(lView[index]);
                    const context = createLContext(lView, index, native);
                    attachPatchData(native, context);
                    mpValue = context;
                    break;
                }
            }
        }
    }
    return mpValue || null;
}
function createLContext(lView, nodeIndex, native) {
    return new LContext(lView[ID], nodeIndex, native);
}
function getComponentViewByInstance(componentInstance) {
    let patchedData = readPatchedData(componentInstance);
    let lView;
    if (isLView(patchedData)) {
        const contextLView = patchedData;
        const nodeIndex = findViaComponent(contextLView, componentInstance);
        lView = getComponentLViewByIndex(nodeIndex, contextLView);
        const context = createLContext(contextLView, nodeIndex, lView[HOST]);
        context.component = componentInstance;
        attachPatchData(componentInstance, context);
        attachPatchData(context.native, context);
    } else {
        const context = patchedData;
        const contextLView = context.lView;
        ngDevMode && assertLView(contextLView);
        lView = getComponentLViewByIndex(context.nodeIndex, contextLView);
    }
    return lView;
}
const MONKEY_PATCH_KEY_NAME = '__ngContext__';
function attachPatchData(target, data) {
    ngDevMode && assertDefined(target, 'Target expected');
    if (isLView(data)) {
        target[MONKEY_PATCH_KEY_NAME] = data[ID];
        registerLView(data);
    } else target[MONKEY_PATCH_KEY_NAME] = data;
}
function readPatchedData(target) {
    ngDevMode && assertDefined(target, 'Target expected');
    const data = target[MONKEY_PATCH_KEY_NAME];
    return typeof data === 'number' ? getLViewById(data) : data || null;
}
function readPatchedLView(target) {
    const value = readPatchedData(target);
    if (value) return isLView(value) ? value : value.lView;
    return null;
}
function isComponentInstance(instance) {
    return instance && instance.constructor && instance.constructor.ɵcmp;
}
function isDirectiveInstance(instance) {
    return instance && instance.constructor && instance.constructor.ɵdir;
}
function findViaNativeElement(lView, target) {
    const tView = lView[TVIEW];
    for(let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++){
        if (unwrapRNode(lView[i]) === target) return i;
    }
    return -1;
}
function traverseNextElement(tNode) {
    if (tNode.child) return tNode.child;
    else if (tNode.next) return tNode.next;
    else {
        while(tNode.parent && !tNode.parent.next)tNode = tNode.parent;
        return tNode.parent && tNode.parent.next;
    }
}
function findViaComponent(lView, componentInstance) {
    const componentIndices = lView[TVIEW].components;
    if (componentIndices) for(let i = 0; i < componentIndices.length; i++){
        const elementComponentIndex = componentIndices[i];
        const componentView = getComponentLViewByIndex(elementComponentIndex, lView);
        if (componentView[CONTEXT] === componentInstance) return elementComponentIndex;
    }
    else {
        const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);
        const rootComponent = rootComponentView[CONTEXT];
        if (rootComponent === componentInstance) return HEADER_OFFSET;
    }
    return -1;
}
function findViaDirective(lView, directiveInstance) {
    let tNode = lView[TVIEW].firstChild;
    while(tNode){
        const directiveIndexStart = tNode.directiveStart;
        const directiveIndexEnd = tNode.directiveEnd;
        for(let i = directiveIndexStart; i < directiveIndexEnd; i++){
            if (lView[i] === directiveInstance) return tNode.index;
        }
        tNode = traverseNextElement(tNode);
    }
    return -1;
}
function getDirectivesAtNodeIndex(nodeIndex, lView) {
    const tNode = lView[TVIEW].data[nodeIndex];
    if (tNode.directiveStart === 0) return EMPTY_ARRAY;
    const results = [];
    for(let i = tNode.directiveStart; i < tNode.directiveEnd; i++){
        const directiveInstance = lView[i];
        if (!isComponentInstance(directiveInstance)) results.push(directiveInstance);
    }
    return results;
}
function getComponentAtNodeIndex(nodeIndex, lView) {
    const tNode = lView[TVIEW].data[nodeIndex];
    const { directiveStart , componentOffset  } = tNode;
    return componentOffset > -1 ? lView[directiveStart + componentOffset] : null;
}
let _icuContainerIterate;
function icuContainerIterate(tIcuContainerNode, lView) {
    return _icuContainerIterate(tIcuContainerNode, lView);
}
function ensureIcuContainerVisitorLoaded(loader) {
    if (_icuContainerIterate === undefined) _icuContainerIterate = loader();
}
function getLViewParent(lView) {
    ngDevMode && assertLView(lView);
    const parent = lView[PARENT];
    return isLContainer(parent) ? parent[PARENT] : parent;
}
function getRootView(componentOrLView) {
    ngDevMode && assertDefined(componentOrLView, 'component');
    let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
    while(lView && !(lView[FLAGS] & 512))lView = getLViewParent(lView);
    ngDevMode && assertLView(lView);
    return lView;
}
function getRootContext(viewOrComponent) {
    const rootView = getRootView(viewOrComponent);
    ngDevMode && assertDefined(rootView[CONTEXT], 'Root view has no context. Perhaps it is disconnected?');
    return rootView[CONTEXT];
}
function getFirstLContainer(lView) {
    return getNearestLContainer(lView[CHILD_HEAD]);
}
function getNextLContainer(container) {
    return getNearestLContainer(container[NEXT]);
}
function getNearestLContainer(viewOrContainer) {
    while(viewOrContainer !== null && !isLContainer(viewOrContainer))viewOrContainer = viewOrContainer[NEXT];
    return viewOrContainer;
}
function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
    if (lNodeToHandle != null) {
        let lContainer;
        let isComponent = false;
        if (isLContainer(lNodeToHandle)) lContainer = lNodeToHandle;
        else if (isLView(lNodeToHandle)) {
            isComponent = true;
            ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');
            lNodeToHandle = lNodeToHandle[HOST];
        }
        const rNode = unwrapRNode(lNodeToHandle);
        if (action === 0 && parent !== null) {
            if (beforeNode == null) nativeAppendChild(renderer, parent, rNode);
            else nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
        } else if (action === 1 && parent !== null) nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
        else if (action === 2) nativeRemoveNode(renderer, rNode, isComponent);
        else if (action === 3) {
            ngDevMode && ngDevMode.rendererDestroyNode++;
            renderer.destroyNode(rNode);
        }
        if (lContainer != null) applyContainer(renderer, action, lContainer, parent, beforeNode);
    }
}
function createTextNode(renderer, value) {
    ngDevMode && ngDevMode.rendererCreateTextNode++;
    ngDevMode && ngDevMode.rendererSetText++;
    return renderer.createText(value);
}
function updateTextNode(renderer, rNode, value) {
    ngDevMode && ngDevMode.rendererSetText++;
    renderer.setValue(rNode, value);
}
function createCommentNode(renderer, value) {
    ngDevMode && ngDevMode.rendererCreateComment++;
    return renderer.createComment(escapeCommentText(value));
}
function createElementNode(renderer, name, namespace) {
    ngDevMode && ngDevMode.rendererCreateElement++;
    return renderer.createElement(name, namespace);
}
function removeViewFromContainer(tView, lView) {
    const renderer = lView[RENDERER];
    applyView(tView, lView, renderer, 2, null, null);
    lView[HOST] = null;
    lView[T_HOST] = null;
}
function addViewToContainer(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
    lView[HOST] = parentNativeNode;
    lView[T_HOST] = parentTNode;
    applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
}
function renderDetachView(tView, lView) {
    applyView(tView, lView, lView[RENDERER], 2, null, null);
}
function destroyViewTree(rootView) {
    let lViewOrLContainer = rootView[CHILD_HEAD];
    if (!lViewOrLContainer) return cleanUpView(rootView[TVIEW], rootView);
    while(lViewOrLContainer){
        let next = null;
        if (isLView(lViewOrLContainer)) next = lViewOrLContainer[CHILD_HEAD];
        else {
            ngDevMode && assertLContainer(lViewOrLContainer);
            const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
            if (firstView) next = firstView;
        }
        if (!next) {
            while(lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView){
                if (isLView(lViewOrLContainer)) cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
                lViewOrLContainer = lViewOrLContainer[PARENT];
            }
            if (lViewOrLContainer === null) lViewOrLContainer = rootView;
            if (isLView(lViewOrLContainer)) cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
            next = lViewOrLContainer && lViewOrLContainer[NEXT];
        }
        lViewOrLContainer = next;
    }
}
function insertView(tView, lView, lContainer, index) {
    ngDevMode && assertLView(lView);
    ngDevMode && assertLContainer(lContainer);
    const indexInContainer = CONTAINER_HEADER_OFFSET + index;
    const containerLength = lContainer.length;
    if (index > 0) lContainer[indexInContainer - 1][NEXT] = lView;
    if (index < containerLength - CONTAINER_HEADER_OFFSET) {
        lView[NEXT] = lContainer[indexInContainer];
        addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);
    } else {
        lContainer.push(lView);
        lView[NEXT] = null;
    }
    lView[PARENT] = lContainer;
    const declarationLContainer = lView[DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && lContainer !== declarationLContainer) trackMovedView(declarationLContainer, lView);
    const lQueries = lView[QUERIES];
    if (lQueries !== null) lQueries.insertView(tView);
    lView[FLAGS] |= 128;
}
function trackMovedView(declarationContainer, lView) {
    ngDevMode && assertDefined(lView, 'LView required');
    ngDevMode && assertLContainer(declarationContainer);
    const movedViews = declarationContainer[MOVED_VIEWS];
    const insertedLContainer = lView[PARENT];
    ngDevMode && assertLContainer(insertedLContainer);
    const insertedComponentLView = insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(insertedComponentLView, 'Missing insertedComponentLView');
    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(declaredComponentLView, 'Missing declaredComponentLView');
    if (declaredComponentLView !== insertedComponentLView) declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;
    if (movedViews === null) declarationContainer[MOVED_VIEWS] = [
        lView
    ];
    else movedViews.push(lView);
}
function detachMovedView(declarationContainer, lView) {
    ngDevMode && assertLContainer(declarationContainer);
    ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], 'A projected view should belong to a non-empty projected views collection');
    const movedViews = declarationContainer[MOVED_VIEWS];
    const declarationViewIndex = movedViews.indexOf(lView);
    const insertionLContainer = lView[PARENT];
    ngDevMode && assertLContainer(insertionLContainer);
    clearViewRefreshFlag(lView);
    movedViews.splice(declarationViewIndex, 1);
}
function detachView(lContainer, removeIndex) {
    if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;
    const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
    const viewToDetach = lContainer[indexInContainer];
    if (viewToDetach) {
        const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
        if (declarationLContainer !== null && declarationLContainer !== lContainer) detachMovedView(declarationLContainer, viewToDetach);
        if (removeIndex > 0) lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
        const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
        removeViewFromContainer(viewToDetach[TVIEW], viewToDetach);
        const lQueries = removedLView[QUERIES];
        if (lQueries !== null) lQueries.detachView(removedLView[TVIEW]);
        viewToDetach[PARENT] = null;
        viewToDetach[NEXT] = null;
        viewToDetach[FLAGS] &= -129;
    }
    return viewToDetach;
}
function destroyLView(tView, lView) {
    if (!(lView[FLAGS] & 256)) {
        var _lView_REACTIVE_TEMPLATE_CONSUMER, _lView_REACTIVE_HOST_BINDING_CONSUMER;
        const renderer = lView[RENDERER];
        (_lView_REACTIVE_TEMPLATE_CONSUMER = lView[REACTIVE_TEMPLATE_CONSUMER]) === null || _lView_REACTIVE_TEMPLATE_CONSUMER === void 0 || _lView_REACTIVE_TEMPLATE_CONSUMER.destroy();
        (_lView_REACTIVE_HOST_BINDING_CONSUMER = lView[REACTIVE_HOST_BINDING_CONSUMER]) === null || _lView_REACTIVE_HOST_BINDING_CONSUMER === void 0 || _lView_REACTIVE_HOST_BINDING_CONSUMER.destroy();
        if (renderer.destroyNode) applyView(tView, lView, renderer, 3, null, null);
        destroyViewTree(lView);
    }
}
function cleanUpView(tView, lView) {
    if (!(lView[FLAGS] & 256)) {
        lView[FLAGS] &= -129;
        lView[FLAGS] |= 256;
        executeOnDestroys(tView, lView);
        processCleanups(tView, lView);
        if (lView[TVIEW].type === 1) {
            ngDevMode && ngDevMode.rendererDestroy++;
            lView[RENDERER].destroy();
        }
        const declarationContainer = lView[DECLARATION_LCONTAINER];
        if (declarationContainer !== null && isLContainer(lView[PARENT])) {
            if (declarationContainer !== lView[PARENT]) detachMovedView(declarationContainer, lView);
            const lQueries = lView[QUERIES];
            if (lQueries !== null) lQueries.detachView(tView);
        }
        unregisterLView(lView);
    }
}
function processCleanups(tView, lView) {
    const tCleanup = tView.cleanup;
    const lCleanup = lView[CLEANUP];
    if (tCleanup !== null) {
        for(let i = 0; i < tCleanup.length - 1; i += 2)if (typeof tCleanup[i] === 'string') {
            const targetIdx = tCleanup[i + 3];
            ngDevMode && assertNumber(targetIdx, 'cleanup target must be a number');
            if (targetIdx >= 0) lCleanup[targetIdx]();
            else lCleanup[-targetIdx].unsubscribe();
            i += 2;
        } else {
            const context = lCleanup[tCleanup[i + 1]];
            tCleanup[i].call(context);
        }
    }
    if (lCleanup !== null) lView[CLEANUP] = null;
    const destroyHooks = lView[ON_DESTROY_HOOKS];
    if (destroyHooks !== null) {
        for(let i = 0; i < destroyHooks.length; i++){
            const destroyHooksFn = destroyHooks[i];
            ngDevMode && assertFunction(destroyHooksFn, 'Expecting destroy hook to be a function.');
            destroyHooksFn();
        }
        lView[ON_DESTROY_HOOKS] = null;
    }
}
function executeOnDestroys(tView, lView) {
    let destroyHooks;
    if (tView != null && (destroyHooks = tView.destroyHooks) != null) for(let i = 0; i < destroyHooks.length; i += 2){
        const context = lView[destroyHooks[i]];
        if (!(context instanceof NodeInjectorFactory)) {
            const toCall = destroyHooks[i + 1];
            if (Array.isArray(toCall)) for(let j = 0; j < toCall.length; j += 2){
                const callContext = context[toCall[j]];
                const hook = toCall[j + 1];
                profiler(4, callContext, hook);
                try {
                    hook.call(callContext);
                } finally{
                    profiler(5, callContext, hook);
                }
            }
            else {
                profiler(4, context, toCall);
                try {
                    toCall.call(context);
                } finally{
                    profiler(5, context, toCall);
                }
            }
        }
    }
}
function getParentRElement(tView, tNode, lView) {
    return getClosestRElement(tView, tNode.parent, lView);
}
function getClosestRElement(tView, tNode, lView) {
    let parentTNode = tNode;
    while(parentTNode !== null && parentTNode.type & 40){
        tNode = parentTNode;
        parentTNode = tNode.parent;
    }
    if (parentTNode === null) return lView[HOST];
    else {
        ngDevMode && assertTNodeType(parentTNode, 7);
        const { componentOffset  } = parentTNode;
        if (componentOffset > -1) {
            ngDevMode && assertTNodeForLView(parentTNode, lView);
            const { encapsulation  } = tView.data[parentTNode.directiveStart + componentOffset];
            if (encapsulation === ViewEncapsulation$1.None || encapsulation === ViewEncapsulation$1.Emulated) return null;
        }
        return getNativeByTNode(parentTNode, lView);
    }
}
function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
    ngDevMode && ngDevMode.rendererInsertBefore++;
    renderer.insertBefore(parent, child, beforeNode, isMove);
}
function nativeAppendChild(renderer, parent, child) {
    ngDevMode && ngDevMode.rendererAppendChild++;
    ngDevMode && assertDefined(parent, 'parent node must be defined');
    renderer.appendChild(parent, child);
}
function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
    if (beforeNode !== null) nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
    else nativeAppendChild(renderer, parent, child);
}
function nativeRemoveChild(renderer, parent, child, isHostElement) {
    renderer.removeChild(parent, child, isHostElement);
}
function nativeParentNode(renderer, node) {
    return renderer.parentNode(node);
}
function nativeNextSibling(renderer, node) {
    return renderer.nextSibling(node);
}
function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
    return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
}
function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
    if (parentTNode.type & 40) return getNativeByTNode(parentTNode, lView);
    return null;
}
let _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
let _processI18nInsertBefore;
function setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore) {
    _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n;
    _processI18nInsertBefore = processI18nInsertBefore;
}
function appendChild(tView, lView, childRNode, childTNode) {
    const parentRNode = getParentRElement(tView, childTNode, lView);
    const renderer = lView[RENDERER];
    const parentTNode = childTNode.parent || lView[T_HOST];
    const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
    if (parentRNode != null) {
        if (Array.isArray(childRNode)) for(let i = 0; i < childRNode.length; i++)nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
        else nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
    }
    _processI18nInsertBefore !== undefined && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
}
function getFirstNativeNode(lView, tNode) {
    if (tNode !== null) {
        ngDevMode && assertTNodeType(tNode, 63);
        const tNodeType = tNode.type;
        if (tNodeType & 3) return getNativeByTNode(tNode, lView);
        else if (tNodeType & 4) return getBeforeNodeForView(-1, lView[tNode.index]);
        else if (tNodeType & 8) {
            const elIcuContainerChild = tNode.child;
            if (elIcuContainerChild !== null) return getFirstNativeNode(lView, elIcuContainerChild);
            else {
                const rNodeOrLContainer = lView[tNode.index];
                if (isLContainer(rNodeOrLContainer)) return getBeforeNodeForView(-1, rNodeOrLContainer);
                else return unwrapRNode(rNodeOrLContainer);
            }
        } else if (tNodeType & 32) {
            let nextRNode = icuContainerIterate(tNode, lView);
            let rNode = nextRNode();
            return rNode || unwrapRNode(lView[tNode.index]);
        } else {
            const projectionNodes = getProjectionNodes(lView, tNode);
            if (projectionNodes !== null) {
                if (Array.isArray(projectionNodes)) return projectionNodes[0];
                const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
                ngDevMode && assertParentView(parentView);
                return getFirstNativeNode(parentView, projectionNodes);
            } else return getFirstNativeNode(lView, tNode.next);
        }
    }
    return null;
}
function getProjectionNodes(lView, tNode) {
    if (tNode !== null) {
        const componentView = lView[DECLARATION_COMPONENT_VIEW];
        const componentHost = componentView[T_HOST];
        const slotIdx = tNode.projection;
        ngDevMode && assertProjectionSlots(lView);
        return componentHost.projection[slotIdx];
    }
    return null;
}
function getBeforeNodeForView(viewIndexInContainer, lContainer) {
    const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
    if (nextViewIndex < lContainer.length) {
        const lView = lContainer[nextViewIndex];
        const firstTNodeOfView = lView[TVIEW].firstChild;
        if (firstTNodeOfView !== null) return getFirstNativeNode(lView, firstTNodeOfView);
    }
    return lContainer[NATIVE];
}
function nativeRemoveNode(renderer, rNode, isHostElement) {
    ngDevMode && ngDevMode.rendererRemoveNode++;
    const nativeParent = nativeParentNode(renderer, rNode);
    if (nativeParent) nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);
}
function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
    while(tNode != null){
        ngDevMode && assertTNodeForLView(tNode, lView);
        ngDevMode && assertTNodeType(tNode, 63);
        const rawSlotValue = lView[tNode.index];
        const tNodeType = tNode.type;
        if (isProjection) {
            if (action === 0) {
                rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
                tNode.flags |= 2;
            }
        }
        if ((tNode.flags & 32) !== 32) {
            if (tNodeType & 8) {
                applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
                applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
            } else if (tNodeType & 32) {
                const nextRNode = icuContainerIterate(tNode, lView);
                let rNode;
                while(rNode = nextRNode())applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
                applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
            } else if (tNodeType & 16) applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
            else {
                ngDevMode && assertTNodeType(tNode, 7);
                applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
            }
        }
        tNode = isProjection ? tNode.projectionNext : tNode.next;
    }
}
function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
    applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
}
function applyProjection(tView, lView, tProjectionNode) {
    const renderer = lView[RENDERER];
    const parentRNode = getParentRElement(tView, tProjectionNode, lView);
    const parentTNode = tProjectionNode.parent || lView[T_HOST];
    let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
    applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
}
function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
    const componentLView = lView[DECLARATION_COMPONENT_VIEW];
    const componentNode = componentLView[T_HOST];
    ngDevMode && assertEqual(typeof tProjectionNode.projection, 'number', 'expecting projection index');
    const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
    if (Array.isArray(nodeToProjectOrRNodes)) for(let i = 0; i < nodeToProjectOrRNodes.length; i++){
        const rNode = nodeToProjectOrRNodes[i];
        applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
    }
    else {
        let nodeToProject = nodeToProjectOrRNodes;
        const projectedComponentLView = componentLView[PARENT];
        applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
    }
}
function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
    ngDevMode && assertLContainer(lContainer);
    const anchor = lContainer[NATIVE];
    const native = unwrapRNode(lContainer);
    if (anchor !== native) applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
    for(let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++){
        const lView = lContainer[i];
        applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
    }
}
function applyStyling(renderer, isClassBased, rNode, prop, value) {
    if (isClassBased) {
        if (!value) {
            ngDevMode && ngDevMode.rendererRemoveClass++;
            renderer.removeClass(rNode, prop);
        } else {
            ngDevMode && ngDevMode.rendererAddClass++;
            renderer.addClass(rNode, prop);
        }
    } else {
        let flags = prop.indexOf('-') === -1 ? undefined : RendererStyleFlags2.DashCase;
        if (value == null) {
            ngDevMode && ngDevMode.rendererRemoveStyle++;
            renderer.removeStyle(rNode, prop, flags);
        } else {
            const isImportant = typeof value === 'string' ? value.endsWith('!important') : false;
            if (isImportant) {
                value = value.slice(0, -10);
                flags |= RendererStyleFlags2.Important;
            }
            ngDevMode && ngDevMode.rendererSetStyle++;
            renderer.setStyle(rNode, prop, value, flags);
        }
    }
}
function writeDirectStyle(renderer, element, newValue) {
    ngDevMode && assertString(newValue, '\'newValue\' should be a string');
    renderer.setAttribute(element, 'style', newValue);
    ngDevMode && ngDevMode.rendererSetStyle++;
}
function writeDirectClass(renderer, element, newValue) {
    ngDevMode && assertString(newValue, '\'newValue\' should be a string');
    if (newValue === '') renderer.removeAttribute(element, 'class');
    else renderer.setAttribute(element, 'class', newValue);
    ngDevMode && ngDevMode.rendererSetClassName++;
}
function setupStaticAttributes(renderer, element, tNode) {
    const { mergedAttrs , classes , styles  } = tNode;
    if (mergedAttrs !== null) setUpAttributes(renderer, element, mergedAttrs);
    if (classes !== null) writeDirectClass(renderer, element, classes);
    if (styles !== null) writeDirectStyle(renderer, element, styles);
}
let policy$1;
function getPolicy$1() {
    if (policy$1 === undefined) {
        policy$1 = null;
        if (_global.trustedTypes) try {
            policy$1 = _global.trustedTypes.createPolicy('angular', {
                createHTML: (s)=>s,
                createScript: (s)=>s,
                createScriptURL: (s)=>s
            });
        } catch (e) {}
    }
    return policy$1;
}
function trustedHTMLFromString(html) {
    var _getPolicy$1;
    return ((_getPolicy$1 = getPolicy$1()) === null || _getPolicy$1 === void 0 ? void 0 : _getPolicy$1.createHTML(html)) || html;
}
function trustedScriptURLFromString(url) {
    var _getPolicy$1;
    return ((_getPolicy$1 = getPolicy$1()) === null || _getPolicy$1 === void 0 ? void 0 : _getPolicy$1.createScriptURL(url)) || url;
}
function ɵɵvalidateIframeAttribute(attrValue, tagName, attrName) {
    const lView = getLView();
    const tNode = getSelectedTNode();
    const element = getNativeByTNode(tNode, lView);
    if (tNode.type === 2 && tagName.toLowerCase() === 'iframe') {
        const iframe = element;
        iframe.src = '';
        iframe.srcdoc = trustedHTMLFromString('');
        nativeRemoveNode(lView[RENDERER], iframe);
        const errorMessage = ngDevMode && `Angular has detected that the \`${attrName}\` was applied ` + `as a binding to an <iframe>${getTemplateLocationDetails(lView)}. ` + `For security reasons, the \`${attrName}\` can be set on an <iframe> ` + `as a static attribute only. \n` + `To fix this, switch the \`${attrName}\` binding to a static attribute ` + `in a template or in host bindings section.`;
        throw new RuntimeError(-910, errorMessage);
    }
    return attrValue;
}
let DOCUMENT = undefined;
function setDocument(document1) {
    DOCUMENT = document1;
}
function getDocument() {
    if (DOCUMENT !== undefined) return DOCUMENT;
    else if (typeof document !== 'undefined') return document;
    return undefined;
}
let policy;
function getPolicy() {
    if (policy === undefined) {
        policy = null;
        if (_global.trustedTypes) try {
            policy = _global.trustedTypes.createPolicy('angular#unsafe-bypass', {
                createHTML: (s)=>s,
                createScript: (s)=>s,
                createScriptURL: (s)=>s
            });
        } catch (e) {}
    }
    return policy;
}
function trustedHTMLFromStringBypass(html) {
    var _getPolicy;
    return ((_getPolicy = getPolicy()) === null || _getPolicy === void 0 ? void 0 : _getPolicy.createHTML(html)) || html;
}
function trustedScriptFromStringBypass(script) {
    var _getPolicy;
    return ((_getPolicy = getPolicy()) === null || _getPolicy === void 0 ? void 0 : _getPolicy.createScript(script)) || script;
}
function trustedScriptURLFromStringBypass(url) {
    var _getPolicy;
    return ((_getPolicy = getPolicy()) === null || _getPolicy === void 0 ? void 0 : _getPolicy.createScriptURL(url)) || url;
}
class SafeValueImpl {
    toString() {
        return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` + ` (see ${XSS_SECURITY_URL})`;
    }
    constructor(changingThisBreaksApplicationSecurity){
        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
    }
}
class SafeHtmlImpl extends SafeValueImpl {
    getTypeName() {
        return "HTML";
    }
}
class SafeStyleImpl extends SafeValueImpl {
    getTypeName() {
        return "Style";
    }
}
class SafeScriptImpl extends SafeValueImpl {
    getTypeName() {
        return "Script";
    }
}
class SafeUrlImpl extends SafeValueImpl {
    getTypeName() {
        return "URL";
    }
}
class SafeResourceUrlImpl extends SafeValueImpl {
    getTypeName() {
        return "ResourceURL";
    }
}
function unwrapSafeValue(value) {
    return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
}
function allowSanitizationBypassAndThrow(value, type) {
    const actualType = getSanitizationBypassType(value);
    if (actualType != null && actualType !== type) {
        if (actualType === "ResourceURL" && type === "URL") return true;
        throw new Error(`Required a safe ${type}, got a ${actualType} (see ${XSS_SECURITY_URL})`);
    }
    return actualType === type;
}
function getSanitizationBypassType(value) {
    return value instanceof SafeValueImpl && value.getTypeName() || null;
}
function bypassSanitizationTrustHtml(trustedHtml) {
    return new SafeHtmlImpl(trustedHtml);
}
function bypassSanitizationTrustStyle(trustedStyle) {
    return new SafeStyleImpl(trustedStyle);
}
function bypassSanitizationTrustScript(trustedScript) {
    return new SafeScriptImpl(trustedScript);
}
function bypassSanitizationTrustUrl(trustedUrl) {
    return new SafeUrlImpl(trustedUrl);
}
function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
    return new SafeResourceUrlImpl(trustedResourceUrl);
}
function getInertBodyHelper(defaultDoc) {
    const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
    return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
}
class DOMParserHelper {
    getInertBodyElement(html) {
        html = '<body><remove></remove>' + html;
        try {
            const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), 'text/html').body;
            if (body === null) return this.inertDocumentHelper.getInertBodyElement(html);
            body.removeChild(body.firstChild);
            return body;
        } catch (e) {
            return null;
        }
    }
    constructor(inertDocumentHelper){
        this.inertDocumentHelper = inertDocumentHelper;
    }
}
class InertDocumentHelper {
    getInertBodyElement(html) {
        const templateEl = this.inertDocument.createElement('template');
        templateEl.innerHTML = trustedHTMLFromString(html);
        return templateEl;
    }
    constructor(defaultDoc){
        this.defaultDoc = defaultDoc;
        this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');
    }
}
function isDOMParserAvailable() {
    try {
        return !!new window.DOMParser().parseFromString(trustedHTMLFromString(''), 'text/html');
    } catch (e) {
        return false;
    }
}
const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
function _sanitizeUrl(url) {
    url = String(url);
    if (url.match(SAFE_URL_PATTERN)) return url;
    if (typeof ngDevMode === 'undefined' || ngDevMode) console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`);
    return 'unsafe:' + url;
}
function tagSet(tags) {
    const res = {};
    for (const t of tags.split(','))res[t] = true;
    return res;
}
function merge(...sets) {
    const res = {};
    for (const s of sets){
        for(const v in s)if (s.hasOwnProperty(v)) res[v] = true;
    }
    return res;
}
const VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
const OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
const OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
const OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
const BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
const INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
const VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
const URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
const HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
const ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
const VALID_ATTRS = merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);
const SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');
class SanitizingHtmlSerializer {
    sanitizeChildren(el) {
        let current = el.firstChild;
        let traverseContent = true;
        while(current){
            if (current.nodeType === Node.ELEMENT_NODE) traverseContent = this.startElement(current);
            else if (current.nodeType === Node.TEXT_NODE) this.chars(current.nodeValue);
            else this.sanitizedSomething = true;
            if (traverseContent && current.firstChild) {
                current = current.firstChild;
                continue;
            }
            while(current){
                if (current.nodeType === Node.ELEMENT_NODE) this.endElement(current);
                let next = this.checkClobberedElement(current, current.nextSibling);
                if (next) {
                    current = next;
                    break;
                }
                current = this.checkClobberedElement(current, current.parentNode);
            }
        }
        return this.buf.join('');
    }
    startElement(element) {
        const tagName = element.nodeName.toLowerCase();
        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
            this.sanitizedSomething = true;
            return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
        }
        this.buf.push('<');
        this.buf.push(tagName);
        const elAttrs = element.attributes;
        for(let i = 0; i < elAttrs.length; i++){
            const elAttr = elAttrs.item(i);
            const attrName = elAttr.name;
            const lower = attrName.toLowerCase();
            if (!VALID_ATTRS.hasOwnProperty(lower)) {
                this.sanitizedSomething = true;
                continue;
            }
            let value = elAttr.value;
            if (URI_ATTRS[lower]) value = _sanitizeUrl(value);
            this.buf.push(' ', attrName, '="', encodeEntities(value), '"');
        }
        this.buf.push('>');
        return true;
    }
    endElement(current) {
        const tagName = current.nodeName.toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
            this.buf.push('</');
            this.buf.push(tagName);
            this.buf.push('>');
        }
    }
    chars(chars) {
        this.buf.push(encodeEntities(chars));
    }
    checkClobberedElement(node, nextNode) {
        if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
        return nextNode;
    }
    constructor(){
        this.sanitizedSomething = false;
        this.buf = [];
    }
}
const SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
const NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
function encodeEntities(value) {
    return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(match) {
        const hi = match.charCodeAt(0);
        const low = match.charCodeAt(1);
        return '&#' + ((hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000) + ';';
    }).replace(NON_ALPHANUMERIC_REGEXP, function(match) {
        return '&#' + match.charCodeAt(0) + ';';
    }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
let inertBodyHelper;
function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
    let inertBodyElement = null;
    try {
        inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
        let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
        inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
        let mXSSAttempts = 5;
        let parsedHtml = unsafeHtml;
        do {
            if (mXSSAttempts === 0) throw new Error('Failed to sanitize html because the input is unstable');
            mXSSAttempts--;
            unsafeHtml = parsedHtml;
            parsedHtml = inertBodyElement.innerHTML;
            inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
        }while (unsafeHtml !== parsedHtml)
        const sanitizer = new SanitizingHtmlSerializer();
        const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
        if ((typeof ngDevMode === 'undefined' || ngDevMode) && sanitizer.sanitizedSomething) console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`);
        return trustedHTMLFromString(safeHtml);
    } finally{
        if (inertBodyElement) {
            const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
            while(parent.firstChild)parent.removeChild(parent.firstChild);
        }
    }
}
function getTemplateContent(el) {
    return 'content' in el && isTemplateElement(el) ? el.content : null;
}
function isTemplateElement(el) {
    return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';
}
var SecurityContext = (()=>{
    SecurityContext = SecurityContext || {};
    SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
    SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
    SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
    SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
    SecurityContext[SecurityContext["URL"] = 4] = "URL";
    SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
    return SecurityContext;
})();
function ɵɵsanitizeHtml(unsafeHtml) {
    const sanitizer = getSanitizer();
    if (sanitizer) return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '');
    if (allowSanitizationBypassAndThrow(unsafeHtml, "HTML")) return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
    return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
}
function ɵɵsanitizeStyle(unsafeStyle) {
    const sanitizer = getSanitizer();
    if (sanitizer) return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';
    if (allowSanitizationBypassAndThrow(unsafeStyle, "Style")) return unwrapSafeValue(unsafeStyle);
    return renderStringify(unsafeStyle);
}
function ɵɵsanitizeUrl(unsafeUrl) {
    const sanitizer = getSanitizer();
    if (sanitizer) return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';
    if (allowSanitizationBypassAndThrow(unsafeUrl, "URL")) return unwrapSafeValue(unsafeUrl);
    return _sanitizeUrl(renderStringify(unsafeUrl));
}
function ɵɵsanitizeResourceUrl(unsafeResourceUrl) {
    const sanitizer = getSanitizer();
    if (sanitizer) return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '');
    if (allowSanitizationBypassAndThrow(unsafeResourceUrl, "ResourceURL")) return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
    throw new RuntimeError(904, ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
}
function ɵɵsanitizeScript(unsafeScript) {
    const sanitizer = getSanitizer();
    if (sanitizer) return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '');
    if (allowSanitizationBypassAndThrow(unsafeScript, "Script")) return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
    throw new RuntimeError(905, ngDevMode && 'unsafe value used in a script context');
}
function ɵɵtrustConstantHtml(html) {
    if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join('?')}`);
    return trustedHTMLFromString(html[0]);
}
function ɵɵtrustConstantResourceUrl(url) {
    if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join('?')}`);
    return trustedScriptURLFromString(url[0]);
}
function getUrlSanitizer(tag, prop) {
    if (prop === 'src' && (tag === 'embed' || tag === 'frame' || tag === 'iframe' || tag === 'media' || tag === 'script') || prop === 'href' && (tag === 'base' || tag === 'link')) return ɵɵsanitizeResourceUrl;
    return ɵɵsanitizeUrl;
}
function ɵɵsanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
    return getUrlSanitizer(tag, prop)(unsafeUrl);
}
function validateAgainstEventProperties(name) {
    if (name.toLowerCase().startsWith('on')) {
        const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...` + `\nIf '${name}' is a directive input, make sure the directive is imported by the` + ` current module.`;
        throw new RuntimeError(306, errorMessage);
    }
}
function validateAgainstEventAttributes(name) {
    if (name.toLowerCase().startsWith('on')) {
        const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...`;
        throw new RuntimeError(306, errorMessage);
    }
}
function getSanitizer() {
    const lView = getLView();
    return lView && lView[ENVIRONMENT].sanitizer;
}
class InjectionToken {
    get multi() {
        return this;
    }
    toString() {
        return `InjectionToken ${this._desc}`;
    }
    constructor(_desc, options){
        this._desc = _desc;
        this.ngMetadataName = 'InjectionToken';
        this.ɵprov = undefined;
        if (typeof options == 'number') {
            (typeof ngDevMode === 'undefined' || ngDevMode) && assertLessThan(options, 0, 'Only negative numbers are supported here');
            this.__NG_ELEMENT_ID__ = options;
        } else if (options !== undefined) this.ɵprov = ɵɵdefineInjectable({
            token: this,
            providedIn: options.providedIn || 'root',
            factory: options.factory
        });
    }
}
const ENVIRONMENT_INITIALIZER = new InjectionToken('ENVIRONMENT_INITIALIZER');
const INJECTOR = new InjectionToken('INJECTOR', -1);
const INJECTOR_DEF_TYPES = new InjectionToken('INJECTOR_DEF_TYPES');
class NullInjector {
    get(token, notFoundValue = THROW_IF_NOT_FOUND) {
        if (notFoundValue === THROW_IF_NOT_FOUND) {
            const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
            error.name = 'NullInjectorError';
            throw error;
        }
        return notFoundValue;
    }
}
function importProvidersFrom(...sources) {
    return {
        ɵproviders: internalImportProvidersFrom(true, sources),
        ɵfromNgModule: true
    };
}
function internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {
    const providersOut = [];
    const dedup = new Set();
    let injectorTypesWithProviders;
    deepForEach(sources, (source)=>{
        if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {
            const cmpDef = getComponentDef(source);
            if (cmpDef === null || cmpDef === void 0 ? void 0 : cmpDef.standalone) throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`);
        }
        const internalSource = source;
        if (walkProviderTree(internalSource, providersOut, [], dedup)) {
            injectorTypesWithProviders || (injectorTypesWithProviders = []);
            injectorTypesWithProviders.push(internalSource);
        }
    });
    if (injectorTypesWithProviders !== undefined) processInjectorTypesWithProviders(injectorTypesWithProviders, providersOut);
    return providersOut;
}
function processInjectorTypesWithProviders(typesWithProviders, providersOut) {
    for(let i = 0; i < typesWithProviders.length; i++){
        const { ngModule , providers  } = typesWithProviders[i];
        deepForEachProvider(providers, (provider)=>{
            ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);
            providersOut.push(provider);
        });
    }
}
function walkProviderTree(container, providersOut, parents, dedup) {
    container = resolveForwardRef(container);
    if (!container) return false;
    let defType = null;
    let injDef = getInjectorDef(container);
    const cmpDef = !injDef && getComponentDef(container);
    if (!injDef && !cmpDef) {
        const ngModule = container.ngModule;
        injDef = getInjectorDef(ngModule);
        if (injDef) defType = ngModule;
        else return false;
    } else if (cmpDef && !cmpDef.standalone) return false;
    else defType = container;
    if (ngDevMode && parents.indexOf(defType) !== -1) {
        const defName = stringify(defType);
        const path = parents.map(stringify);
        throwCyclicDependencyError(defName, path);
    }
    const isDuplicate = dedup.has(defType);
    if (cmpDef) {
        if (isDuplicate) return false;
        dedup.add(defType);
        if (cmpDef.dependencies) {
            const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;
            for (const dep of deps)walkProviderTree(dep, providersOut, parents, dedup);
        }
    } else if (injDef) {
        if (injDef.imports != null && !isDuplicate) {
            ngDevMode && parents.push(defType);
            dedup.add(defType);
            let importTypesWithProviders;
            try {
                deepForEach(injDef.imports, (imported)=>{
                    if (walkProviderTree(imported, providersOut, parents, dedup)) {
                        importTypesWithProviders || (importTypesWithProviders = []);
                        importTypesWithProviders.push(imported);
                    }
                });
            } finally{
                ngDevMode && parents.pop();
            }
            if (importTypesWithProviders !== undefined) processInjectorTypesWithProviders(importTypesWithProviders, providersOut);
        }
        if (!isDuplicate) {
            const factory = getFactoryDef(defType) || (()=>new defType());
            providersOut.push({
                provide: defType,
                useFactory: factory,
                deps: EMPTY_ARRAY
            }, {
                provide: INJECTOR_DEF_TYPES,
                useValue: defType,
                multi: true
            }, {
                provide: ENVIRONMENT_INITIALIZER,
                useValue: ()=>ɵɵinject(defType),
                multi: true
            });
        }
        const defProviders = injDef.providers;
        if (defProviders != null && !isDuplicate) {
            const injectorType = container;
            deepForEachProvider(defProviders, (provider)=>{
                ngDevMode && validateProvider(provider, defProviders, injectorType);
                providersOut.push(provider);
            });
        }
    } else return false;
    return defType !== container && container.providers !== undefined;
}
function validateProvider(provider, providers, containerType) {
    if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) return;
    const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
    if (!classRef) throwInvalidProviderError(containerType, providers, provider);
}
function deepForEachProvider(providers, fn) {
    for (let provider of providers){
        if (isEnvironmentProviders(provider)) provider = provider.ɵproviders;
        if (Array.isArray(provider)) deepForEachProvider(provider, fn);
        else fn(provider);
    }
}
const USE_VALUE$1 = getClosureSafeProperty({
    provide: String,
    useValue: getClosureSafeProperty
});
function isValueProvider(value) {
    return value !== null && typeof value == 'object' && USE_VALUE$1 in value;
}
function isExistingProvider(value) {
    return !!(value && value.useExisting);
}
function isFactoryProvider(value) {
    return !!(value && value.useFactory);
}
function isTypeProvider(value) {
    return typeof value === 'function';
}
function isClassProvider(value) {
    return !!value.useClass;
}
const INJECTOR_SCOPE = new InjectionToken('Set Injector scope.');
const NOT_YET = {};
const CIRCULAR = {};
let NULL_INJECTOR$1 = undefined;
function getNullInjector() {
    if (NULL_INJECTOR$1 === undefined) NULL_INJECTOR$1 = new NullInjector();
    return NULL_INJECTOR$1;
}
class EnvironmentInjector {
}
class R3Injector extends EnvironmentInjector {
    get destroyed() {
        return this._destroyed;
    }
    destroy() {
        this.assertNotDestroyed();
        this._destroyed = true;
        try {
            for (const service of this._ngOnDestroyHooks)service.ngOnDestroy();
            for (const hook of this._onDestroyHooks)hook();
        } finally{
            this.records.clear();
            this._ngOnDestroyHooks.clear();
            this.injectorDefTypes.clear();
            this._onDestroyHooks.length = 0;
        }
    }
    onDestroy(callback) {
        this.assertNotDestroyed();
        this._onDestroyHooks.push(callback);
        return ()=>this.removeOnDestroy(callback);
    }
    runInContext(fn) {
        this.assertNotDestroyed();
        const previousInjector = setCurrentInjector(this);
        const previousInjectImplementation = setInjectImplementation(undefined);
        try {
            return fn();
        } finally{
            setCurrentInjector(previousInjector);
            setInjectImplementation(previousInjectImplementation);
        }
    }
    get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
        this.assertNotDestroyed();
        if (token.hasOwnProperty(NG_ENV_ID)) return token[NG_ENV_ID](this);
        flags = convertToBitFlags(flags);
        const previousInjector = setCurrentInjector(this);
        const previousInjectImplementation = setInjectImplementation(undefined);
        try {
            if (!(flags & InjectFlags.SkipSelf)) {
                let record = this.records.get(token);
                if (record === undefined) {
                    const def = couldBeInjectableType(token) && getInjectableDef(token);
                    if (def && this.injectableDefInScope(def)) record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
                    else record = null;
                    this.records.set(token, record);
                }
                if (record != null) return this.hydrate(token, record);
            }
            const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();
            notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
            return nextInjector.get(token, notFoundValue);
        } catch (e) {
            if (e.name === 'NullInjectorError') {
                const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
                path.unshift(stringify(token));
                if (previousInjector) throw e;
                else return catchInjectorError(e, token, 'R3InjectorError', this.source);
            } else throw e;
        } finally{
            setInjectImplementation(previousInjectImplementation);
            setCurrentInjector(previousInjector);
        }
    }
    resolveInjectorInitializers() {
        const previousInjector = setCurrentInjector(this);
        const previousInjectImplementation = setInjectImplementation(undefined);
        try {
            const initializers = this.get(ENVIRONMENT_INITIALIZER.multi, EMPTY_ARRAY, InjectFlags.Self);
            if (ngDevMode && !Array.isArray(initializers)) throw new RuntimeError(-209, 'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' + `(expected an array, but got ${typeof initializers}). ` + 'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' + '`multi: true` provider.');
            for (const initializer of initializers)initializer();
        } finally{
            setCurrentInjector(previousInjector);
            setInjectImplementation(previousInjectImplementation);
        }
    }
    toString() {
        const tokens = [];
        const records = this.records;
        for (const token of records.keys())tokens.push(stringify(token));
        return `R3Injector[${tokens.join(', ')}]`;
    }
    assertNotDestroyed() {
        if (this._destroyed) throw new RuntimeError(205, ngDevMode && 'Injector has already been destroyed.');
    }
    processProvider(provider) {
        provider = resolveForwardRef(provider);
        let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
        const record = providerToRecord(provider);
        if (!isTypeProvider(provider) && provider.multi === true) {
            let multiRecord = this.records.get(token);
            if (multiRecord) {
                if (ngDevMode && multiRecord.multi === undefined) throwMixedMultiProviderError();
            } else {
                multiRecord = makeRecord(undefined, NOT_YET, true);
                multiRecord.factory = ()=>injectArgs(multiRecord.multi);
                this.records.set(token, multiRecord);
            }
            token = provider;
            multiRecord.multi.push(provider);
        } else {
            const existing = this.records.get(token);
            if (ngDevMode && existing && existing.multi !== undefined) throwMixedMultiProviderError();
        }
        this.records.set(token, record);
    }
    hydrate(token, record) {
        if (ngDevMode && record.value === CIRCULAR) throwCyclicDependencyError(stringify(token));
        else if (record.value === NOT_YET) {
            record.value = CIRCULAR;
            record.value = record.factory();
        }
        if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) this._ngOnDestroyHooks.add(record.value);
        return record.value;
    }
    injectableDefInScope(def) {
        if (!def.providedIn) return false;
        const providedIn = resolveForwardRef(def.providedIn);
        if (typeof providedIn === 'string') return providedIn === 'any' || this.scopes.has(providedIn);
        else return this.injectorDefTypes.has(providedIn);
    }
    removeOnDestroy(callback) {
        const destroyCBIdx = this._onDestroyHooks.indexOf(callback);
        if (destroyCBIdx !== -1) this._onDestroyHooks.splice(destroyCBIdx, 1);
    }
    constructor(providers, parent, source, scopes){
        super();
        this.parent = parent;
        this.source = source;
        this.scopes = scopes;
        this.records = new Map();
        this._ngOnDestroyHooks = new Set();
        this._onDestroyHooks = [];
        this._destroyed = false;
        forEachSingleProvider(providers, (provider)=>this.processProvider(provider));
        this.records.set(INJECTOR, makeRecord(undefined, this));
        if (scopes.has('environment')) this.records.set(EnvironmentInjector, makeRecord(undefined, this));
        const record = this.records.get(INJECTOR_SCOPE);
        if (record != null && typeof record.value === 'string') this.scopes.add(record.value);
        this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES.multi, EMPTY_ARRAY, InjectFlags.Self));
    }
}
function injectableDefOrInjectorDefFactory(token) {
    const injectableDef = getInjectableDef(token);
    const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
    if (factory !== null) return factory;
    if (token instanceof InjectionToken) throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);
    if (token instanceof Function) return getUndecoratedInjectableFactory(token);
    throw new RuntimeError(204, ngDevMode && 'unreachable');
}
function getUndecoratedInjectableFactory(token) {
    const paramLength = token.length;
    if (paramLength > 0) {
        const args = newArray(paramLength, '?');
        throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${args.join(', ')}).`);
    }
    const inheritedInjectableDef = getInheritedInjectableDef(token);
    if (inheritedInjectableDef !== null) return ()=>inheritedInjectableDef.factory(token);
    else return ()=>new token();
}
function providerToRecord(provider) {
    if (isValueProvider(provider)) return makeRecord(undefined, provider.useValue);
    else {
        const factory = providerToFactory(provider);
        return makeRecord(factory, NOT_YET);
    }
}
function providerToFactory(provider, ngModuleType, providers) {
    let factory = undefined;
    if (ngDevMode && isEnvironmentProviders(provider)) throwInvalidProviderError(undefined, providers, provider);
    if (isTypeProvider(provider)) {
        const unwrappedProvider = resolveForwardRef(provider);
        return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
    } else {
        if (isValueProvider(provider)) factory = ()=>resolveForwardRef(provider.useValue);
        else if (isFactoryProvider(provider)) factory = ()=>provider.useFactory(...injectArgs(provider.deps || []));
        else if (isExistingProvider(provider)) factory = ()=>ɵɵinject(resolveForwardRef(provider.useExisting));
        else {
            const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
            if (ngDevMode && !classRef) throwInvalidProviderError(ngModuleType, providers, provider);
            if (hasDeps(provider)) factory = ()=>new classRef(...injectArgs(provider.deps));
            else return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
        }
    }
    return factory;
}
function makeRecord(factory, value, multi = false) {
    return {
        factory: factory,
        value: value,
        multi: multi ? [] : undefined
    };
}
function hasDeps(value) {
    return !!value.deps;
}
function hasOnDestroy(value) {
    return value !== null && typeof value === 'object' && typeof value.ngOnDestroy === 'function';
}
function couldBeInjectableType(value) {
    return typeof value === 'function' || typeof value === 'object' && value instanceof InjectionToken;
}
function forEachSingleProvider(providers, fn) {
    for (const provider of providers){
        if (Array.isArray(provider)) forEachSingleProvider(provider, fn);
        else if (provider && isEnvironmentProviders(provider)) forEachSingleProvider(provider.ɵproviders, fn);
        else fn(provider);
    }
}
const APP_ID = new InjectionToken('AppId', {
    providedIn: 'root',
    factory: ()=>DEFAULT_APP_ID
});
const DEFAULT_APP_ID = 'ng';
const PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer');
const PLATFORM_ID = new InjectionToken('Platform ID', {
    providedIn: 'platform',
    factory: ()=>'unknown'
});
new InjectionToken('Application Packages Root URL');
new InjectionToken('AnimationModuleType');
const CSP_NONCE = new InjectionToken('CSP nonce', {
    providedIn: 'root',
    factory: ()=>{
        var _getDocument_body_querySelector, _getDocument_body;
        return ((_getDocument_body_querySelector = (_getDocument_body = getDocument().body) === null || _getDocument_body === void 0 ? void 0 : _getDocument_body.querySelector('[ngCspNonce]')) === null || _getDocument_body_querySelector === void 0 ? void 0 : _getDocument_body_querySelector.getAttribute('ngCspNonce')) || null;
    }
});
new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'ENABLED_SSR_FEATURES' : '', {
    providedIn: 'root',
    factory: ()=>new Set()
});
function unescapeTransferStateContent(text) {
    const unescapedText = {
        '&a;': '&',
        '&q;': '"',
        '&s;': '\'',
        '&l;': '<',
        '&g;': '>'
    };
    return text.replace(/&[^;]+;/g, (s)=>unescapedText[s]);
}
function makeStateKey(key) {
    return key;
}
function initTransferState() {
    const transferState = new TransferState();
    transferState.store = retrieveTransferredState(getDocument(), inject(APP_ID));
    return transferState;
}
let TransferState = (()=>{
    class TransferState {
        get(key, defaultValue) {
            return this.store[key] !== undefined ? this.store[key] : defaultValue;
        }
        set(key, value) {
            this.store[key] = value;
        }
        remove(key) {
            delete this.store[key];
        }
        hasKey(key) {
            return this.store.hasOwnProperty(key);
        }
        get isEmpty() {
            return Object.keys(this.store).length === 0;
        }
        onSerialize(key, callback) {
            this.onSerializeCallbacks[key] = callback;
        }
        toJson() {
            for(const key in this.onSerializeCallbacks){
                if (this.onSerializeCallbacks.hasOwnProperty(key)) try {
                    this.store[key] = this.onSerializeCallbacks[key]();
                } catch (e) {
                    console.warn('Exception in onSerialize callback: ', e);
                }
            }
            return JSON.stringify(this.store);
        }
        constructor(){
            this.store = {};
            this.onSerializeCallbacks = {};
        }
    }
    TransferState.ɵprov = ɵɵdefineInjectable({
        token: TransferState,
        providedIn: 'root',
        factory: initTransferState
    });
    return TransferState;
})();
function retrieveTransferredState(doc, appId) {
    const script = doc.getElementById(appId + '-state');
    let initialState = {};
    if (script && script.textContent) try {
        initialState = JSON.parse(unescapeTransferStateContent(script.textContent));
    } catch (e) {
        console.warn('Exception while restoring TransferState for app ' + appId, e);
    }
    return initialState;
}
const REFERENCE_NODE_HOST = 'h';
const REFERENCE_NODE_BODY = 'b';
var NodeNavigationStep = (()=>{
    NodeNavigationStep = NodeNavigationStep || {};
    NodeNavigationStep["FirstChild"] = "f";
    NodeNavigationStep["NextSibling"] = "n";
    return NodeNavigationStep;
})();
const TRANSFER_STATE_TOKEN_ID = '__ɵnghData__';
makeStateKey(TRANSFER_STATE_TOKEN_ID);
let _retrieveHydrationInfoImpl = (rNode, injector)=>null;
function retrieveHydrationInfo(rNode, injector) {
    return _retrieveHydrationInfoImpl(rNode, injector);
}
class ComponentRef$1 {
}
class ComponentFactory$1 {
}
function noComponentFactoryError(component) {
    const error = Error(`No component factory found for ${stringify(component)}.`);
    error[ERROR_COMPONENT] = component;
    return error;
}
const ERROR_COMPONENT = 'ngComponent';
class _NullComponentFactoryResolver {
    resolveComponentFactory(component) {
        throw noComponentFactoryError(component);
    }
}
let ComponentFactoryResolver$1 = (()=>{
    class ComponentFactoryResolver$1 {
    }
    ComponentFactoryResolver$1.NULL = new _NullComponentFactoryResolver();
    return ComponentFactoryResolver$1;
})();
function injectElementRef() {
    return createElementRef(getCurrentTNode(), getLView());
}
function createElementRef(tNode, lView) {
    return new ElementRef(getNativeByTNode(tNode, lView));
}
let ElementRef = (()=>{
    class ElementRef {
        constructor(nativeElement){
            this.nativeElement = nativeElement;
        }
    }
    ElementRef.__NG_ELEMENT_ID__ = injectElementRef;
    return ElementRef;
})();
function unwrapElementRef(value) {
    return value instanceof ElementRef ? value.nativeElement : value;
}
class RendererFactory2 {
}
let Renderer2 = (()=>{
    class Renderer2 {
    }
    Renderer2.__NG_ELEMENT_ID__ = ()=>injectRenderer2();
    return Renderer2;
})();
function injectRenderer2() {
    const lView = getLView();
    const tNode = getCurrentTNode();
    const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);
    return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];
}
let Sanitizer = (()=>{
    class Sanitizer {
    }
    Sanitizer.ɵprov = ɵɵdefineInjectable({
        token: Sanitizer,
        providedIn: 'root',
        factory: ()=>null
    });
    return Sanitizer;
})();
class Version {
    constructor(full){
        this.full = full;
        this.major = full.split('.')[0];
        this.minor = full.split('.')[1];
        this.patch = full.split('.').slice(2).join('.');
    }
}
const VERSION = new Version('16.0.0');
const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
function markViewDirty(lView) {
    while(lView){
        lView[FLAGS] |= 64;
        const parent = getLViewParent(lView);
        if (isRootView(lView) && !parent) return lView;
        lView = parent;
    }
    return null;
}
const ERROR_ORIGINAL_ERROR = 'ngOriginalError';
function getOriginalError(error) {
    return error[ERROR_ORIGINAL_ERROR];
}
class ErrorHandler {
    handleError(error) {
        const originalError = this._findOriginalError(error);
        this._console.error('ERROR', error);
        if (originalError) this._console.error('ORIGINAL ERROR', originalError);
    }
    _findOriginalError(error) {
        let e = error && getOriginalError(error);
        while(e && getOriginalError(e))e = getOriginalError(e);
        return e || null;
    }
    constructor(){
        this._console = console;
    }
}
new InjectionToken(typeof ngDevMode === 'undefined' || !!ngDevMode ? 'IS_HYDRATION_DOM_REUSE_ENABLED' : '');
const PRESERVE_HOST_CONTENT_DEFAULT = false;
const PRESERVE_HOST_CONTENT = new InjectionToken(typeof ngDevMode === 'undefined' || !!ngDevMode ? 'PRESERVE_HOST_CONTENT' : '', {
    providedIn: 'root',
    factory: ()=>PRESERVE_HOST_CONTENT_DEFAULT
});
function normalizeDebugBindingName(name) {
    name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));
    return `ng-reflect-${name}`;
}
const CAMEL_CASE_REGEXP = /([A-Z])/g;
function camelCaseToDashCase(input) {
    return input.replace(CAMEL_CASE_REGEXP, (...m)=>'-' + m[1].toLowerCase());
}
function normalizeDebugBindingValue(value) {
    try {
        return value != null ? value.toString().slice(0, 30) : value;
    } catch (e) {
        return '[ERROR] Exception while trying to serialize the value';
    }
}
function ɵɵresolveWindow(element) {
    return element.ownerDocument.defaultView;
}
function ɵɵresolveDocument(element) {
    return element.ownerDocument;
}
function ɵɵresolveBody(element) {
    return element.ownerDocument.body;
}
const INTERPOLATION_DELIMITER = `�`;
function maybeUnwrapFn(value) {
    if (value instanceof Function) return value();
    else return value;
}
function throwMultipleComponentError(tNode, first, second) {
    throw new RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}: ` + `${stringifyForError(first)} and ` + `${stringifyForError(second)}`);
}
function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName) {
    const field = propName ? ` for '${propName}'` : '';
    let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${oldValue}'. Current value: '${currValue}'.`;
    if (creationMode) msg += ` It seems like the view has been created after its parent and its children have been dirty checked.` + ` Has it been created in a change detection hook?`;
    throw new RuntimeError(-100, msg);
}
function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
    const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
    let oldValue = prefix, newValue = prefix;
    for(let i = 0; i < chunks.length; i++){
        const slotIdx = rootIndex + i;
        oldValue += `${lView[slotIdx]}${chunks[i]}`;
        newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
    }
    return {
        propName,
        oldValue,
        newValue
    };
}
function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
    const tData = lView[TVIEW].data;
    const metadata = tData[bindingIndex];
    if (typeof metadata === 'string') {
        if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
        return {
            propName: metadata,
            oldValue,
            newValue
        };
    }
    if (metadata === null) {
        let idx = bindingIndex - 1;
        while(typeof tData[idx] !== 'string' && tData[idx + 1] === null)idx--;
        const meta = tData[idx];
        if (typeof meta === 'string') {
            const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, 'g'));
            if (matches && matches.length - 1 > bindingIndex - idx) return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
        }
    }
    return {
        propName: undefined,
        oldValue,
        newValue
    };
}
class ReactiveLViewConsumer extends ReactiveNode {
    set lView(lView) {
        (typeof ngDevMode === 'undefined' || ngDevMode) && assertEqual(this._lView, null, 'Consumer already associated with a view.');
        this._lView = lView;
    }
    onConsumerDependencyMayHaveChanged() {
        (typeof ngDevMode === 'undefined' || ngDevMode) && assertDefined(this._lView, 'Updating a signal during template or host binding execution is not allowed.');
        markViewDirty(this._lView);
    }
    onProducerUpdateValueVersion() {}
    get hasReadASignal() {
        return this.hasProducers;
    }
    runInContext(fn, rf, ctx) {
        const prevConsumer = setActiveConsumer(this);
        this.trackingVersion++;
        try {
            fn(rf, ctx);
        } finally{
            setActiveConsumer(prevConsumer);
        }
    }
    destroy() {
        this.trackingVersion++;
    }
    constructor(){
        super(...arguments);
        this.consumerAllowSignalWrites = false;
        this._lView = null;
    }
}
let currentConsumer = null;
function getOrCreateCurrentLViewConsumer() {
    currentConsumer !== null && currentConsumer !== void 0 ? currentConsumer : currentConsumer = new ReactiveLViewConsumer();
    return currentConsumer;
}
function getReactiveLViewConsumer(lView, slot) {
    var _lView_slot;
    return (_lView_slot = lView[slot]) !== null && _lView_slot !== void 0 ? _lView_slot : getOrCreateCurrentLViewConsumer();
}
function commitLViewConsumerIfHasProducers(lView, slot) {
    const consumer = getOrCreateCurrentLViewConsumer();
    if (!consumer.hasReadASignal) return;
    lView[slot] = currentConsumer;
    consumer.lView = lView;
    currentConsumer = new ReactiveLViewConsumer();
}
const NO_CHANGE = typeof ngDevMode === 'undefined' || ngDevMode ? {
    __brand__: 'NO_CHANGE'
} : {};
function ɵɵadvance(delta) {
    ngDevMode && assertGreaterThan(delta, 0, 'Can only advance forward');
    selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());
}
function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
    ngDevMode && assertIndexInDeclRange(lView, index);
    if (!checkNoChangesMode) {
        const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;
        if (hooksInitPhaseCompleted) {
            const preOrderCheckHooks = tView.preOrderCheckHooks;
            if (preOrderCheckHooks !== null) executeCheckHooks(lView, preOrderCheckHooks, index);
        } else {
            const preOrderHooks = tView.preOrderHooks;
            if (preOrderHooks !== null) executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
        }
    }
    setSelectedIndex(index);
}
const angularCoreDiEnv = {
    'ɵɵdefineInjectable': ɵɵdefineInjectable,
    'ɵɵdefineInjector': ɵɵdefineInjector,
    'ɵɵinject': ɵɵinject,
    'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,
    'resolveForwardRef': resolveForwardRef
};
function compileInjectable(type, meta) {
    let ngInjectableDef = null;
    let ngFactoryDef = null;
    if (!type.hasOwnProperty(NG_PROV_DEF)) Object.defineProperty(type, NG_PROV_DEF, {
        get: ()=>{
            if (ngInjectableDef === null) {
                const compiler = getCompilerFacade({
                    usage: 0,
                    kind: 'injectable',
                    type
                });
                ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/ɵprov.js`, getInjectableMetadata(type, meta));
            }
            return ngInjectableDef;
        }
    });
    if (!type.hasOwnProperty(NG_FACTORY_DEF)) Object.defineProperty(type, NG_FACTORY_DEF, {
        get: ()=>{
            if (ngFactoryDef === null) {
                const compiler = getCompilerFacade({
                    usage: 0,
                    kind: 'injectable',
                    type
                });
                ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/ɵfac.js`, {
                    name: type.name,
                    type,
                    typeArgumentCount: 0,
                    deps: reflectDependencies(type),
                    target: compiler.FactoryTarget.Injectable
                });
            }
            return ngFactoryDef;
        },
        configurable: true
    });
}
const USE_VALUE = getClosureSafeProperty({
    provide: String,
    useValue: getClosureSafeProperty
});
function isUseClassProvider(meta) {
    return meta.useClass !== undefined;
}
function isUseValueProvider(meta) {
    return USE_VALUE in meta;
}
function isUseFactoryProvider(meta) {
    return meta.useFactory !== undefined;
}
function isUseExistingProvider(meta) {
    return meta.useExisting !== undefined;
}
function getInjectableMetadata(type, srcMeta) {
    const meta = srcMeta || {
        providedIn: null
    };
    const compilerMeta = {
        name: type.name,
        type: type,
        typeArgumentCount: 0,
        providedIn: meta.providedIn
    };
    if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) compilerMeta.deps = convertDependencies(meta.deps);
    if (isUseClassProvider(meta)) compilerMeta.useClass = meta.useClass;
    else if (isUseValueProvider(meta)) compilerMeta.useValue = meta.useValue;
    else if (isUseFactoryProvider(meta)) compilerMeta.useFactory = meta.useFactory;
    else if (isUseExistingProvider(meta)) compilerMeta.useExisting = meta.useExisting;
    return compilerMeta;
}
const Injectable = makeDecorator('Injectable', undefined, undefined, undefined, (type, meta)=>compileInjectable(type, meta));
function createInjector(defType, parent = null, additionalProviders = null, name) {
    const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
    injector.resolveInjectorInitializers();
    return injector;
}
function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {
    const providers = [
        additionalProviders || EMPTY_ARRAY,
        importProvidersFrom(defType)
    ];
    name = name || (typeof defType === 'object' ? undefined : stringify(defType));
    return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);
}
let Injector = (()=>{
    class Injector {
        static create(options, parent) {
            if (Array.isArray(options)) return createInjector({
                name: ''
            }, parent, options, '');
            else {
                var _options_name;
                const name = (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : '';
                return createInjector({
                    name
                }, options.parent, options.providers, name);
            }
        }
    }
    Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
    Injector.NULL = new NullInjector();
    Injector.ɵprov = ɵɵdefineInjectable({
        token: Injector,
        providedIn: 'any',
        factory: ()=>ɵɵinject(INJECTOR)
    });
    Injector.__NG_ELEMENT_ID__ = -1;
    return Injector;
})();
function ɵɵdirectiveInject(token, flags = InjectFlags.Default) {
    const lView = getLView();
    if (lView === null) {
        ngDevMode && assertInjectImplementationNotEqual(ɵɵdirectiveInject);
        return ɵɵinject(token, flags);
    }
    const tNode = getCurrentTNode();
    return getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);
}
function ɵɵinvalidFactory() {
    const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : 'invalid';
    throw new Error(msg);
}
function processHostBindingOpCodes(tView, lView) {
    const hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null) return;
    const consumer = getReactiveLViewConsumer(lView, REACTIVE_HOST_BINDING_CONSUMER);
    try {
        for(let i = 0; i < hostBindingOpCodes.length; i++){
            const opCode = hostBindingOpCodes[i];
            if (opCode < 0) setSelectedIndex(~opCode);
            else {
                const directiveIdx = opCode;
                const bindingRootIndx = hostBindingOpCodes[++i];
                const hostBindingFn = hostBindingOpCodes[++i];
                setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
                const context = lView[directiveIdx];
                consumer.runInContext(hostBindingFn, 2, context);
            }
        }
    } finally{
        if (lView[REACTIVE_HOST_BINDING_CONSUMER] === null) commitLViewConsumerIfHasProducers(lView, REACTIVE_HOST_BINDING_CONSUMER);
        setSelectedIndex(-1);
    }
}
function createLView(parentLView, tView, context, flags, host, tHostNode, environment, renderer, injector, embeddedViewInjector, hydrationInfo) {
    const lView = tView.blueprint.slice();
    lView[HOST] = host;
    lView[FLAGS] = flags | 140;
    if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 2048) lView[FLAGS] |= 2048;
    resetPreOrderHookFlags(lView);
    ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);
    lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
    lView[CONTEXT] = context;
    lView[ENVIRONMENT] = environment || parentLView && parentLView[ENVIRONMENT];
    ngDevMode && assertDefined(lView[ENVIRONMENT], 'LViewEnvironment is required');
    lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];
    ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');
    lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null;
    lView[T_HOST] = tHostNode;
    lView[ID] = getUniqueLViewId();
    lView[HYDRATION] = hydrationInfo;
    lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;
    ngDevMode && assertEqual(tView.type == 2 ? parentLView !== null : true, true, 'Embedded views must have parentLView');
    lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
    return lView;
}
function getOrCreateTNode(tView, index, type, name, attrs) {
    ngDevMode && index !== 0 && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\'t be in the LView header.');
    ngDevMode && assertPureTNodeType(type);
    let tNode = tView.data[index];
    if (tNode === null) {
        tNode = createTNodeAtIndex(tView, index, type, name, attrs);
        if (isInI18nBlock()) tNode.flags |= 32;
    } else if (tNode.type & 64) {
        tNode.type = type;
        tNode.value = name;
        tNode.attrs = attrs;
        const parent = getCurrentParentTNode();
        tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
        ngDevMode && assertTNodeForTView(tNode, tView);
        ngDevMode && assertEqual(index, tNode.index, 'Expecting same index');
    }
    setCurrentTNode(tNode, true);
    return tNode;
}
function createTNodeAtIndex(tView, index, type, name, attrs) {
    const currentTNode = getCurrentTNodePlaceholderOk();
    const isParent = isCurrentTNodeParent();
    const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
    const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);
    if (tView.firstChild === null) tView.firstChild = tNode;
    if (currentTNode !== null) {
        if (isParent) {
            if (currentTNode.child == null && tNode.parent !== null) currentTNode.child = tNode;
        } else if (currentTNode.next === null) {
            currentTNode.next = tNode;
            tNode.prev = currentTNode;
        }
    }
    return tNode;
}
function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
    if (numSlotsToAlloc === 0) return -1;
    if (ngDevMode) {
        assertFirstCreatePass(tView);
        assertSame(tView, lView[TVIEW], '`LView` must be associated with `TView`!');
        assertEqual(tView.data.length, lView.length, 'Expecting LView to be same size as TView');
        assertEqual(tView.data.length, tView.blueprint.length, 'Expecting Blueprint to be same size as TView');
        assertFirstUpdatePass(tView);
    }
    const allocIdx = lView.length;
    for(let i = 0; i < numSlotsToAlloc; i++){
        lView.push(initialValue);
        tView.blueprint.push(initialValue);
        tView.data.push(null);
    }
    return allocIdx;
}
function executeTemplate(tView, lView, templateFn, rf, context) {
    const consumer = getReactiveLViewConsumer(lView, REACTIVE_TEMPLATE_CONSUMER);
    const prevSelectedIndex = getSelectedIndex();
    const isUpdatePhase = rf & 2;
    try {
        setSelectedIndex(-1);
        if (isUpdatePhase && lView.length > HEADER_OFFSET) selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());
        const preHookType = isUpdatePhase ? 2 : 0;
        profiler(preHookType, context);
        if (isUpdatePhase) consumer.runInContext(templateFn, rf, context);
        else {
            const prevConsumer = setActiveConsumer(null);
            try {
                templateFn(rf, context);
            } finally{
                setActiveConsumer(prevConsumer);
            }
        }
    } finally{
        if (isUpdatePhase && lView[REACTIVE_TEMPLATE_CONSUMER] === null) commitLViewConsumerIfHasProducers(lView, REACTIVE_TEMPLATE_CONSUMER);
        setSelectedIndex(prevSelectedIndex);
        const postHookType = isUpdatePhase ? 3 : 1;
        profiler(postHookType, context);
    }
}
function executeContentQueries(tView, tNode, lView) {
    if (isContentQueryHost(tNode)) {
        const prevConsumer = setActiveConsumer(null);
        try {
            const start = tNode.directiveStart;
            const end = tNode.directiveEnd;
            for(let directiveIndex = start; directiveIndex < end; directiveIndex++){
                const def = tView.data[directiveIndex];
                if (def.contentQueries) def.contentQueries(1, lView[directiveIndex], directiveIndex);
            }
        } finally{
            setActiveConsumer(prevConsumer);
        }
    }
}
function createDirectivesInstances(tView, lView, tNode) {
    if (!getBindingsEnabled()) return;
    instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));
    if ((tNode.flags & 64) === 64) invokeDirectivesHostBindings(tView, lView, tNode);
}
function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
    const localNames = tNode.localNames;
    if (localNames !== null) {
        let localIndex = tNode.index + 1;
        for(let i = 0; i < localNames.length; i += 2){
            const index = localNames[i + 1];
            const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
            viewData[localIndex++] = value;
        }
    }
}
function getOrCreateComponentTView(def) {
    const tView = def.tView;
    if (tView === null || tView.incompleteFirstPass) {
        const declTNode = null;
        return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);
    }
    return tView;
}
function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {
    ngDevMode && ngDevMode.tView++;
    const bindingStartIndex = HEADER_OFFSET + decls;
    const initialViewLength = bindingStartIndex + vars;
    const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
    const consts = typeof constsOrFactory === 'function' ? constsOrFactory() : constsOrFactory;
    const tView = blueprint[TVIEW] = {
        type: type,
        blueprint: blueprint,
        template: templateFn,
        queries: null,
        viewQuery: viewQuery,
        declTNode: declTNode,
        data: blueprint.slice().fill(null, bindingStartIndex),
        bindingStartIndex: bindingStartIndex,
        expandoStartIndex: initialViewLength,
        hostBindingOpCodes: null,
        firstCreatePass: true,
        firstUpdatePass: true,
        staticViewQueries: false,
        staticContentQueries: false,
        preOrderHooks: null,
        preOrderCheckHooks: null,
        contentHooks: null,
        contentCheckHooks: null,
        viewHooks: null,
        viewCheckHooks: null,
        destroyHooks: null,
        cleanup: null,
        contentQueries: null,
        components: null,
        directiveRegistry: typeof directives === 'function' ? directives() : directives,
        pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,
        firstChild: null,
        schemas: schemas,
        consts: consts,
        incompleteFirstPass: false,
        ssrId
    };
    if (ngDevMode) Object.seal(tView);
    return tView;
}
function createViewBlueprint(bindingStartIndex, initialViewLength) {
    const blueprint = [];
    for(let i = 0; i < initialViewLength; i++)blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
    return blueprint;
}
function locateHostElement(renderer, elementOrSelector, encapsulation, injector) {
    const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);
    const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation$1.ShadowDom;
    const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);
    applyRootElementTransform(rootElement);
    return rootElement;
}
function applyRootElementTransform(rootElement) {
    _applyRootElementTransformImpl(rootElement);
}
let _applyRootElementTransformImpl = (rootElement)=>null;
function storeCleanupWithContext(tView, lView, context, cleanupFn) {
    const lCleanup = getOrCreateLViewCleanup(lView);
    ngDevMode && assertDefined(context, 'Cleanup context is mandatory when registering framework-level destroy hooks');
    lCleanup.push(context);
    if (tView.firstCreatePass) getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
    else if (ngDevMode) Object.freeze(getOrCreateTViewCleanup(tView));
}
function createTNode(tView, tParent, type, index, value, attrs) {
    ngDevMode && index !== 0 && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\'t be in the LView header.');
    ngDevMode && assertNotSame(attrs, undefined, '\'undefined\' is not valid value for \'attrs\'');
    ngDevMode && ngDevMode.tNode++;
    ngDevMode && tParent && assertTNodeForTView(tParent, tView);
    let injectorIndex = tParent ? tParent.injectorIndex : -1;
    const tNode = {
        type,
        index,
        insertBeforeIndex: null,
        injectorIndex,
        directiveStart: -1,
        directiveEnd: -1,
        directiveStylingLast: -1,
        componentOffset: -1,
        propertyBindings: null,
        flags: 0,
        providerIndexes: 0,
        value: value,
        attrs: attrs,
        mergedAttrs: null,
        localNames: null,
        initialInputs: undefined,
        inputs: null,
        outputs: null,
        tView: null,
        next: null,
        prev: null,
        projectionNext: null,
        child: null,
        parent: tParent,
        projection: null,
        styles: null,
        stylesWithoutHost: null,
        residualStyles: undefined,
        classes: null,
        classesWithoutHost: null,
        residualClasses: undefined,
        classBindings: 0,
        styleBindings: 0
    };
    if (ngDevMode) Object.seal(tNode);
    return tNode;
}
function generatePropertyAliases(aliasMap, directiveIndex, propertyAliases, hostDirectiveAliasMap) {
    for(let publicName in aliasMap)if (aliasMap.hasOwnProperty(publicName)) {
        propertyAliases = propertyAliases === null ? {} : propertyAliases;
        const internalName = aliasMap[publicName];
        if (hostDirectiveAliasMap === null) addPropertyAlias(propertyAliases, directiveIndex, publicName, internalName);
        else if (hostDirectiveAliasMap.hasOwnProperty(publicName)) addPropertyAlias(propertyAliases, directiveIndex, hostDirectiveAliasMap[publicName], internalName);
    }
    return propertyAliases;
}
function addPropertyAlias(propertyAliases, directiveIndex, publicName, internalName) {
    if (propertyAliases.hasOwnProperty(publicName)) propertyAliases[publicName].push(directiveIndex, internalName);
    else propertyAliases[publicName] = [
        directiveIndex,
        internalName
    ];
}
function initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefinitionMap) {
    ngDevMode && assertFirstCreatePass(tView);
    const start = tNode.directiveStart;
    const end = tNode.directiveEnd;
    const tViewData = tView.data;
    const tNodeAttrs = tNode.attrs;
    const inputsFromAttrs = [];
    let inputsStore = null;
    let outputsStore = null;
    for(let directiveIndex = start; directiveIndex < end; directiveIndex++){
        const directiveDef = tViewData[directiveIndex];
        const aliasData = hostDirectiveDefinitionMap ? hostDirectiveDefinitionMap.get(directiveDef) : null;
        const aliasedInputs = aliasData ? aliasData.inputs : null;
        const aliasedOutputs = aliasData ? aliasData.outputs : null;
        inputsStore = generatePropertyAliases(directiveDef.inputs, directiveIndex, inputsStore, aliasedInputs);
        outputsStore = generatePropertyAliases(directiveDef.outputs, directiveIndex, outputsStore, aliasedOutputs);
        const initialInputs = inputsStore !== null && tNodeAttrs !== null && !isInlineTemplate(tNode) ? generateInitialInputs(inputsStore, directiveIndex, tNodeAttrs) : null;
        inputsFromAttrs.push(initialInputs);
    }
    if (inputsStore !== null) {
        if (inputsStore.hasOwnProperty('class')) tNode.flags |= 8;
        if (inputsStore.hasOwnProperty('style')) tNode.flags |= 16;
    }
    tNode.initialInputs = inputsFromAttrs;
    tNode.inputs = inputsStore;
    tNode.outputs = outputsStore;
}
function mapPropName(name) {
    if (name === 'class') return 'className';
    if (name === 'for') return 'htmlFor';
    if (name === 'formaction') return 'formAction';
    if (name === 'innerHtml') return 'innerHTML';
    if (name === 'readonly') return 'readOnly';
    if (name === 'tabindex') return 'tabIndex';
    return name;
}
function elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {
    ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');
    const element = getNativeByTNode(tNode, lView);
    let inputData = tNode.inputs;
    let dataValue;
    if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {
        setInputsForProperty(tView, lView, dataValue, propName, value);
        if (isComponentHost(tNode)) markDirtyIfOnPush(lView, tNode.index);
        if (ngDevMode) setNgReflectProperties(lView, element, tNode.type, dataValue, value);
    } else if (tNode.type & 3) {
        propName = mapPropName(propName);
        if (ngDevMode) {
            validateAgainstEventProperties(propName);
            if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
            ngDevMode.rendererSetProperty++;
        }
        value = sanitizer != null ? sanitizer(value, tNode.value || '', propName) : value;
        renderer.setProperty(element, propName, value);
    } else if (tNode.type & 12) {
        if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
    }
}
function markDirtyIfOnPush(lView, viewIndex) {
    ngDevMode && assertLView(lView);
    const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
    if (!(childComponentLView[FLAGS] & 16)) childComponentLView[FLAGS] |= 64;
}
function setNgReflectProperty(lView, element, type, attrName, value) {
    const renderer = lView[RENDERER];
    attrName = normalizeDebugBindingName(attrName);
    const debugValue = normalizeDebugBindingValue(value);
    if (type & 3) {
        if (value == null) renderer.removeAttribute(element, attrName);
        else renderer.setAttribute(element, attrName, debugValue);
    } else {
        const textContent = escapeCommentText(`bindings=${JSON.stringify({
            [attrName]: debugValue
        }, null, 2)}`);
        renderer.setValue(element, textContent);
    }
}
function setNgReflectProperties(lView, element, type, dataValue, value) {
    if (type & 7) for(let i = 0; i < dataValue.length; i += 2)setNgReflectProperty(lView, element, type, dataValue[i + 1], value);
}
function resolveDirectives(tView, lView, tNode, localRefs) {
    ngDevMode && assertFirstCreatePass(tView);
    if (getBindingsEnabled()) {
        const exportsMap = localRefs === null ? null : {
            '': -1
        };
        const matchResult = findDirectiveDefMatches(tView, tNode);
        let directiveDefs;
        let hostDirectiveDefs;
        if (matchResult === null) directiveDefs = hostDirectiveDefs = null;
        else [directiveDefs, hostDirectiveDefs] = matchResult;
        if (directiveDefs !== null) initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs);
        if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);
    }
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
}
function initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs) {
    ngDevMode && assertFirstCreatePass(tView);
    for(let i = 0; i < directives.length; i++)diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, directives[i].type);
    initTNodeFlags(tNode, tView.data.length, directives.length);
    for(let i = 0; i < directives.length; i++){
        const def = directives[i];
        if (def.providersResolver) def.providersResolver(def);
    }
    let preOrderHooksFound = false;
    let preOrderCheckHooksFound = false;
    let directiveIdx = allocExpando(tView, lView, directives.length, null);
    ngDevMode && assertSame(directiveIdx, tNode.directiveStart, 'TNode.directiveStart should point to just allocated space');
    for(let i = 0; i < directives.length; i++){
        const def = directives[i];
        tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
        configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
        saveNameToExportMap(directiveIdx, def, exportsMap);
        if (def.contentQueries !== null) tNode.flags |= 4;
        if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0) tNode.flags |= 64;
        const lifeCycleHooks = def.type.prototype;
        if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
            var _tView;
            var _preOrderHooks;
            ((_preOrderHooks = (_tView = tView).preOrderHooks) !== null && _preOrderHooks !== void 0 ? _preOrderHooks : _tView.preOrderHooks = []).push(tNode.index);
            preOrderHooksFound = true;
        }
        if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
            var _tView1;
            var _preOrderCheckHooks;
            ((_preOrderCheckHooks = (_tView1 = tView).preOrderCheckHooks) !== null && _preOrderCheckHooks !== void 0 ? _preOrderCheckHooks : _tView1.preOrderCheckHooks = []).push(tNode.index);
            preOrderCheckHooksFound = true;
        }
        directiveIdx++;
    }
    initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);
}
function registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {
    ngDevMode && assertFirstCreatePass(tView);
    const hostBindings = def.hostBindings;
    if (hostBindings) {
        let hostBindingOpCodes = tView.hostBindingOpCodes;
        if (hostBindingOpCodes === null) hostBindingOpCodes = tView.hostBindingOpCodes = [];
        const elementIndx = ~tNode.index;
        if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) hostBindingOpCodes.push(elementIndx);
        hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
    }
}
function lastSelectedElementIdx(hostBindingOpCodes) {
    let i = hostBindingOpCodes.length;
    while(i > 0){
        const value = hostBindingOpCodes[--i];
        if (typeof value === 'number' && value < 0) return value;
    }
    return 0;
}
function instantiateAllDirectives(tView, lView, tNode, native) {
    const start = tNode.directiveStart;
    const end = tNode.directiveEnd;
    if (isComponentHost(tNode)) {
        ngDevMode && assertTNodeType(tNode, 3);
        addComponentLogic(lView, tNode, tView.data[start + tNode.componentOffset]);
    }
    if (!tView.firstCreatePass) getOrCreateNodeInjectorForNode(tNode, lView);
    attachPatchData(native, lView);
    const initialInputs = tNode.initialInputs;
    for(let i = start; i < end; i++){
        const def = tView.data[i];
        const directive = getNodeInjectable(lView, tView, i, tNode);
        attachPatchData(directive, lView);
        if (initialInputs !== null) setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);
        if (isComponentDef(def)) {
            const componentView = getComponentLViewByIndex(tNode.index, lView);
            componentView[CONTEXT] = getNodeInjectable(lView, tView, i, tNode);
        }
    }
}
function invokeDirectivesHostBindings(tView, lView, tNode) {
    const start = tNode.directiveStart;
    const end = tNode.directiveEnd;
    const elementIndex = tNode.index;
    const currentDirectiveIndex = getCurrentDirectiveIndex();
    try {
        setSelectedIndex(elementIndex);
        for(let dirIndex = start; dirIndex < end; dirIndex++){
            const def = tView.data[dirIndex];
            const directive = lView[dirIndex];
            setCurrentDirectiveIndex(dirIndex);
            if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) invokeHostBindingsInCreationMode(def, directive);
        }
    } finally{
        setSelectedIndex(-1);
        setCurrentDirectiveIndex(currentDirectiveIndex);
    }
}
function invokeHostBindingsInCreationMode(def, directive) {
    if (def.hostBindings !== null) def.hostBindings(1, directive);
}
function findDirectiveDefMatches(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && assertTNodeType(tNode, 15);
    const registry = tView.directiveRegistry;
    let matches = null;
    let hostDirectiveDefs = null;
    if (registry) for(let i = 0; i < registry.length; i++){
        const def = registry[i];
        if (isNodeMatchingSelectorList(tNode, def.selectors, false)) {
            matches || (matches = []);
            if (isComponentDef(def)) {
                if (ngDevMode) {
                    assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. ` + `Please use a different tag to activate the ${stringify(def.type)} component.`);
                    if (isComponentHost(tNode)) throwMultipleComponentError(tNode, matches.find(isComponentDef).type, def.type);
                }
                if (def.findHostDirectiveDefs !== null) {
                    const hostDirectiveMatches = [];
                    hostDirectiveDefs = hostDirectiveDefs || new Map();
                    def.findHostDirectiveDefs(def, hostDirectiveMatches, hostDirectiveDefs);
                    matches.unshift(...hostDirectiveMatches, def);
                    const componentOffset = hostDirectiveMatches.length;
                    markAsComponentHost(tView, tNode, componentOffset);
                } else {
                    matches.unshift(def);
                    markAsComponentHost(tView, tNode, 0);
                }
            } else {
                var _def_findHostDirectiveDefs;
                hostDirectiveDefs = hostDirectiveDefs || new Map();
                (_def_findHostDirectiveDefs = def.findHostDirectiveDefs) === null || _def_findHostDirectiveDefs === void 0 || _def_findHostDirectiveDefs.call(def, def, matches, hostDirectiveDefs);
                matches.push(def);
            }
        }
    }
    return matches === null ? null : [
        matches,
        hostDirectiveDefs
    ];
}
function markAsComponentHost(tView, hostTNode, componentOffset) {
    var _tView;
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && assertGreaterThan(componentOffset, -1, 'componentOffset must be great than -1');
    hostTNode.componentOffset = componentOffset;
    var _components;
    ((_components = (_tView = tView).components) !== null && _components !== void 0 ? _components : _tView.components = []).push(hostTNode.index);
}
function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
    if (localRefs) {
        const localNames = tNode.localNames = [];
        for(let i = 0; i < localRefs.length; i += 2){
            const index = exportsMap[localRefs[i + 1]];
            if (index == null) throw new RuntimeError(-301, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);
            localNames.push(localRefs[i], index);
        }
    }
}
function saveNameToExportMap(directiveIdx, def, exportsMap) {
    if (exportsMap) {
        if (def.exportAs) for(let i = 0; i < def.exportAs.length; i++)exportsMap[def.exportAs[i]] = directiveIdx;
        if (isComponentDef(def)) exportsMap[''] = directiveIdx;
    }
}
function initTNodeFlags(tNode, index, numberOfDirectives) {
    ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, 'Reached the max number of directives');
    tNode.flags |= 1;
    tNode.directiveStart = index;
    tNode.directiveEnd = index + numberOfDirectives;
    tNode.providerIndexes = index;
}
function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
    ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, 'Must be in Expando section');
    tView.data[directiveIndex] = def;
    const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
    const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), ɵɵdirectiveInject);
    tView.blueprint[directiveIndex] = nodeInjectorFactory;
    lView[directiveIndex] = nodeInjectorFactory;
    registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
}
function addComponentLogic(lView, hostTNode, def) {
    const native = getNativeByTNode(hostTNode, lView);
    const tView = getOrCreateComponentTView(def);
    const rendererFactory = lView[ENVIRONMENT].rendererFactory;
    const componentView = addToViewTree(lView, createLView(lView, tView, null, def.onPush ? 64 : 16, native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));
    lView[hostTNode.index] = componentView;
}
function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
    if (ngDevMode) {
        assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');
        validateAgainstEventAttributes(name);
        assertTNodeType(tNode, 2, `Attempted to set attribute \`${name}\` on a container node. ` + `Host bindings are not valid on ng-container or ng-template.`);
    }
    const element = getNativeByTNode(tNode, lView);
    setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);
}
function setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {
    if (value == null) {
        ngDevMode && ngDevMode.rendererRemoveAttribute++;
        renderer.removeAttribute(element, name, namespace);
    } else {
        ngDevMode && ngDevMode.rendererSetAttribute++;
        const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || '', name);
        renderer.setAttribute(element, name, strValue, namespace);
    }
}
function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
    const initialInputs = initialInputData[directiveIndex];
    if (initialInputs !== null) for(let i = 0; i < initialInputs.length;){
        const publicName = initialInputs[i++];
        const privateName = initialInputs[i++];
        const value = initialInputs[i++];
        writeToDirectiveInput(def, instance, publicName, privateName, value);
        if (ngDevMode) {
            const nativeElement = getNativeByTNode(tNode, lView);
            setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);
        }
    }
}
function writeToDirectiveInput(def, instance, publicName, privateName, value) {
    const prevConsumer = setActiveConsumer(null);
    try {
        if (def.setInput !== null) def.setInput(instance, value, publicName, privateName);
        else instance[privateName] = value;
    } finally{
        setActiveConsumer(prevConsumer);
    }
}
function generateInitialInputs(inputs, directiveIndex, attrs) {
    let inputsToStore = null;
    let i = 0;
    while(i < attrs.length){
        const attrName = attrs[i];
        if (attrName === 0) {
            i += 4;
            continue;
        } else if (attrName === 5) {
            i += 2;
            continue;
        }
        if (typeof attrName === 'number') break;
        if (inputs.hasOwnProperty(attrName)) {
            if (inputsToStore === null) inputsToStore = [];
            const inputConfig = inputs[attrName];
            for(let j = 0; j < inputConfig.length; j += 2)if (inputConfig[j] === directiveIndex) {
                inputsToStore.push(attrName, inputConfig[j + 1], attrs[i + 1]);
                break;
            }
        }
        i += 2;
    }
    return inputsToStore;
}
function createLContainer(hostNative, currentView, native, tNode) {
    ngDevMode && assertLView(currentView);
    const lContainer = [
        hostNative,
        true,
        false,
        currentView,
        null,
        0,
        tNode,
        native,
        null,
        null,
        null
    ];
    ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, 'Should allocate correct number of slots for LContainer header.');
    return lContainer;
}
function refreshContentQueries(tView, lView) {
    const contentQueries = tView.contentQueries;
    if (contentQueries !== null) for(let i = 0; i < contentQueries.length; i += 2){
        const queryStartIdx = contentQueries[i];
        const directiveDefIdx = contentQueries[i + 1];
        if (directiveDefIdx !== -1) {
            const directiveDef = tView.data[directiveDefIdx];
            ngDevMode && assertDefined(directiveDef, 'DirectiveDef not found.');
            ngDevMode && assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');
            setCurrentQueryIndex(queryStartIdx);
            directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
        }
    }
}
function addToViewTree(lView, lViewOrLContainer) {
    if (lView[CHILD_HEAD]) lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
    else lView[CHILD_HEAD] = lViewOrLContainer;
    lView[CHILD_TAIL] = lViewOrLContainer;
    return lViewOrLContainer;
}
function executeViewQueryFn(flags, viewQueryFn, component) {
    ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');
    setCurrentQueryIndex(0);
    const prevConsumer = setActiveConsumer(null);
    try {
        viewQueryFn(flags, component);
    } finally{
        setActiveConsumer(prevConsumer);
    }
}
function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
    if (tData[bindingIndex] === null) {
        if (tNode.inputs == null || !tNode.inputs[propertyName]) {
            const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
            propBindingIdxs.push(bindingIndex);
            let bindingMetadata = propertyName;
            if (interpolationParts.length > 0) bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
            tData[bindingIndex] = bindingMetadata;
        }
    }
}
function getOrCreateLViewCleanup(view) {
    return view[CLEANUP] || (view[CLEANUP] = []);
}
function getOrCreateTViewCleanup(tView) {
    return tView.cleanup || (tView.cleanup = []);
}
function loadComponentRenderer(currentDef, tNode, lView) {
    if (currentDef === null || isComponentDef(currentDef)) lView = unwrapLView(lView[tNode.index]);
    return lView[RENDERER];
}
function handleError(lView, error) {
    const injector = lView[INJECTOR$1];
    const errorHandler = injector ? injector.get(ErrorHandler, null) : null;
    errorHandler && errorHandler.handleError(error);
}
function setInputsForProperty(tView, lView, inputs, publicName, value) {
    for(let i = 0; i < inputs.length;){
        const index = inputs[i++];
        const privateName = inputs[i++];
        const instance = lView[index];
        ngDevMode && assertIndexInRange(lView, index);
        const def = tView.data[index];
        writeToDirectiveInput(def, instance, publicName, privateName, value);
    }
}
function textBindingInternal(lView, index, value) {
    ngDevMode && assertString(value, 'Value should be a string');
    ngDevMode && assertNotSame(value, NO_CHANGE, 'value should not be NO_CHANGE');
    ngDevMode && assertIndexInRange(lView, index);
    const element = getNativeByIndex(index, lView);
    ngDevMode && assertDefined(element, 'native element should exist');
    updateTextNode(lView[RENDERER], element, value);
}
function renderComponent(hostLView, componentHostIdx) {
    ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');
    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
    const componentTView = componentView[TVIEW];
    syncViewWithBlueprint(componentTView, componentView);
    const hostRNode = componentView[HOST];
    if (hostRNode !== null && componentView[HYDRATION] === null) componentView[HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[INJECTOR$1]);
    renderView(componentTView, componentView, componentView[CONTEXT]);
}
function syncViewWithBlueprint(tView, lView) {
    for(let i = lView.length; i < tView.blueprint.length; i++)lView.push(tView.blueprint[i]);
}
function renderView(tView, lView, context) {
    ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');
    enterView(lView);
    try {
        const viewQuery = tView.viewQuery;
        if (viewQuery !== null) executeViewQueryFn(1, viewQuery, context);
        const templateFn = tView.template;
        if (templateFn !== null) executeTemplate(tView, lView, templateFn, 1, context);
        if (tView.firstCreatePass) tView.firstCreatePass = false;
        if (tView.staticContentQueries) refreshContentQueries(tView, lView);
        if (tView.staticViewQueries) executeViewQueryFn(2, tView.viewQuery, context);
        const components = tView.components;
        if (components !== null) renderChildComponents(lView, components);
    } catch (error) {
        if (tView.firstCreatePass) {
            tView.incompleteFirstPass = true;
            tView.firstCreatePass = false;
        }
        throw error;
    } finally{
        lView[FLAGS] &= -5;
        leaveView();
    }
}
function renderChildComponents(hostLView, components) {
    for(let i = 0; i < components.length; i++)renderComponent(hostLView, components[i]);
}
let DestroyRef = (()=>{
    class DestroyRef {
    }
    DestroyRef.__NG_ELEMENT_ID__ = injectDestroyRef;
    DestroyRef.__NG_ENV_ID__ = (injector)=>injector;
    return DestroyRef;
})();
class NodeInjectorDestroyRef extends DestroyRef {
    onDestroy(callback) {
        storeLViewOnDestroy(this._lView, callback);
        return ()=>removeLViewOnDestroy(this._lView, callback);
    }
    constructor(_lView){
        super();
        this._lView = _lView;
    }
}
function injectDestroyRef() {
    return new NodeInjectorDestroyRef(getLView());
}
let EffectManager = (()=>{
    class EffectManager {
        create(effectFn, destroyRef, allowSignalWrites) {
            const zone = typeof Zone === 'undefined' ? null : Zone.current;
            const watch = new Watch(effectFn, (watch)=>{
                if (!this.all.has(watch)) return;
                this.queue.set(watch, zone);
            }, allowSignalWrites);
            this.all.add(watch);
            watch.notify();
            let unregisterOnDestroy;
            const destroy = ()=>{
                watch.cleanup();
                unregisterOnDestroy === null || unregisterOnDestroy === void 0 || unregisterOnDestroy();
                this.all.delete(watch);
                this.queue.delete(watch);
            };
            unregisterOnDestroy = destroyRef === null || destroyRef === void 0 ? void 0 : destroyRef.onDestroy(destroy);
            return {
                destroy
            };
        }
        flush() {
            if (this.queue.size === 0) return;
            for (const [watch, zone] of this.queue){
                this.queue.delete(watch);
                if (zone) zone.run(()=>watch.run());
                else watch.run();
            }
        }
        get isQueueEmpty() {
            return this.queue.size === 0;
        }
        constructor(){
            this.all = new Set();
            this.queue = new Map();
        }
    }
    EffectManager.ɵprov = ɵɵdefineInjectable({
        token: EffectManager,
        providedIn: 'root',
        factory: ()=>new EffectManager()
    });
    return EffectManager;
})();
function computeStaticStyling(tNode, attrs, writeToHost) {
    ngDevMode && assertFirstCreatePass(getTView(), 'Expecting to be called in first template pass only');
    let styles = writeToHost ? tNode.styles : null;
    let classes = writeToHost ? tNode.classes : null;
    let mode = 0;
    if (attrs !== null) for(let i = 0; i < attrs.length; i++){
        const value = attrs[i];
        if (typeof value === 'number') mode = value;
        else if (mode == 1) classes = concatStringsWithSpace(classes, value);
        else if (mode == 2) {
            const style = value;
            const styleValue = attrs[++i];
            styles = concatStringsWithSpace(styles, style + ': ' + styleValue + ';');
        }
    }
    writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
    writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
}
function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
    while(tNode !== null){
        ngDevMode && assertTNodeType(tNode, 63);
        const lNode = lView[tNode.index];
        if (lNode !== null) result.push(unwrapRNode(lNode));
        if (isLContainer(lNode)) {
            for(let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++){
                const lViewInAContainer = lNode[i];
                const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
                if (lViewFirstChildTNode !== null) collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
            }
            if (lNode[NATIVE] !== lNode[HOST]) result.push(lNode[NATIVE]);
        }
        const tNodeType = tNode.type;
        if (tNodeType & 8) collectNativeNodes(tView, lView, tNode.child, result);
        else if (tNodeType & 32) {
            const nextRNode = icuContainerIterate(tNode, lView);
            let rNode;
            while(rNode = nextRNode())result.push(rNode);
        } else if (tNodeType & 16) {
            const nodesInSlot = getProjectionNodes(lView, tNode);
            if (Array.isArray(nodesInSlot)) result.push(...nodesInSlot);
            else {
                const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
                ngDevMode && assertParentView(parentView);
                collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
            }
        }
        tNode = isProjection ? tNode.projectionNext : tNode.next;
    }
    return result;
}
function detectChangesInternal(tView, lView, context, notifyErrorHandler = true) {
    const rendererFactory = lView[ENVIRONMENT].rendererFactory;
    const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();
    if (!checkNoChangesMode && rendererFactory.begin) rendererFactory.begin();
    try {
        refreshView(tView, lView, tView.template, context);
    } catch (error) {
        if (notifyErrorHandler) handleError(lView, error);
        throw error;
    } finally{
        var _lView_ENVIRONMENT_effectManager;
        if (!checkNoChangesMode && rendererFactory.end) rendererFactory.end();
        !checkNoChangesMode && ((_lView_ENVIRONMENT_effectManager = lView[ENVIRONMENT].effectManager) === null || _lView_ENVIRONMENT_effectManager === void 0 || _lView_ENVIRONMENT_effectManager.flush());
    }
}
function checkNoChangesInternal(tView, lView, context, notifyErrorHandler = true) {
    setIsInCheckNoChangesMode(true);
    try {
        detectChangesInternal(tView, lView, context, notifyErrorHandler);
    } finally{
        setIsInCheckNoChangesMode(false);
    }
}
function detectChanges(component) {
    const view = getComponentViewByInstance(component);
    detectChangesInternal(view[TVIEW], view, component);
}
function refreshView(tView, lView, templateFn, context) {
    var _lView_ENVIRONMENT_effectManager;
    ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');
    const flags = lView[FLAGS];
    if ((flags & 256) === 256) return;
    const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
    !isInCheckNoChangesPass && ((_lView_ENVIRONMENT_effectManager = lView[ENVIRONMENT].effectManager) === null || _lView_ENVIRONMENT_effectManager === void 0 || _lView_ENVIRONMENT_effectManager.flush());
    enterView(lView);
    try {
        resetPreOrderHookFlags(lView);
        setBindingIndex(tView.bindingStartIndex);
        if (templateFn !== null) executeTemplate(tView, lView, templateFn, 2, context);
        const hooksInitPhaseCompleted = (flags & 3) === 3;
        if (!isInCheckNoChangesPass) {
            if (hooksInitPhaseCompleted) {
                const preOrderCheckHooks = tView.preOrderCheckHooks;
                if (preOrderCheckHooks !== null) executeCheckHooks(lView, preOrderCheckHooks, null);
            } else {
                const preOrderHooks = tView.preOrderHooks;
                if (preOrderHooks !== null) executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
                incrementInitPhaseFlags(lView, 0);
            }
        }
        markTransplantedViewsForRefresh(lView);
        refreshEmbeddedViews(lView);
        if (tView.contentQueries !== null) refreshContentQueries(tView, lView);
        if (!isInCheckNoChangesPass) {
            if (hooksInitPhaseCompleted) {
                const contentCheckHooks = tView.contentCheckHooks;
                if (contentCheckHooks !== null) executeCheckHooks(lView, contentCheckHooks);
            } else {
                const contentHooks = tView.contentHooks;
                if (contentHooks !== null) executeInitAndCheckHooks(lView, contentHooks, 1);
                incrementInitPhaseFlags(lView, 1);
            }
        }
        processHostBindingOpCodes(tView, lView);
        const components = tView.components;
        if (components !== null) refreshChildComponents(lView, components);
        const viewQuery = tView.viewQuery;
        if (viewQuery !== null) executeViewQueryFn(2, viewQuery, context);
        if (!isInCheckNoChangesPass) {
            if (hooksInitPhaseCompleted) {
                const viewCheckHooks = tView.viewCheckHooks;
                if (viewCheckHooks !== null) executeCheckHooks(lView, viewCheckHooks);
            } else {
                const viewHooks = tView.viewHooks;
                if (viewHooks !== null) executeInitAndCheckHooks(lView, viewHooks, 2);
                incrementInitPhaseFlags(lView, 2);
            }
        }
        if (tView.firstUpdatePass === true) tView.firstUpdatePass = false;
        if (!isInCheckNoChangesPass) lView[FLAGS] &= -73;
        clearViewRefreshFlag(lView);
    } finally{
        leaveView();
    }
}
function refreshEmbeddedViews(lView) {
    for(let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer))for(let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++){
        const embeddedLView = lContainer[i];
        const embeddedTView = embeddedLView[TVIEW];
        ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');
        if (viewAttachedToChangeDetector(embeddedLView)) refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
    }
}
function markTransplantedViewsForRefresh(lView) {
    for(let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)){
        if (!lContainer[HAS_TRANSPLANTED_VIEWS]) continue;
        const movedViews = lContainer[MOVED_VIEWS];
        ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');
        for(let i = 0; i < movedViews.length; i++){
            const movedLView = movedViews[i];
            const insertionLContainer = movedLView[PARENT];
            ngDevMode && assertLContainer(insertionLContainer);
            markViewForRefresh(movedLView);
        }
    }
}
function refreshComponent(hostLView, componentHostIdx) {
    ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');
    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
    if (viewAttachedToChangeDetector(componentView)) {
        const tView = componentView[TVIEW];
        if (componentView[FLAGS] & 80) refreshView(tView, componentView, tView.template, componentView[CONTEXT]);
        else if (componentView[DESCENDANT_VIEWS_TO_REFRESH] > 0) refreshContainsDirtyView(componentView);
    }
}
function refreshContainsDirtyView(lView) {
    for(let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer))for(let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++){
        const embeddedLView = lContainer[i];
        if (viewAttachedToChangeDetector(embeddedLView)) {
            if (embeddedLView[FLAGS] & 1024) {
                const embeddedTView = embeddedLView[TVIEW];
                ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');
                refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
            } else if (embeddedLView[DESCENDANT_VIEWS_TO_REFRESH] > 0) refreshContainsDirtyView(embeddedLView);
        }
    }
    const tView = lView[TVIEW];
    const components = tView.components;
    if (components !== null) for(let i = 0; i < components.length; i++){
        const componentView = getComponentLViewByIndex(components[i], lView);
        if (viewAttachedToChangeDetector(componentView) && componentView[DESCENDANT_VIEWS_TO_REFRESH] > 0) refreshContainsDirtyView(componentView);
    }
}
function refreshChildComponents(hostLView, components) {
    for(let i = 0; i < components.length; i++)refreshComponent(hostLView, components[i]);
}
class ViewRef$1 {
    get rootNodes() {
        const lView = this._lView;
        const tView = lView[TVIEW];
        return collectNativeNodes(tView, lView, tView.firstChild, []);
    }
    get context() {
        return this._lView[CONTEXT];
    }
    set context(value) {
        this._lView[CONTEXT] = value;
    }
    get destroyed() {
        return (this._lView[FLAGS] & 256) === 256;
    }
    destroy() {
        if (this._appRef) this._appRef.detachView(this);
        else if (this._attachedToViewContainer) {
            const parent = this._lView[PARENT];
            if (isLContainer(parent)) {
                const viewRefs = parent[VIEW_REFS];
                const index = viewRefs ? viewRefs.indexOf(this) : -1;
                if (index > -1) {
                    ngDevMode && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, 'An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.');
                    detachView(parent, index);
                    removeFromArray(viewRefs, index);
                }
            }
            this._attachedToViewContainer = false;
        }
        destroyLView(this._lView[TVIEW], this._lView);
    }
    onDestroy(callback) {
        storeLViewOnDestroy(this._lView, callback);
    }
    markForCheck() {
        markViewDirty(this._cdRefInjectingView || this._lView);
    }
    detach() {
        this._lView[FLAGS] &= -129;
    }
    reattach() {
        this._lView[FLAGS] |= 128;
    }
    detectChanges() {
        detectChangesInternal(this._lView[TVIEW], this._lView, this.context);
    }
    checkNoChanges() {
        if (ngDevMode) checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);
    }
    attachToViewContainerRef() {
        if (this._appRef) throw new RuntimeError(902, ngDevMode && 'This view is already attached directly to the ApplicationRef!');
        this._attachedToViewContainer = true;
    }
    detachFromAppRef() {
        this._appRef = null;
        renderDetachView(this._lView[TVIEW], this._lView);
    }
    attachToAppRef(appRef) {
        if (this._attachedToViewContainer) throw new RuntimeError(902, ngDevMode && 'This view is already attached to a ViewContainer!');
        this._appRef = appRef;
    }
    constructor(_lView, _cdRefInjectingView){
        this._lView = _lView;
        this._cdRefInjectingView = _cdRefInjectingView;
        this._appRef = null;
        this._attachedToViewContainer = false;
    }
}
class RootViewRef extends ViewRef$1 {
    detectChanges() {
        const lView = this._view;
        const tView = lView[TVIEW];
        const context = lView[CONTEXT];
        detectChangesInternal(tView, lView, context, false);
    }
    checkNoChanges() {
        if (ngDevMode) {
            const lView = this._view;
            const tView = lView[TVIEW];
            const context = lView[CONTEXT];
            checkNoChangesInternal(tView, lView, context, false);
        }
    }
    get context() {
        return null;
    }
    constructor(_view){
        super(_view);
        this._view = _view;
    }
}
class ComponentFactoryResolver extends ComponentFactoryResolver$1 {
    resolveComponentFactory(component) {
        ngDevMode && assertComponentType(component);
        const componentDef = getComponentDef(component);
        return new ComponentFactory(componentDef, this.ngModule);
    }
    constructor(ngModule){
        super();
        this.ngModule = ngModule;
    }
}
function toRefArray(map) {
    const array = [];
    for(let nonMinified in map)if (map.hasOwnProperty(nonMinified)) {
        const minified = map[nonMinified];
        array.push({
            propName: minified,
            templateName: nonMinified
        });
    }
    return array;
}
function getNamespace(elementName) {
    const name = elementName.toLowerCase();
    return name === 'svg' ? SVG_NAMESPACE : name === 'math' ? MATH_ML_NAMESPACE : null;
}
class ChainedInjector {
    get(token, notFoundValue, flags) {
        flags = convertToBitFlags(flags);
        const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
        if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) return value;
        return this.parentInjector.get(token, notFoundValue, flags);
    }
    constructor(injector, parentInjector){
        this.injector = injector;
        this.parentInjector = parentInjector;
    }
}
class ComponentFactory extends ComponentFactory$1 {
    get inputs() {
        return toRefArray(this.componentDef.inputs);
    }
    get outputs() {
        return toRefArray(this.componentDef.outputs);
    }
    create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {
        environmentInjector = environmentInjector || this.ngModule;
        let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector === null || environmentInjector === void 0 ? void 0 : environmentInjector.injector;
        if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;
        const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;
        const rendererFactory = rootViewInjector.get(RendererFactory2, null);
        if (rendererFactory === null) throw new RuntimeError(407, ngDevMode && "Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.");
        const sanitizer = rootViewInjector.get(Sanitizer, null);
        const effectManager = rootViewInjector.get(EffectManager, null);
        const environment = {
            rendererFactory,
            sanitizer,
            effectManager
        };
        const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);
        const elementName = this.componentDef.selectors[0][0] || 'div';
        const hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation, rootViewInjector) : createElementNode(hostRenderer, elementName, getNamespace(elementName));
        const rootFlags = this.componentDef.onPush ? 576 : 528;
        const rootTView = createTView(0, null, null, 1, 0, null, null, null, null, null, null);
        const rootLView = createLView(null, rootTView, null, rootFlags, null, null, environment, hostRenderer, rootViewInjector, null, null);
        enterView(rootLView);
        let component;
        let tElementNode;
        try {
            const rootComponentDef = this.componentDef;
            let rootDirectives;
            let hostDirectiveDefs = null;
            if (rootComponentDef.findHostDirectiveDefs) {
                rootDirectives = [];
                hostDirectiveDefs = new Map();
                rootComponentDef.findHostDirectiveDefs(rootComponentDef, rootDirectives, hostDirectiveDefs);
                rootDirectives.push(rootComponentDef);
            } else rootDirectives = [
                rootComponentDef
            ];
            const hostTNode = createRootComponentTNode(rootLView, hostRNode);
            const componentView = createRootComponentView(hostTNode, hostRNode, rootComponentDef, rootDirectives, rootLView, environment, hostRenderer);
            tElementNode = getTNode(rootTView, HEADER_OFFSET);
            if (hostRNode) setRootNodeAttributes(hostRenderer, rootComponentDef, hostRNode, rootSelectorOrNode);
            if (projectableNodes !== undefined) projectNodes(tElementNode, this.ngContentSelectors, projectableNodes);
            component = createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, [
                LifecycleHooksFeature
            ]);
            renderView(rootTView, rootLView, null);
        } finally{
            leaveView();
        }
        return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);
    }
    constructor(componentDef, ngModule){
        super();
        this.componentDef = componentDef;
        this.ngModule = ngModule;
        this.componentType = componentDef.type;
        this.selector = stringifyCSSSelectorList(componentDef.selectors);
        this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];
        this.isBoundToModule = !!ngModule;
    }
}
class ComponentRef extends ComponentRef$1 {
    setInput(name, value) {
        const inputData = this._tNode.inputs;
        let dataValue;
        if (inputData !== null && (dataValue = inputData[name])) {
            var _this_previousInputValues;
            (_this_previousInputValues = this.previousInputValues) !== null && _this_previousInputValues !== void 0 ? _this_previousInputValues : this.previousInputValues = new Map();
            if (this.previousInputValues.has(name) && Object.is(this.previousInputValues.get(name), value)) return;
            const lView = this._rootLView;
            setInputsForProperty(lView[TVIEW], lView, dataValue, name, value);
            this.previousInputValues.set(name, value);
            const childComponentLView = getComponentLViewByIndex(this._tNode.index, lView);
            markViewDirty(childComponentLView);
        } else if (ngDevMode) {
            const cmpNameForError = stringifyForError(this.componentType);
            let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;
            message += `Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;
            reportUnknownPropertyError(message);
        }
    }
    get injector() {
        return new NodeInjector(this._tNode, this._rootLView);
    }
    destroy() {
        this.hostView.destroy();
    }
    onDestroy(callback) {
        this.hostView.onDestroy(callback);
    }
    constructor(componentType, instance, location1, _rootLView, _tNode){
        super();
        this.location = location1;
        this._rootLView = _rootLView;
        this._tNode = _tNode;
        this.previousInputValues = null;
        this.instance = instance;
        this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);
        this.componentType = componentType;
    }
}
function createRootComponentTNode(lView, rNode) {
    const tView = lView[TVIEW];
    const index = HEADER_OFFSET;
    ngDevMode && assertIndexInRange(lView, index);
    lView[index] = rNode;
    return getOrCreateTNode(tView, index, 2, '#host', null);
}
function createRootComponentView(tNode, hostRNode, rootComponentDef, rootDirectives, rootView, environment, hostRenderer) {
    const tView = rootView[TVIEW];
    applyRootComponentStyling(rootDirectives, tNode, hostRNode, hostRenderer);
    let hydrationInfo = null;
    if (hostRNode !== null) hydrationInfo = retrieveHydrationInfo(hostRNode, rootView[INJECTOR$1]);
    const viewRenderer = environment.rendererFactory.createRenderer(hostRNode, rootComponentDef);
    const componentView = createLView(rootView, getOrCreateComponentTView(rootComponentDef), null, rootComponentDef.onPush ? 64 : 16, rootView[tNode.index], tNode, environment, viewRenderer, null, null, hydrationInfo);
    if (tView.firstCreatePass) markAsComponentHost(tView, tNode, rootDirectives.length - 1);
    addToViewTree(rootView, componentView);
    return rootView[tNode.index] = componentView;
}
function applyRootComponentStyling(rootDirectives, tNode, rNode, hostRenderer) {
    for (const def of rootDirectives)tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
    if (tNode.mergedAttrs !== null) {
        computeStaticStyling(tNode, tNode.mergedAttrs, true);
        if (rNode !== null) setupStaticAttributes(hostRenderer, rNode, tNode);
    }
}
function createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, hostFeatures) {
    const rootTNode = getCurrentTNode();
    ngDevMode && assertDefined(rootTNode, 'tNode should have been already created');
    const tView = rootLView[TVIEW];
    const native = getNativeByTNode(rootTNode, rootLView);
    initializeDirectives(tView, rootLView, rootTNode, rootDirectives, null, hostDirectiveDefs);
    for(let i = 0; i < rootDirectives.length; i++){
        const directiveIndex = rootTNode.directiveStart + i;
        const directiveInstance = getNodeInjectable(rootLView, tView, directiveIndex, rootTNode);
        attachPatchData(directiveInstance, rootLView);
    }
    invokeDirectivesHostBindings(tView, rootLView, rootTNode);
    if (native) attachPatchData(native, rootLView);
    ngDevMode && assertGreaterThan(rootTNode.componentOffset, -1, 'componentOffset must be great than -1');
    const component = getNodeInjectable(rootLView, tView, rootTNode.directiveStart + rootTNode.componentOffset, rootTNode);
    componentView[CONTEXT] = rootLView[CONTEXT] = component;
    if (hostFeatures !== null) for (const feature of hostFeatures)feature(component, rootComponentDef);
    executeContentQueries(tView, rootTNode, componentView);
    return component;
}
function setRootNodeAttributes(hostRenderer, componentDef, hostRNode, rootSelectorOrNode) {
    if (rootSelectorOrNode) setUpAttributes(hostRenderer, hostRNode, [
        'ng-version',
        VERSION.full
    ]);
    else {
        const { attrs , classes  } = extractAttrsAndClassesFromSelector(componentDef.selectors[0]);
        if (attrs) setUpAttributes(hostRenderer, hostRNode, attrs);
        if (classes && classes.length > 0) writeDirectClass(hostRenderer, hostRNode, classes.join(' '));
    }
}
function projectNodes(tNode, ngContentSelectors, projectableNodes) {
    const projection = tNode.projection = [];
    for(let i = 0; i < ngContentSelectors.length; i++){
        const nodesforSlot = projectableNodes[i];
        projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);
    }
}
function LifecycleHooksFeature() {
    const tNode = getCurrentTNode();
    ngDevMode && assertDefined(tNode, 'TNode is required');
    registerPostOrderHooks(getLView()[TVIEW], tNode);
}
function getSuperType(type) {
    return Object.getPrototypeOf(type.prototype).constructor;
}
function ɵɵInheritDefinitionFeature(definition) {
    let superType = getSuperType(definition.type);
    let shouldInheritFields = true;
    const inheritanceChain = [
        definition
    ];
    while(superType){
        let superDef = undefined;
        if (isComponentDef(definition)) superDef = superType.ɵcmp || superType.ɵdir;
        else {
            if (superType.ɵcmp) throw new RuntimeError(903, ngDevMode && `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);
            superDef = superType.ɵdir;
        }
        if (superDef) {
            if (shouldInheritFields) {
                inheritanceChain.push(superDef);
                const writeableDef = definition;
                writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
                writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
                writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
                const superHostBindings = superDef.hostBindings;
                superHostBindings && inheritHostBindings(definition, superHostBindings);
                const superViewQuery = superDef.viewQuery;
                const superContentQueries = superDef.contentQueries;
                superViewQuery && inheritViewQuery(definition, superViewQuery);
                superContentQueries && inheritContentQueries(definition, superContentQueries);
                fillProperties(definition.inputs, superDef.inputs);
                fillProperties(definition.declaredInputs, superDef.declaredInputs);
                fillProperties(definition.outputs, superDef.outputs);
                if (isComponentDef(superDef) && superDef.data.animation) {
                    const defData = definition.data;
                    defData.animation = (defData.animation || []).concat(superDef.data.animation);
                }
            }
            const features = superDef.features;
            if (features) for(let i = 0; i < features.length; i++){
                const feature = features[i];
                if (feature && feature.ngInherit) feature(definition);
                if (feature === ɵɵInheritDefinitionFeature) shouldInheritFields = false;
            }
        }
        superType = Object.getPrototypeOf(superType);
    }
    mergeHostAttrsAcrossInheritance(inheritanceChain);
}
function mergeHostAttrsAcrossInheritance(inheritanceChain) {
    let hostVars = 0;
    let hostAttrs = null;
    for(let i = inheritanceChain.length - 1; i >= 0; i--){
        const def = inheritanceChain[i];
        def.hostVars = hostVars += def.hostVars;
        def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
    }
}
function maybeUnwrapEmpty(value) {
    if (value === EMPTY_OBJ) return {};
    else if (value === EMPTY_ARRAY) return [];
    else return value;
}
function inheritViewQuery(definition, superViewQuery) {
    const prevViewQuery = definition.viewQuery;
    if (prevViewQuery) definition.viewQuery = (rf, ctx)=>{
        superViewQuery(rf, ctx);
        prevViewQuery(rf, ctx);
    };
    else definition.viewQuery = superViewQuery;
}
function inheritContentQueries(definition, superContentQueries) {
    const prevContentQueries = definition.contentQueries;
    if (prevContentQueries) definition.contentQueries = (rf, ctx, directiveIndex)=>{
        superContentQueries(rf, ctx, directiveIndex);
        prevContentQueries(rf, ctx, directiveIndex);
    };
    else definition.contentQueries = superContentQueries;
}
function inheritHostBindings(definition, superHostBindings) {
    const prevHostBindings = definition.hostBindings;
    if (prevHostBindings) definition.hostBindings = (rf, ctx)=>{
        superHostBindings(rf, ctx);
        prevHostBindings(rf, ctx);
    };
    else definition.hostBindings = superHostBindings;
}
const COPY_DIRECTIVE_FIELDS = [
    'providersResolver'
];
const COPY_COMPONENT_FIELDS = [
    'template',
    'decls',
    'consts',
    'vars',
    'onPush',
    'ngContentSelectors',
    'styles',
    'encapsulation',
    'schemas'
];
function ɵɵCopyDefinitionFeature(definition) {
    let superType = getSuperType(definition.type);
    let superDef = undefined;
    if (isComponentDef(definition)) superDef = superType.ɵcmp;
    else superDef = superType.ɵdir;
    const defAny = definition;
    for (const field of COPY_DIRECTIVE_FIELDS)defAny[field] = superDef[field];
    if (isComponentDef(superDef)) for (const field of COPY_COMPONENT_FIELDS)defAny[field] = superDef[field];
}
function ɵɵHostDirectivesFeature(rawHostDirectives) {
    return (definition)=>{
        definition.findHostDirectiveDefs = findHostDirectiveDefs;
        definition.hostDirectives = (Array.isArray(rawHostDirectives) ? rawHostDirectives : rawHostDirectives()).map((dir)=>{
            return typeof dir === 'function' ? {
                directive: resolveForwardRef(dir),
                inputs: EMPTY_OBJ,
                outputs: EMPTY_OBJ
            } : {
                directive: resolveForwardRef(dir.directive),
                inputs: bindingArrayToMap(dir.inputs),
                outputs: bindingArrayToMap(dir.outputs)
            };
        });
    };
}
function findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {
    if (currentDef.hostDirectives !== null) for (const hostDirectiveConfig of currentDef.hostDirectives){
        const hostDirectiveDef = getDirectiveDef(hostDirectiveConfig.directive);
        if (typeof ngDevMode === 'undefined' || ngDevMode) validateHostDirective(hostDirectiveConfig, hostDirectiveDef, matchedDefs);
        patchDeclaredInputs(hostDirectiveDef.declaredInputs, hostDirectiveConfig.inputs);
        findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);
        hostDirectiveDefs.set(hostDirectiveDef, hostDirectiveConfig);
        matchedDefs.push(hostDirectiveDef);
    }
}
function bindingArrayToMap(bindings) {
    if (bindings === undefined || bindings.length === 0) return EMPTY_OBJ;
    const result = {};
    for(let i = 0; i < bindings.length; i += 2)result[bindings[i]] = bindings[i + 1];
    return result;
}
function patchDeclaredInputs(declaredInputs, exposedInputs) {
    for(const publicName in exposedInputs)if (exposedInputs.hasOwnProperty(publicName)) {
        const remappedPublicName = exposedInputs[publicName];
        const privateName = declaredInputs[publicName];
        if ((typeof ngDevMode === 'undefined' || ngDevMode) && declaredInputs.hasOwnProperty(remappedPublicName)) assertEqual(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);
        declaredInputs[remappedPublicName] = privateName;
    }
}
function validateHostDirective(hostDirectiveConfig, directiveDef, matchedDefs) {
    const type = hostDirectiveConfig.directive;
    if (directiveDef === null) {
        if (getComponentDef(type) !== null) throw new RuntimeError(310, `Host directive ${type.name} cannot be a component.`);
        throw new RuntimeError(307, `Could not resolve metadata for host directive ${type.name}. ` + `Make sure that the ${type.name} class is annotated with an @Directive decorator.`);
    }
    if (!directiveDef.standalone) throw new RuntimeError(308, `Host directive ${directiveDef.type.name} must be standalone.`);
    if (matchedDefs.indexOf(directiveDef) > -1) throw new RuntimeError(309, `Directive ${directiveDef.type.name} matches multiple times on the same element. ` + `Directives can only match an element once.`);
    validateMappings('input', directiveDef, hostDirectiveConfig.inputs);
    validateMappings('output', directiveDef, hostDirectiveConfig.outputs);
}
function validateMappings(bindingType, def, hostDirectiveBindings) {
    const className = def.type.name;
    const bindings = bindingType === 'input' ? def.inputs : def.outputs;
    for(const publicName in hostDirectiveBindings)if (hostDirectiveBindings.hasOwnProperty(publicName)) {
        if (!bindings.hasOwnProperty(publicName)) throw new RuntimeError(311, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);
        const remappedPublicName = hostDirectiveBindings[publicName];
        if (bindings.hasOwnProperty(remappedPublicName) && bindings[remappedPublicName] !== publicName) throw new RuntimeError(312, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);
    }
}
function isListLikeIterable(obj) {
    if (!isJsObject(obj)) return false;
    return Array.isArray(obj) || !(obj instanceof Map) && Symbol.iterator in obj;
}
function areIterablesEqual(a, b, comparator) {
    const iterator1 = a[Symbol.iterator]();
    const iterator2 = b[Symbol.iterator]();
    while(true){
        const item1 = iterator1.next();
        const item2 = iterator2.next();
        if (item1.done && item2.done) return true;
        if (item1.done || item2.done) return false;
        if (!comparator(item1.value, item2.value)) return false;
    }
}
function iterateListLike(obj, fn) {
    if (Array.isArray(obj)) for(let i = 0; i < obj.length; i++)fn(obj[i]);
    else {
        const iterator = obj[Symbol.iterator]();
        let item;
        while(!(item = iterator.next()).done)fn(item.value);
    }
}
function isJsObject(o) {
    return o !== null && (typeof o === 'function' || typeof o === 'object');
}
function devModeEqual(a, b) {
    const isListLikeIterableA = isListLikeIterable(a);
    const isListLikeIterableB = isListLikeIterable(b);
    if (isListLikeIterableA && isListLikeIterableB) return areIterablesEqual(a, b, devModeEqual);
    else {
        const isAObject = a && (typeof a === 'object' || typeof a === 'function');
        const isBObject = b && (typeof b === 'object' || typeof b === 'function');
        if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) return true;
        else return Object.is(a, b);
    }
}
function updateBinding(lView, bindingIndex, value) {
    return lView[bindingIndex] = value;
}
function getBinding(lView, bindingIndex) {
    ngDevMode && assertIndexInRange(lView, bindingIndex);
    ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');
    return lView[bindingIndex];
}
function bindingUpdated(lView, bindingIndex, value) {
    ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');
    ngDevMode && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
    const oldValue = lView[bindingIndex];
    if (Object.is(oldValue, value)) return false;
    else {
        if (ngDevMode && isInCheckNoChangesMode()) {
            const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : undefined;
            if (!devModeEqual(oldValueToCompare, value)) {
                const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
                throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName);
            }
            return false;
        }
        lView[bindingIndex] = value;
        return true;
    }
}
function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
    const different = bindingUpdated(lView, bindingIndex, exp1);
    return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
}
function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
    return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
}
function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
    return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
}
function ɵɵattribute(name, value, sanitizer, namespace) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
        const tView = getTView();
        const tNode = getSelectedTNode();
        elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, 'attr.' + name, bindingIndex);
    }
    return ɵɵattribute;
}
function interpolationV(lView, values) {
    ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');
    ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');
    let isBindingUpdated = false;
    let bindingIndex = getBindingIndex();
    for(let i = 1; i < values.length; i += 2)isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
    setBindingIndex(bindingIndex);
    if (!isBindingUpdated) return NO_CHANGE;
    let content = values[0];
    for(let i = 1; i < values.length; i += 2)content += renderStringify(values[i]) + values[i + 1];
    return content;
}
function interpolation1(lView, prefix, v0, suffix) {
    const different = bindingUpdated(lView, nextBindingIndex(), v0);
    return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
}
function interpolation2(lView, prefix, v0, i0, v1, suffix) {
    const bindingIndex = getBindingIndex();
    const different = bindingUpdated2(lView, bindingIndex, v0, v1);
    incrementBindingIndex(2);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
}
function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {
    const bindingIndex = getBindingIndex();
    const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
    incrementBindingIndex(3);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;
}
function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
    const bindingIndex = getBindingIndex();
    const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    incrementBindingIndex(4);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;
}
function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
    incrementBindingIndex(5);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;
}
function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
    incrementBindingIndex(6);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;
}
function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
    incrementBindingIndex(7);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;
}
function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
    incrementBindingIndex(8);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;
}
function ɵɵattributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tNode = getSelectedTNode();
        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
        ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 1, prefix, suffix);
    }
    return ɵɵattributeInterpolate1;
}
function ɵɵattributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tNode = getSelectedTNode();
        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
        ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 2, prefix, i0, suffix);
    }
    return ɵɵattributeInterpolate2;
}
function ɵɵattributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tNode = getSelectedTNode();
        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
        ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);
    }
    return ɵɵattributeInterpolate3;
}
function ɵɵattributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tNode = getSelectedTNode();
        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
        ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
    }
    return ɵɵattributeInterpolate4;
}
function ɵɵattributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tNode = getSelectedTNode();
        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
        ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
    }
    return ɵɵattributeInterpolate5;
}
function ɵɵattributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tNode = getSelectedTNode();
        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
        ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
    }
    return ɵɵattributeInterpolate6;
}
function ɵɵattributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tNode = getSelectedTNode();
        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
        ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
    }
    return ɵɵattributeInterpolate7;
}
function ɵɵattributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tNode = getSelectedTNode();
        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
        ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
    }
    return ɵɵattributeInterpolate8;
}
function ɵɵattributeInterpolateV(attrName, values, sanitizer, namespace) {
    const lView = getLView();
    const interpolated = interpolationV(lView, values);
    if (interpolated !== NO_CHANGE) {
        const tNode = getSelectedTNode();
        elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);
        if (ngDevMode) {
            const interpolationInBetween = [
                values[0]
            ];
            for(let i = 2; i < values.length; i += 2)interpolationInBetween.push(values[i]);
            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
        }
    }
    return ɵɵattributeInterpolateV;
}
new Set([
    'ngh',
    'ng-version',
    'ng-server-context'
]);
new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);
function templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) {
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && ngDevMode.firstCreatePass++;
    const tViewConsts = tView.consts;
    const tNode = getOrCreateTNode(tView, index, 4, tagName || null, getConstant(tViewConsts, attrsIndex));
    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
    registerPostOrderHooks(tView, tNode);
    const embeddedTView = tNode.tView = createTView(2, tNode, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry, null, tView.schemas, tViewConsts, null);
    if (tView.queries !== null) {
        tView.queries.template(tView, tNode);
        embeddedTView.queries = tView.queries.embeddedTView(tNode);
    }
    return tNode;
}
function ɵɵtemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = index + HEADER_OFFSET;
    const tNode = tView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
    setCurrentTNode(tNode, false);
    const comment = _locateOrCreateContainerAnchor(tView, lView, tNode, index);
    if (wasLastNodeCreated()) appendChild(tView, lView, comment, tNode);
    attachPatchData(comment, lView);
    addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));
    if (isDirectiveHost(tNode)) createDirectivesInstances(tView, lView, tNode);
    if (localRefsIndex != null) saveResolvedLocalsInData(lView, tNode, localRefExtractor);
}
let _locateOrCreateContainerAnchor = createContainerAnchorImpl;
function createContainerAnchorImpl(tView, lView, tNode, index) {
    lastNodeWasCreated(true);
    return lView[RENDERER].createComment(ngDevMode ? 'container' : '');
}
function store(tView, lView, index, value) {
    if (index >= tView.data.length) {
        tView.data[index] = null;
        tView.blueprint[index] = null;
    }
    lView[index] = value;
}
function ɵɵreference(index) {
    const contextLView = getContextLView();
    return load(contextLView, HEADER_OFFSET + index);
}
function ɵɵproperty(propName, value, sanitizer) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
        const tView = getTView();
        const tNode = getSelectedTNode();
        elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
    }
    return ɵɵproperty;
}
function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
    const inputs = tNode.inputs;
    const property = isClassBased ? 'class' : 'style';
    setInputsForProperty(tView, lView, inputs[property], property, value);
}
function elementStartFirstCreatePass(index, tView, lView, name, attrsIndex, localRefsIndex) {
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && ngDevMode.firstCreatePass++;
    const tViewConsts = tView.consts;
    const attrs = getConstant(tViewConsts, attrsIndex);
    const tNode = getOrCreateTNode(tView, index, 2, name, attrs);
    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
    if (tNode.attrs !== null) computeStaticStyling(tNode, tNode.attrs, false);
    if (tNode.mergedAttrs !== null) computeStaticStyling(tNode, tNode.mergedAttrs, true);
    if (tView.queries !== null) tView.queries.elementStart(tView, tNode);
    return tNode;
}
function ɵɵelementStart(index, name, attrsIndex, localRefsIndex) {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = HEADER_OFFSET + index;
    ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, 'elements should be created before any bindings');
    ngDevMode && assertIndexInRange(lView, adjustedIndex);
    const renderer = lView[RENDERER];
    const tNode = tView.firstCreatePass ? elementStartFirstCreatePass(adjustedIndex, tView, lView, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
    const native = _locateOrCreateElementNode(tView, lView, tNode, renderer, name, index);
    lView[adjustedIndex] = native;
    const hasDirectives = isDirectiveHost(tNode);
    if (ngDevMode && tView.firstCreatePass) validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);
    setCurrentTNode(tNode, true);
    setupStaticAttributes(renderer, native, tNode);
    if ((tNode.flags & 32) !== 32 && wasLastNodeCreated()) appendChild(tView, lView, native, tNode);
    if (getElementDepthCount() === 0) attachPatchData(native, lView);
    increaseElementDepthCount();
    if (hasDirectives) {
        createDirectivesInstances(tView, lView, tNode);
        executeContentQueries(tView, tNode, lView);
    }
    if (localRefsIndex !== null) saveResolvedLocalsInData(lView, tNode);
    return ɵɵelementStart;
}
function ɵɵelementEnd() {
    let currentTNode = getCurrentTNode();
    ngDevMode && assertDefined(currentTNode, 'No parent node to close.');
    if (isCurrentTNodeParent()) setCurrentTNodeAsNotParent();
    else {
        ngDevMode && assertHasParent(getCurrentTNode());
        currentTNode = currentTNode.parent;
        setCurrentTNode(currentTNode, false);
    }
    const tNode = currentTNode;
    ngDevMode && assertTNodeType(tNode, 3);
    if (isSkipHydrationRootTNode(tNode)) leaveSkipHydrationBlock();
    decreaseElementDepthCount();
    const tView = getTView();
    if (tView.firstCreatePass) {
        registerPostOrderHooks(tView, currentTNode);
        if (isContentQueryHost(currentTNode)) tView.queries.elementEnd(currentTNode);
    }
    if (tNode.classesWithoutHost != null && hasClassInput(tNode)) setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);
    if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);
    return ɵɵelementEnd;
}
function ɵɵelement(index, name, attrsIndex, localRefsIndex) {
    ɵɵelementStart(index, name, attrsIndex, localRefsIndex);
    ɵɵelementEnd();
    return ɵɵelement;
}
let _locateOrCreateElementNode = (tView, lView, tNode, renderer, name, index)=>{
    lastNodeWasCreated(true);
    return createElementNode(renderer, name, getNamespace$1());
};
function elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {
    ngDevMode && ngDevMode.firstCreatePass++;
    const tViewConsts = tView.consts;
    const attrs = getConstant(tViewConsts, attrsIndex);
    const tNode = getOrCreateTNode(tView, index, 8, 'ng-container', attrs);
    if (attrs !== null) computeStaticStyling(tNode, attrs, true);
    const localRefs = getConstant(tViewConsts, localRefsIndex);
    resolveDirectives(tView, lView, tNode, localRefs);
    if (tView.queries !== null) tView.queries.elementStart(tView, tNode);
    return tNode;
}
function ɵɵelementContainerStart(index, attrsIndex, localRefsIndex) {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = index + HEADER_OFFSET;
    ngDevMode && assertIndexInRange(lView, adjustedIndex);
    ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, 'element containers should be created before any bindings');
    const tNode = tView.firstCreatePass ? elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
    setCurrentTNode(tNode, true);
    const comment = _locateOrCreateElementContainerNode(tView, lView, tNode, index);
    lView[adjustedIndex] = comment;
    if (wasLastNodeCreated()) appendChild(tView, lView, comment, tNode);
    attachPatchData(comment, lView);
    if (isDirectiveHost(tNode)) {
        createDirectivesInstances(tView, lView, tNode);
        executeContentQueries(tView, tNode, lView);
    }
    if (localRefsIndex != null) saveResolvedLocalsInData(lView, tNode);
    return ɵɵelementContainerStart;
}
function ɵɵelementContainerEnd() {
    let currentTNode = getCurrentTNode();
    const tView = getTView();
    if (isCurrentTNodeParent()) setCurrentTNodeAsNotParent();
    else {
        ngDevMode && assertHasParent(currentTNode);
        currentTNode = currentTNode.parent;
        setCurrentTNode(currentTNode, false);
    }
    ngDevMode && assertTNodeType(currentTNode, 8);
    if (tView.firstCreatePass) {
        registerPostOrderHooks(tView, currentTNode);
        if (isContentQueryHost(currentTNode)) tView.queries.elementEnd(currentTNode);
    }
    return ɵɵelementContainerEnd;
}
function ɵɵelementContainer(index, attrsIndex, localRefsIndex) {
    ɵɵelementContainerStart(index, attrsIndex, localRefsIndex);
    ɵɵelementContainerEnd();
    return ɵɵelementContainer;
}
let _locateOrCreateElementContainerNode = (tView, lView, tNode, index)=>{
    lastNodeWasCreated(true);
    return createCommentNode(lView[RENDERER], ngDevMode ? 'ng-container' : '');
};
function ɵɵgetCurrentView() {
    return getLView();
}
function isPromise(obj) {
    return !!obj && typeof obj.then === 'function';
}
function isSubscribable(obj) {
    return !!obj && typeof obj.subscribe === 'function';
}
function ɵɵlistener(eventName, listenerFn, useCapture, eventTargetResolver) {
    const lView = getLView();
    const tView = getTView();
    const tNode = getCurrentTNode();
    listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, eventTargetResolver);
    return ɵɵlistener;
}
function ɵɵsyntheticHostListener(eventName, listenerFn) {
    const tNode = getCurrentTNode();
    const lView = getLView();
    const tView = getTView();
    const currentDef = getCurrentDirectiveDef(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);
    return ɵɵsyntheticHostListener;
}
function findExistingListener(tView, lView, eventName, tNodeIdx) {
    const tCleanup = tView.cleanup;
    if (tCleanup != null) for(let i = 0; i < tCleanup.length - 1; i += 2){
        const cleanupEventName = tCleanup[i];
        if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {
            const lCleanup = lView[CLEANUP];
            const listenerIdxInLCleanup = tCleanup[i + 2];
            return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
        }
        if (typeof cleanupEventName === 'string') i += 2;
    }
    return null;
}
function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {
    const isTNodeDirectiveHost = isDirectiveHost(tNode);
    const firstCreatePass = tView.firstCreatePass;
    const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);
    const context = lView[CONTEXT];
    const lCleanup = getOrCreateLViewCleanup(lView);
    ngDevMode && assertTNodeType(tNode, 15);
    let processOutputs = true;
    if (tNode.type & 3 || eventTargetResolver) {
        const native = getNativeByTNode(tNode, lView);
        const target = eventTargetResolver ? eventTargetResolver(native) : native;
        const lCleanupIndex = lCleanup.length;
        const idxOrTargetGetter = eventTargetResolver ? (_lView)=>eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;
        let existingListener = null;
        if (!eventTargetResolver && isTNodeDirectiveHost) existingListener = findExistingListener(tView, lView, eventName, tNode.index);
        if (existingListener !== null) {
            const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
            lastListenerFn.__ngNextListenerFn__ = listenerFn;
            existingListener.__ngLastListenerFn__ = listenerFn;
            processOutputs = false;
        } else {
            listenerFn = wrapListener(tNode, lView, context, listenerFn, false);
            const cleanupFn = renderer.listen(target, eventName, listenerFn);
            ngDevMode && ngDevMode.rendererAddEventListener++;
            lCleanup.push(listenerFn, cleanupFn);
            tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
        }
    } else listenerFn = wrapListener(tNode, lView, context, listenerFn, false);
    const outputs = tNode.outputs;
    let props;
    if (processOutputs && outputs !== null && (props = outputs[eventName])) {
        const propsLength = props.length;
        if (propsLength) for(let i = 0; i < propsLength; i += 2){
            const index = props[i];
            ngDevMode && assertIndexInRange(lView, index);
            const minifiedName = props[i + 1];
            const directiveInstance = lView[index];
            const output = directiveInstance[minifiedName];
            if (ngDevMode && !isSubscribable(output)) throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);
            const subscription = output.subscribe(listenerFn);
            const idx = lCleanup.length;
            lCleanup.push(listenerFn, subscription);
            tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
        }
    }
}
function executeListenerWithErrorHandling(lView, context, listenerFn, e) {
    try {
        profiler(6, context, listenerFn);
        return listenerFn(e) !== false;
    } catch (error) {
        handleError(lView, error);
        return false;
    } finally{
        profiler(7, context, listenerFn);
    }
}
function wrapListener(tNode, lView, context, listenerFn, wrapWithPreventDefault) {
    return function wrapListenerIn_markDirtyAndPreventDefault(e) {
        if (e === Function) return listenerFn;
        const startView = tNode.componentOffset > -1 ? getComponentLViewByIndex(tNode.index, lView) : lView;
        markViewDirty(startView);
        let result = executeListenerWithErrorHandling(lView, context, listenerFn, e);
        let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
        while(nextListenerFn){
            result = executeListenerWithErrorHandling(lView, context, nextListenerFn, e) && result;
            nextListenerFn = nextListenerFn.__ngNextListenerFn__;
        }
        if (wrapWithPreventDefault && result === false) {
            e.preventDefault();
            e.returnValue = false;
        }
        return result;
    };
}
function ɵɵnextContext(level = 1) {
    return nextContextImpl(level);
}
function matchingProjectionSlotIndex(tNode, projectionSlots) {
    let wildcardNgContentIndex = null;
    const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
    for(let i = 0; i < projectionSlots.length; i++){
        const slotValue = projectionSlots[i];
        if (slotValue === '*') {
            wildcardNgContentIndex = i;
            continue;
        }
        if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(tNode, slotValue, true) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) return i;
    }
    return wildcardNgContentIndex;
}
function ɵɵprojectionDef(projectionSlots) {
    const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];
    if (!componentNode.projection) {
        const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
        const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);
        const tails = projectionHeads.slice();
        let componentChild = componentNode.child;
        while(componentChild !== null){
            const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
            if (slotIndex !== null) {
                if (tails[slotIndex]) tails[slotIndex].projectionNext = componentChild;
                else projectionHeads[slotIndex] = componentChild;
                tails[slotIndex] = componentChild;
            }
            componentChild = componentChild.next;
        }
    }
}
function ɵɵprojection(nodeIndex, selectorIndex = 0, attrs) {
    const lView = getLView();
    const tView = getTView();
    const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
    if (tProjectionNode.projection === null) tProjectionNode.projection = selectorIndex;
    setCurrentTNodeAsNotParent();
    const hydrationInfo = lView[HYDRATION];
    const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1();
    if (isNodeCreationMode && (tProjectionNode.flags & 32) !== 32) applyProjection(tView, lView, tProjectionNode);
}
function ɵɵpropertyInterpolate(propName, v0, sanitizer) {
    ɵɵpropertyInterpolate1(propName, '', v0, '', sanitizer);
    return ɵɵpropertyInterpolate;
}
function ɵɵpropertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tView = getTView();
        const tNode = getSelectedTNode();
        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);
    }
    return ɵɵpropertyInterpolate1;
}
function ɵɵpropertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tView = getTView();
        const tNode = getSelectedTNode();
        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);
    }
    return ɵɵpropertyInterpolate2;
}
function ɵɵpropertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tView = getTView();
        const tNode = getSelectedTNode();
        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);
    }
    return ɵɵpropertyInterpolate3;
}
function ɵɵpropertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tView = getTView();
        const tNode = getSelectedTNode();
        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
    }
    return ɵɵpropertyInterpolate4;
}
function ɵɵpropertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tView = getTView();
        const tNode = getSelectedTNode();
        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
    }
    return ɵɵpropertyInterpolate5;
}
function ɵɵpropertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tView = getTView();
        const tNode = getSelectedTNode();
        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
    }
    return ɵɵpropertyInterpolate6;
}
function ɵɵpropertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tView = getTView();
        const tNode = getSelectedTNode();
        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
    }
    return ɵɵpropertyInterpolate7;
}
function ɵɵpropertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    if (interpolatedValue !== NO_CHANGE) {
        const tView = getTView();
        const tNode = getSelectedTNode();
        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
    }
    return ɵɵpropertyInterpolate8;
}
function ɵɵpropertyInterpolateV(propName, values, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    if (interpolatedValue !== NO_CHANGE) {
        const tView = getTView();
        const tNode = getSelectedTNode();
        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
        if (ngDevMode) {
            const interpolationInBetween = [
                values[0]
            ];
            for(let i = 2; i < values.length; i += 2)interpolationInBetween.push(values[i]);
            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
        }
    }
    return ɵɵpropertyInterpolateV;
}
function toTStylingRange(prev, next) {
    ngDevMode && assertNumberInRange(prev, 0, 32767);
    ngDevMode && assertNumberInRange(next, 0, 32767);
    return prev << 17 | next << 2;
}
function getTStylingRangePrev(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    return tStylingRange >> 17 & 32767;
}
function getTStylingRangePrevDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    return (tStylingRange & 2) == 2;
}
function setTStylingRangePrev(tStylingRange, previous) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    ngDevMode && assertNumberInRange(previous, 0, 32767);
    return tStylingRange & 131071 | previous << 17;
}
function setTStylingRangePrevDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    return tStylingRange | 2;
}
function getTStylingRangeNext(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    return (tStylingRange & 131068) >> 2;
}
function setTStylingRangeNext(tStylingRange, next) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    ngDevMode && assertNumberInRange(next, 0, 32767);
    return tStylingRange & -131069 | next << 2;
}
function getTStylingRangeNextDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    return (tStylingRange & 1) === 1;
}
function setTStylingRangeNextDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, 'expected number');
    return tStylingRange | 1;
}
function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {
    ngDevMode && assertFirstUpdatePass(getTView());
    let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
    let tmplHead = getTStylingRangePrev(tBindings);
    let tmplTail = getTStylingRangeNext(tBindings);
    tData[index] = tStylingKeyWithStatic;
    let isKeyDuplicateOfStatic = false;
    let tStylingKey;
    if (Array.isArray(tStylingKeyWithStatic)) {
        const staticKeyValueArray = tStylingKeyWithStatic;
        tStylingKey = staticKeyValueArray[1];
        if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) isKeyDuplicateOfStatic = true;
    } else tStylingKey = tStylingKeyWithStatic;
    if (isHostBinding) {
        const hasTemplateBindings = tmplTail !== 0;
        if (hasTemplateBindings) {
            const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
            tData[index + 1] = toTStylingRange(previousNode, tmplHead);
            if (previousNode !== 0) tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
            tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
        } else {
            tData[index + 1] = toTStylingRange(tmplHead, 0);
            if (tmplHead !== 0) tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
            tmplHead = index;
        }
    } else {
        tData[index + 1] = toTStylingRange(tmplTail, 0);
        ngDevMode && assertEqual(tmplHead !== 0 && tmplTail === 0, false, 'Adding template bindings after hostBindings is not allowed.');
        if (tmplHead === 0) tmplHead = index;
        else tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
        tmplTail = index;
    }
    if (isKeyDuplicateOfStatic) tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
    markDuplicates(tData, tStylingKey, index, true, isClassBinding);
    markDuplicates(tData, tStylingKey, index, false, isClassBinding);
    markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
    tBindings = toTStylingRange(tmplHead, tmplTail);
    if (isClassBinding) tNode.classBindings = tBindings;
    else tNode.styleBindings = tBindings;
}
function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
    const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
    if (residual != null && typeof tStylingKey == 'string' && keyValueArrayIndexOf(residual, tStylingKey) >= 0) tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
}
function markDuplicates(tData, tStylingKey, index, isPrevDir, isClassBinding) {
    const tStylingAtIndex = tData[index + 1];
    const isMap = tStylingKey === null;
    let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
    let foundDuplicate = false;
    while(cursor !== 0 && (foundDuplicate === false || isMap)){
        ngDevMode && assertIndexInRange(tData, cursor);
        const tStylingValueAtCursor = tData[cursor];
        const tStyleRangeAtCursor = tData[cursor + 1];
        if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
            foundDuplicate = true;
            tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
        }
        cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
    }
    if (foundDuplicate) tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
}
function isStylingMatch(tStylingKeyCursor, tStylingKey) {
    ngDevMode && assertNotEqual(Array.isArray(tStylingKey), true, 'Expected that \'tStylingKey\' has been unwrapped');
    if (tStylingKeyCursor === null || tStylingKey == null || (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) return true;
    else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === 'string') return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;
    return false;
}
const parserState = {
    textEnd: 0,
    key: 0,
    keyEnd: 0,
    value: 0,
    valueEnd: 0
};
function getLastParsedKey(text) {
    return text.substring(parserState.key, parserState.keyEnd);
}
function getLastParsedValue(text) {
    return text.substring(parserState.value, parserState.valueEnd);
}
function parseClassName(text) {
    resetParserState(text);
    return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseClassNameNext(text, index) {
    const end = parserState.textEnd;
    if (end === index) return -1;
    index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
    return consumeWhitespace(text, index, end);
}
function parseStyle(text) {
    resetParserState(text);
    return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseStyleNext(text, startIndex) {
    const end = parserState.textEnd;
    let index = parserState.key = consumeWhitespace(text, startIndex, end);
    if (end === index) return -1;
    index = parserState.keyEnd = consumeStyleKey(text, index, end);
    index = consumeSeparator(text, index, end, 58);
    index = parserState.value = consumeWhitespace(text, index, end);
    index = parserState.valueEnd = consumeStyleValue(text, index, end);
    return consumeSeparator(text, index, end, 59);
}
function resetParserState(text) {
    parserState.key = 0;
    parserState.keyEnd = 0;
    parserState.value = 0;
    parserState.valueEnd = 0;
    parserState.textEnd = text.length;
}
function consumeWhitespace(text, startIndex, endIndex) {
    while(startIndex < endIndex && text.charCodeAt(startIndex) <= 32)startIndex++;
    return startIndex;
}
function consumeClassToken(text, startIndex, endIndex) {
    while(startIndex < endIndex && text.charCodeAt(startIndex) > 32)startIndex++;
    return startIndex;
}
function consumeStyleKey(text, startIndex, endIndex) {
    let ch;
    while(startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57))startIndex++;
    return startIndex;
}
function consumeSeparator(text, startIndex, endIndex, separator) {
    startIndex = consumeWhitespace(text, startIndex, endIndex);
    if (startIndex < endIndex) {
        if (ngDevMode && text.charCodeAt(startIndex) !== separator) malformedStyleError(text, String.fromCharCode(separator), startIndex);
        startIndex++;
    }
    return startIndex;
}
function consumeStyleValue(text, startIndex, endIndex) {
    let ch1 = -1;
    let ch2 = -1;
    let ch3 = -1;
    let i = startIndex;
    let lastChIndex = i;
    while(i < endIndex){
        const ch = text.charCodeAt(i++);
        if (ch === 59) return lastChIndex;
        else if (ch === 34 || ch === 39) lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);
        else if (startIndex === i - 4 && ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) lastChIndex = i = consumeQuotedText(text, 41, i, endIndex);
        else if (ch > 32) lastChIndex = i;
        ch3 = ch2;
        ch2 = ch1;
        ch1 = ch & -33;
    }
    return lastChIndex;
}
function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
    let ch1 = -1;
    let index = startIndex;
    while(index < endIndex){
        const ch = text.charCodeAt(index++);
        if (ch == quoteCharCode && ch1 !== 92) return index;
        if (ch == 92 && ch1 === 92) ch1 = 0;
        else ch1 = ch;
    }
    throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();
}
function malformedStyleError(text, expecting, index) {
    ngDevMode && assertEqual(typeof text === 'string', true, 'String expected here');
    throw throwError(`Malformed style at location ${index} in string '` + text.substring(0, index) + '[>>' + text.substring(index, index + 1) + '<<]' + text.slice(index + 1) + `'. Expecting '${expecting}'.`);
}
function ɵɵstyleProp(prop, value, suffix) {
    checkStylingProperty(prop, value, suffix, false);
    return ɵɵstyleProp;
}
function ɵɵclassProp(className, value) {
    checkStylingProperty(className, value, null, true);
    return ɵɵclassProp;
}
function ɵɵstyleMap(styles) {
    checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
}
function styleStringParser(keyValueArray, text) {
    for(let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
}
function ɵɵclassMap(classes) {
    checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);
}
function classStringParser(keyValueArray, text) {
    for(let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i))keyValueArraySet(keyValueArray, getLastParsedKey(text), true);
}
function checkStylingProperty(prop, value, suffix, isClassBased) {
    const lView = getLView();
    const tView = getTView();
    const bindingIndex = incrementBindingIndex(2);
    if (tView.firstUpdatePass) stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
        const tNode = tView.data[getSelectedIndex()];
        updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
    }
}
function checkStylingMap(keyValueArraySet, stringParser, value, isClassBased) {
    const tView = getTView();
    const bindingIndex = incrementBindingIndex(2);
    if (tView.firstUpdatePass) stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
    const lView = getLView();
    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
        const tNode = tView.data[getSelectedIndex()];
        if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
            if (ngDevMode) {
                const tStylingKey = tView.data[bindingIndex];
                assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, 'Styling linked list shadow input should be marked as \'false\'');
            }
            let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
            ngDevMode && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(';'), true, 'Expecting static portion to end with \';\'');
            if (staticPrefix !== null) value = concatStringsWithSpace(staticPrefix, value ? value : '');
            setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
        } else updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet, stringParser, value), isClassBased, bindingIndex);
    }
}
function isInHostBindings(tView, bindingIndex) {
    return bindingIndex >= tView.expandoStartIndex;
}
function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
    ngDevMode && assertFirstUpdatePass(tView);
    const tData = tView.data;
    if (tData[bindingIndex + 1] === null) {
        const tNode = tData[getSelectedIndex()];
        ngDevMode && assertDefined(tNode, 'TNode expected');
        const isHostBindings = isInHostBindings(tView, bindingIndex);
        if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) tStylingKey = false;
        tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
        insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
    }
}
function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
    const hostDirectiveDef = getCurrentDirectiveDef(tData);
    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (hostDirectiveDef === null) {
        const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
        if (isFirstStylingInstructionInTemplate) {
            stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
            stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
            residual = null;
        }
    } else {
        const directiveStylingLast = tNode.directiveStylingLast;
        const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
        if (isFirstStylingInstructionInHostBinding) {
            stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
            if (residual === null) {
                let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
                if (templateStylingKey !== undefined && Array.isArray(templateStylingKey)) {
                    templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
                    templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
                    setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
                }
            } else residual = collectResidual(tData, tNode, isClassBased);
        }
    }
    if (residual !== undefined) isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
    return stylingKey;
}
function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
    if (getTStylingRangeNext(bindings) === 0) return undefined;
    return tData[getTStylingRangePrev(bindings)];
}
function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
    ngDevMode && assertNotEqual(getTStylingRangeNext(bindings), 0, 'Expecting to have at least one template styling binding.');
    tData[getTStylingRangePrev(bindings)] = tStylingKey;
}
function collectResidual(tData, tNode, isClassBased) {
    let residual = undefined;
    const directiveEnd = tNode.directiveEnd;
    ngDevMode && assertNotEqual(tNode.directiveStylingLast, -1, 'By the time this function gets called at least one hostBindings-node styling instruction must have executed.');
    for(let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++){
        const attrs = tData[i].hostAttrs;
        residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
    }
    return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
}
function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
    let currentDirective = null;
    const directiveEnd = tNode.directiveEnd;
    let directiveStylingLast = tNode.directiveStylingLast;
    if (directiveStylingLast === -1) directiveStylingLast = tNode.directiveStart;
    else directiveStylingLast++;
    while(directiveStylingLast < directiveEnd){
        currentDirective = tData[directiveStylingLast];
        ngDevMode && assertDefined(currentDirective, 'expected to be defined');
        stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
        if (currentDirective === hostDirectiveDef) break;
        directiveStylingLast++;
    }
    if (hostDirectiveDef !== null) tNode.directiveStylingLast = directiveStylingLast;
    return stylingKey;
}
function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
    const desiredMarker = isClassBased ? 1 : 2;
    let currentMarker = -1;
    if (attrs !== null) for(let i = 0; i < attrs.length; i++){
        const item = attrs[i];
        if (typeof item === 'number') currentMarker = item;
        else if (currentMarker === desiredMarker) {
            if (!Array.isArray(stylingKey)) stylingKey = stylingKey === undefined ? [] : [
                '',
                stylingKey
            ];
            keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);
        }
    }
    return stylingKey === undefined ? null : stylingKey;
}
function toStylingKeyValueArray(keyValueArraySet, stringParser, value) {
    if (value == null || value === '') return EMPTY_ARRAY;
    const styleKeyValueArray = [];
    const unwrappedValue = unwrapSafeValue(value);
    if (Array.isArray(unwrappedValue)) for(let i = 0; i < unwrappedValue.length; i++)keyValueArraySet(styleKeyValueArray, unwrappedValue[i], true);
    else if (typeof unwrappedValue === 'object') {
        for(const key in unwrappedValue)if (unwrappedValue.hasOwnProperty(key)) keyValueArraySet(styleKeyValueArray, key, unwrappedValue[key]);
    } else if (typeof unwrappedValue === 'string') stringParser(styleKeyValueArray, unwrappedValue);
    else ngDevMode && throwError('Unsupported styling type ' + typeof unwrappedValue + ': ' + unwrappedValue);
    return styleKeyValueArray;
}
function styleKeyValueArraySet(keyValueArray, key, value) {
    keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));
}
function classKeyValueArraySet(keyValueArray, key, value) {
    const stringKey = String(key);
    if (stringKey !== '' && !stringKey.includes(' ')) keyValueArraySet(keyValueArray, stringKey, value);
}
function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
    if (oldKeyValueArray === NO_CHANGE) oldKeyValueArray = EMPTY_ARRAY;
    let oldIndex = 0;
    let newIndex = 0;
    let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
    let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
    while(oldKey !== null || newKey !== null){
        ngDevMode && assertLessThan(oldIndex, 999, 'Are we stuck in infinite loop?');
        ngDevMode && assertLessThan(newIndex, 999, 'Are we stuck in infinite loop?');
        const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : undefined;
        const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : undefined;
        let setKey = null;
        let setValue = undefined;
        if (oldKey === newKey) {
            oldIndex += 2;
            newIndex += 2;
            if (oldValue !== newValue) {
                setKey = newKey;
                setValue = newValue;
            }
        } else if (newKey === null || oldKey !== null && oldKey < newKey) {
            oldIndex += 2;
            setKey = oldKey;
        } else {
            ngDevMode && assertDefined(newKey, 'Expecting to have a valid key');
            newIndex += 2;
            setKey = newKey;
            setValue = newValue;
        }
        if (setKey !== null) updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
        oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
        newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
    }
}
function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
    if (!(tNode.type & 3)) return;
    const tData = tView.data;
    const tRange = tData[bindingIndex + 1];
    const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : undefined;
    if (!isStylingValuePresent(higherPriorityValue)) {
        if (!isStylingValuePresent(value)) {
            if (getTStylingRangePrevDuplicate(tRange)) value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
        }
        const rNode = getNativeByIndex(getSelectedIndex(), lView);
        applyStyling(renderer, isClassBased, rNode, prop, value);
    }
}
function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
    const isPrevDirection = tNode === null;
    let value = undefined;
    while(index > 0){
        const rawKey = tData[index];
        const containsStatics = Array.isArray(rawKey);
        const key = containsStatics ? rawKey[1] : rawKey;
        const isStylingMap = key === null;
        let valueAtLViewIndex = lView[index + 1];
        if (valueAtLViewIndex === NO_CHANGE) valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : undefined;
        let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : undefined;
        if (containsStatics && !isStylingValuePresent(currentValue)) currentValue = keyValueArrayGet(rawKey, prop);
        if (isStylingValuePresent(currentValue)) {
            value = currentValue;
            if (isPrevDirection) return value;
        }
        const tRange = tData[index + 1];
        index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
    }
    if (tNode !== null) {
        let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
        if (residual != null) value = keyValueArrayGet(residual, prop);
    }
    return value;
}
function isStylingValuePresent(value) {
    return value !== undefined;
}
function normalizeSuffix(value, suffix) {
    if (value == null || value === '') ;
    else if (typeof suffix === 'string') value = value + suffix;
    else if (typeof value === 'object') value = stringify(unwrapSafeValue(value));
    return value;
}
function hasStylingInputShadow(tNode, isClassBased) {
    return (tNode.flags & (isClassBased ? 8 : 16)) !== 0;
}
function ɵɵtext(index, value = '') {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = index + HEADER_OFFSET;
    ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, 'text nodes should be created before any bindings');
    ngDevMode && assertIndexInRange(lView, adjustedIndex);
    const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];
    const textNative = _locateOrCreateTextNode(tView, lView, tNode, value, index);
    lView[adjustedIndex] = textNative;
    if (wasLastNodeCreated()) appendChild(tView, lView, textNative, tNode);
    setCurrentTNode(tNode, false);
}
let _locateOrCreateTextNode = (tView, lView, tNode, value, index)=>{
    lastNodeWasCreated(true);
    return createTextNode(lView[RENDERER], value);
};
function ɵɵtextInterpolate(v0) {
    ɵɵtextInterpolate1('', v0, '');
    return ɵɵtextInterpolate;
}
function ɵɵtextInterpolate1(prefix, v0, suffix) {
    const lView = getLView();
    const interpolated = interpolation1(lView, prefix, v0, suffix);
    if (interpolated !== NO_CHANGE) textBindingInternal(lView, getSelectedIndex(), interpolated);
    return ɵɵtextInterpolate1;
}
function ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {
    const lView = getLView();
    const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
    if (interpolated !== NO_CHANGE) textBindingInternal(lView, getSelectedIndex(), interpolated);
    return ɵɵtextInterpolate2;
}
function ɵɵtextInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
    const lView = getLView();
    const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    if (interpolated !== NO_CHANGE) textBindingInternal(lView, getSelectedIndex(), interpolated);
    return ɵɵtextInterpolate3;
}
function ɵɵtextInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
    const lView = getLView();
    const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    if (interpolated !== NO_CHANGE) textBindingInternal(lView, getSelectedIndex(), interpolated);
    return ɵɵtextInterpolate4;
}
function ɵɵtextInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
    const lView = getLView();
    const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    if (interpolated !== NO_CHANGE) textBindingInternal(lView, getSelectedIndex(), interpolated);
    return ɵɵtextInterpolate5;
}
function ɵɵtextInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
    const lView = getLView();
    const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    if (interpolated !== NO_CHANGE) textBindingInternal(lView, getSelectedIndex(), interpolated);
    return ɵɵtextInterpolate6;
}
function ɵɵtextInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
    const lView = getLView();
    const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    if (interpolated !== NO_CHANGE) textBindingInternal(lView, getSelectedIndex(), interpolated);
    return ɵɵtextInterpolate7;
}
function ɵɵtextInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
    const lView = getLView();
    const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    if (interpolated !== NO_CHANGE) textBindingInternal(lView, getSelectedIndex(), interpolated);
    return ɵɵtextInterpolate8;
}
function ɵɵtextInterpolateV(values) {
    const lView = getLView();
    const interpolated = interpolationV(lView, values);
    if (interpolated !== NO_CHANGE) textBindingInternal(lView, getSelectedIndex(), interpolated);
    return ɵɵtextInterpolateV;
}
function ɵɵclassMapInterpolate1(prefix, v0, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate2(prefix, v0, i0, v1, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolateV(values) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵstyleMapInterpolate1(prefix, v0, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate2(prefix, v0, i0, v1, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolateV(values) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    ɵɵstyleMap(interpolatedValue);
}
function ɵɵstylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return ɵɵstylePropInterpolate1;
}
function ɵɵstylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return ɵɵstylePropInterpolate2;
}
function ɵɵstylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return ɵɵstylePropInterpolate3;
}
function ɵɵstylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return ɵɵstylePropInterpolate4;
}
function ɵɵstylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return ɵɵstylePropInterpolate5;
}
function ɵɵstylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return ɵɵstylePropInterpolate6;
}
function ɵɵstylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return ɵɵstylePropInterpolate7;
}
function ɵɵstylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return ɵɵstylePropInterpolate8;
}
function ɵɵstylePropInterpolateV(prop, values, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return ɵɵstylePropInterpolateV;
}
function ɵɵhostProperty(propName, value, sanitizer) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
        const tView = getTView();
        const tNode = getSelectedTNode();
        elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);
        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
    }
    return ɵɵhostProperty;
}
function ɵɵsyntheticHostProperty(propName, value, sanitizer) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
        const tView = getTView();
        const tNode = getSelectedTNode();
        const currentDef = getCurrentDirectiveDef(tView.data);
        const renderer = loadComponentRenderer(currentDef, tNode, lView);
        elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);
        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
    }
    return ɵɵsyntheticHostProperty;
}
if (typeof ngI18nClosureMode === 'undefined') (function() {
    _global['ngI18nClosureMode'] = typeof goog !== 'undefined' && typeof goog.getMsg === 'function';
})();
const u = undefined;
function plural(val) {
    const i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\.?/, '').length;
    if (i === 1 && v === 0) return 1;
    return 5;
}
var localeEn = [
    "en",
    [
        [
            "a",
            "p"
        ],
        [
            "AM",
            "PM"
        ],
        u
    ],
    [
        [
            "AM",
            "PM"
        ],
        u,
        u
    ],
    [
        [
            "S",
            "M",
            "T",
            "W",
            "T",
            "F",
            "S"
        ],
        [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
        ],
        [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
        ],
        [
            "Su",
            "Mo",
            "Tu",
            "We",
            "Th",
            "Fr",
            "Sa"
        ]
    ],
    u,
    [
        [
            "J",
            "F",
            "M",
            "A",
            "M",
            "J",
            "J",
            "A",
            "S",
            "O",
            "N",
            "D"
        ],
        [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
        ],
        [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
        ]
    ],
    u,
    [
        [
            "B",
            "A"
        ],
        [
            "BC",
            "AD"
        ],
        [
            "Before Christ",
            "Anno Domini"
        ]
    ],
    0,
    [
        6,
        0
    ],
    [
        "M/d/yy",
        "MMM d, y",
        "MMMM d, y",
        "EEEE, MMMM d, y"
    ],
    [
        "h:mm a",
        "h:mm:ss a",
        "h:mm:ss a z",
        "h:mm:ss a zzzz"
    ],
    [
        "{1}, {0}",
        u,
        "{1} 'at' {0}",
        u
    ],
    [
        ".",
        ",",
        ";",
        "%",
        "+",
        "-",
        "E",
        "×",
        "‰",
        "∞",
        "NaN",
        ":"
    ],
    [
        "#,##0.###",
        "#,##0%",
        "¤#,##0.00",
        "#E0"
    ],
    "USD",
    "$",
    "US Dollar",
    {},
    "ltr",
    plural
];
let LOCALE_DATA = {};
function findLocaleData(locale) {
    const normalizedLocale = normalizeLocale(locale);
    let match = getLocaleData(normalizedLocale);
    if (match) return match;
    const parentLocale = normalizedLocale.split('-')[0];
    match = getLocaleData(parentLocale);
    if (match) return match;
    if (parentLocale === 'en') return localeEn;
    throw new RuntimeError(701, ngDevMode && `Missing locale data for the locale "${locale}".`);
}
function getLocalePluralCase(locale) {
    const data = findLocaleData(locale);
    return data[LocaleDataIndex.PluralCase];
}
function getLocaleData(normalizedLocale) {
    if (!(normalizedLocale in LOCALE_DATA)) LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale];
    return LOCALE_DATA[normalizedLocale];
}
var LocaleDataIndex = (()=>{
    LocaleDataIndex = LocaleDataIndex || {};
    LocaleDataIndex[LocaleDataIndex["LocaleId"] = 0] = "LocaleId";
    LocaleDataIndex[LocaleDataIndex["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
    LocaleDataIndex[LocaleDataIndex["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
    LocaleDataIndex[LocaleDataIndex["DaysFormat"] = 3] = "DaysFormat";
    LocaleDataIndex[LocaleDataIndex["DaysStandalone"] = 4] = "DaysStandalone";
    LocaleDataIndex[LocaleDataIndex["MonthsFormat"] = 5] = "MonthsFormat";
    LocaleDataIndex[LocaleDataIndex["MonthsStandalone"] = 6] = "MonthsStandalone";
    LocaleDataIndex[LocaleDataIndex["Eras"] = 7] = "Eras";
    LocaleDataIndex[LocaleDataIndex["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
    LocaleDataIndex[LocaleDataIndex["WeekendRange"] = 9] = "WeekendRange";
    LocaleDataIndex[LocaleDataIndex["DateFormat"] = 10] = "DateFormat";
    LocaleDataIndex[LocaleDataIndex["TimeFormat"] = 11] = "TimeFormat";
    LocaleDataIndex[LocaleDataIndex["DateTimeFormat"] = 12] = "DateTimeFormat";
    LocaleDataIndex[LocaleDataIndex["NumberSymbols"] = 13] = "NumberSymbols";
    LocaleDataIndex[LocaleDataIndex["NumberFormats"] = 14] = "NumberFormats";
    LocaleDataIndex[LocaleDataIndex["CurrencyCode"] = 15] = "CurrencyCode";
    LocaleDataIndex[LocaleDataIndex["CurrencySymbol"] = 16] = "CurrencySymbol";
    LocaleDataIndex[LocaleDataIndex["CurrencyName"] = 17] = "CurrencyName";
    LocaleDataIndex[LocaleDataIndex["Currencies"] = 18] = "Currencies";
    LocaleDataIndex[LocaleDataIndex["Directionality"] = 19] = "Directionality";
    LocaleDataIndex[LocaleDataIndex["PluralCase"] = 20] = "PluralCase";
    LocaleDataIndex[LocaleDataIndex["ExtraData"] = 21] = "ExtraData";
    return LocaleDataIndex;
})();
function normalizeLocale(locale) {
    return locale.toLowerCase().replace(/_/g, '-');
}
const pluralMapping = [
    'zero',
    'one',
    'two',
    'few',
    'many'
];
function getPluralCase(value, locale) {
    const plural = getLocalePluralCase(locale)(parseInt(value, 10));
    const result = pluralMapping[plural];
    return result !== undefined ? result : 'other';
}
const DEFAULT_LOCALE_ID = 'en-US';
const USD_CURRENCY_CODE = 'USD';
const ELEMENT_MARKER = {
    marker: 'element'
};
const ICU_MARKER = {
    marker: 'ICU'
};
var I18nCreateOpCode = (()=>{
    I18nCreateOpCode = I18nCreateOpCode || {};
    I18nCreateOpCode[I18nCreateOpCode["SHIFT"] = 2] = "SHIFT";
    I18nCreateOpCode[I18nCreateOpCode["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
    I18nCreateOpCode[I18nCreateOpCode["COMMENT"] = 2] = "COMMENT";
    return I18nCreateOpCode;
})();
let LOCALE_ID$1 = DEFAULT_LOCALE_ID;
function setLocaleId(localeId) {
    assertDefined(localeId, `Expected localeId to be defined`);
    if (typeof localeId === 'string') LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, '-');
}
function getLocaleId() {
    return LOCALE_ID$1;
}
function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
    const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
    const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
    if (insertBeforeIndex === null) return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
    else {
        ngDevMode && assertIndexInRange(lView, insertBeforeIndex);
        return unwrapRNode(lView[insertBeforeIndex]);
    }
}
function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
    const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
    if (Array.isArray(tNodeInsertBeforeIndex)) {
        ngDevMode && assertDomNode(childRNode);
        let i18nParent = childRNode;
        let anchorRNode = null;
        if (!(childTNode.type & 3)) {
            anchorRNode = i18nParent;
            i18nParent = parentRElement;
        }
        if (i18nParent !== null && childTNode.componentOffset === -1) for(let i = 1; i < tNodeInsertBeforeIndex.length; i++){
            const i18nChild = lView[tNodeInsertBeforeIndex[i]];
            nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
        }
    }
}
function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
    ngDevMode && assertEqual(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');
    previousTNodes.push(newTNode);
    if (previousTNodes.length > 1) for(let i = previousTNodes.length - 2; i >= 0; i--){
        const existingTNode = previousTNodes[i];
        if (!isI18nText(existingTNode)) {
            if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) setInsertBeforeIndex(existingTNode, newTNode.index);
        }
    }
}
function isI18nText(tNode) {
    return !(tNode.type & 64);
}
function isNewTNodeCreatedBefore(existingTNode, newTNode) {
    return isI18nText(newTNode) || existingTNode.index > newTNode.index;
}
function getInsertBeforeIndex(tNode) {
    const index = tNode.insertBeforeIndex;
    return Array.isArray(index) ? index[0] : index;
}
function setInsertBeforeIndex(tNode, value) {
    const index = tNode.insertBeforeIndex;
    if (Array.isArray(index)) index[0] = value;
    else {
        setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
        tNode.insertBeforeIndex = value;
    }
}
function getTIcu(tView, index) {
    const value = tView.data[index];
    if (value === null || typeof value === 'string') return null;
    if (ngDevMode && !(value.hasOwnProperty('tView') || value.hasOwnProperty('currentCaseLViewIndex'))) throwError('We expect to get \'null\'|\'TIcu\'|\'TIcuContainer\', but got: ' + value);
    const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value : value.value;
    ngDevMode && assertTIcu(tIcu);
    return tIcu;
}
function setTIcu(tView, index, tIcu) {
    const tNode = tView.data[index];
    ngDevMode && assertEqual(tNode === null || tNode.hasOwnProperty('tView'), true, 'We expect to get \'null\'|\'TIcuContainer\'');
    if (tNode === null) tView.data[index] = tIcu;
    else {
        ngDevMode && assertTNodeType(tNode, 32);
        tNode.value = tIcu;
    }
}
function setTNodeInsertBeforeIndex(tNode, index) {
    ngDevMode && assertTNode(tNode);
    let insertBeforeIndex = tNode.insertBeforeIndex;
    if (insertBeforeIndex === null) {
        setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
        insertBeforeIndex = tNode.insertBeforeIndex = [
            null,
            index
        ];
    } else {
        assertEqual(Array.isArray(insertBeforeIndex), true, 'Expecting array here');
        insertBeforeIndex.push(index);
    }
}
function createTNodePlaceholder(tView, previousTNodes, index) {
    const tNode = createTNodeAtIndex(tView, index, 64, null, null);
    addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
    return tNode;
}
function getCurrentICUCaseIndex(tIcu, lView) {
    const currentCase = lView[tIcu.currentCaseLViewIndex];
    return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
}
function getParentFromIcuCreateOpCode(mergedCode) {
    return mergedCode >>> 17;
}
function getRefFromIcuCreateOpCode(mergedCode) {
    return (mergedCode & 131070) >>> 1;
}
function getInstructionFromIcuCreateOpCode(mergedCode) {
    return mergedCode & 1;
}
function icuCreateOpCode(opCode, parentIdx, refIdx) {
    ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, 'Missing parent index');
    ngDevMode && assertGreaterThan(refIdx, 0, 'Missing ref index');
    return opCode | parentIdx << 17 | refIdx << 1;
}
let changeMask = 0b0;
let changeMaskCounter = 0;
function setMaskBit(hasChange) {
    if (hasChange) changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
    changeMaskCounter++;
}
function applyI18n(tView, lView, index) {
    if (changeMaskCounter > 0) {
        ngDevMode && assertDefined(tView, `tView should be defined`);
        const tI18n = tView.data[index];
        const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
        const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;
        applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
    }
    changeMask = 0b0;
    changeMaskCounter = 0;
}
function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
    const renderer = lView[RENDERER];
    for(let i = 0; i < createOpCodes.length; i++){
        const opCode = createOpCodes[i++];
        const text = createOpCodes[i];
        const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
        const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
        const index = opCode >>> I18nCreateOpCode.SHIFT;
        let rNode = lView[index];
        if (rNode === null) rNode = lView[index] = isComment ? renderer.createComment(text) : createTextNode(renderer, text);
        if (appendNow && parentRNode !== null) nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
    }
}
function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
    ngDevMode && assertDomNode(anchorRNode);
    const renderer = lView[RENDERER];
    let rootIdx = null;
    let rootRNode;
    for(let i = 0; i < mutableOpCodes.length; i++){
        const opCode = mutableOpCodes[i];
        if (typeof opCode == 'string') {
            const textNodeIndex = mutableOpCodes[++i];
            if (lView[textNodeIndex] === null) {
                ngDevMode && ngDevMode.rendererCreateTextNode++;
                ngDevMode && assertIndexInRange(lView, textNodeIndex);
                lView[textNodeIndex] = createTextNode(renderer, opCode);
            }
        } else if (typeof opCode == 'number') switch(opCode & 1){
            case 0:
                const parentIdx = getParentFromIcuCreateOpCode(opCode);
                if (rootIdx === null) {
                    rootIdx = parentIdx;
                    rootRNode = nativeParentNode(renderer, anchorRNode);
                }
                let insertInFrontOf;
                let parentRNode;
                if (parentIdx === rootIdx) {
                    insertInFrontOf = anchorRNode;
                    parentRNode = rootRNode;
                } else {
                    insertInFrontOf = null;
                    parentRNode = unwrapRNode(lView[parentIdx]);
                }
                if (parentRNode !== null) {
                    ngDevMode && assertDomNode(parentRNode);
                    const refIdx = getRefFromIcuCreateOpCode(opCode);
                    ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref');
                    const child = lView[refIdx];
                    ngDevMode && assertDomNode(child);
                    nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
                    const tIcu = getTIcu(tView, refIdx);
                    if (tIcu !== null && typeof tIcu === 'object') {
                        ngDevMode && assertTIcu(tIcu);
                        const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
                        if (caseIndex !== null) applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
                    }
                }
                break;
            case 1:
                const elementNodeIndex = opCode >>> 1;
                const attrName = mutableOpCodes[++i];
                const attrValue = mutableOpCodes[++i];
                setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);
                break;
            default:
                if (ngDevMode) throw new RuntimeError(700, `Unable to determine the type of mutate operation for "${opCode}"`);
        }
        else switch(opCode){
            case ICU_MARKER:
                const commentValue = mutableOpCodes[++i];
                const commentNodeIndex = mutableOpCodes[++i];
                if (lView[commentNodeIndex] === null) {
                    ngDevMode && assertEqual(typeof commentValue, 'string', `Expected "${commentValue}" to be a comment node value`);
                    ngDevMode && ngDevMode.rendererCreateComment++;
                    ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);
                    const commentRNode = lView[commentNodeIndex] = createCommentNode(renderer, commentValue);
                    attachPatchData(commentRNode, lView);
                }
                break;
            case ELEMENT_MARKER:
                const tagName = mutableOpCodes[++i];
                const elementNodeIndex1 = mutableOpCodes[++i];
                if (lView[elementNodeIndex1] === null) {
                    ngDevMode && assertEqual(typeof tagName, 'string', `Expected "${tagName}" to be an element node tag name`);
                    ngDevMode && ngDevMode.rendererCreateElement++;
                    ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex1);
                    const elementRNode = lView[elementNodeIndex1] = createElementNode(renderer, tagName, null);
                    attachPatchData(elementRNode, lView);
                }
                break;
            default:
                ngDevMode && throwError(`Unable to determine the type of mutate operation for "${opCode}"`);
        }
    }
}
function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask) {
    for(let i = 0; i < updateOpCodes.length; i++){
        const checkBit = updateOpCodes[i];
        const skipCodes = updateOpCodes[++i];
        if (checkBit & changeMask) {
            let value = '';
            for(let j = i + 1; j <= i + skipCodes; j++){
                const opCode = updateOpCodes[j];
                if (typeof opCode == 'string') value += opCode;
                else if (typeof opCode == 'number') {
                    if (opCode < 0) value += renderStringify(lView[bindingsStartIndex - opCode]);
                    else {
                        const nodeIndex = opCode >>> 2;
                        switch(opCode & 3){
                            case 1:
                                const propName = updateOpCodes[++j];
                                const sanitizeFn = updateOpCodes[++j];
                                const tNodeOrTagName = tView.data[nodeIndex];
                                ngDevMode && assertDefined(tNodeOrTagName, 'Experting TNode or string');
                                if (typeof tNodeOrTagName === 'string') setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
                                else elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);
                                break;
                            case 0:
                                const rText = lView[nodeIndex];
                                rText !== null && updateTextNode(lView[RENDERER], rText, value);
                                break;
                            case 2:
                                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                                break;
                            case 3:
                                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                                break;
                        }
                    }
                }
            }
        } else {
            const opCode = updateOpCodes[i + 1];
            if (opCode > 0 && (opCode & 3) === 3) {
                const nodeIndex = opCode >>> 2;
                const tIcu = getTIcu(tView, nodeIndex);
                const currentIndex = lView[tIcu.currentCaseLViewIndex];
                if (currentIndex < 0) applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
            }
        }
        i += skipCodes;
    }
}
function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
    ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);
    let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
    if (activeCaseIndex !== null) {
        let mask = changeMask;
        if (activeCaseIndex < 0) {
            activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
            mask = -1;
        }
        applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
    }
}
function applyIcuSwitchCase(tView, tIcu, lView, value) {
    const caseIndex = getCaseIndex(tIcu, value);
    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
    if (activeCaseIndex !== caseIndex) {
        applyIcuSwitchCaseRemove(tView, tIcu, lView);
        lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
        if (caseIndex !== null) {
            const anchorRNode = lView[tIcu.anchorIdx];
            if (anchorRNode) {
                ngDevMode && assertDomNode(anchorRNode);
                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
            }
        }
    }
}
function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
    if (activeCaseIndex !== null) {
        const removeCodes = tIcu.remove[activeCaseIndex];
        for(let i = 0; i < removeCodes.length; i++){
            const nodeOrIcuIndex = removeCodes[i];
            if (nodeOrIcuIndex > 0) {
                const rNode = getNativeByIndex(nodeOrIcuIndex, lView);
                rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);
            } else applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
        }
    }
}
function getCaseIndex(icuExpression, bindingValue) {
    let index = icuExpression.cases.indexOf(bindingValue);
    if (index === -1) switch(icuExpression.type){
        case 1:
            {
                const resolvedCase = getPluralCase(bindingValue, getLocaleId());
                index = icuExpression.cases.indexOf(resolvedCase);
                if (index === -1 && resolvedCase !== 'other') index = icuExpression.cases.indexOf('other');
                break;
            }
        case 0:
            index = icuExpression.cases.indexOf('other');
            break;
    }
    return index === -1 ? null : index;
}
function loadIcuContainerVisitor() {
    const _stack = [];
    let _index = -1;
    let _lView;
    let _removes;
    function icuContainerIteratorStart(tIcuContainerNode, lView) {
        _lView = lView;
        while(_stack.length)_stack.pop();
        ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);
        enterIcu(tIcuContainerNode.value, lView);
        return icuContainerIteratorNext;
    }
    function enterIcu(tIcu, lView) {
        _index = 0;
        const currentCase = getCurrentICUCaseIndex(tIcu, lView);
        if (currentCase !== null) {
            ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);
            _removes = tIcu.remove[currentCase];
        } else _removes = EMPTY_ARRAY;
    }
    function icuContainerIteratorNext() {
        if (_index < _removes.length) {
            const removeOpCode = _removes[_index++];
            ngDevMode && assertNumber(removeOpCode, 'Expecting OpCode number');
            if (removeOpCode > 0) {
                const rNode = _lView[removeOpCode];
                ngDevMode && assertDomNode(rNode);
                return rNode;
            } else {
                _stack.push(_index, _removes);
                const tIcuIndex = ~removeOpCode;
                const tIcu = _lView[TVIEW].data[tIcuIndex];
                ngDevMode && assertTIcu(tIcu);
                enterIcu(tIcu, _lView);
                return icuContainerIteratorNext();
            }
        } else {
            if (_stack.length === 0) return null;
            else {
                _removes = _stack.pop();
                _index = _stack.pop();
                return icuContainerIteratorNext();
            }
        }
    }
    return icuContainerIteratorStart;
}
function i18nCreateOpCodesToString(opcodes) {
    const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
    let lines = [];
    for(let i = 0; i < createOpCodes.length; i++){
        const opCode = createOpCodes[i++];
        const text = createOpCodes[i];
        const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
        const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
        const index = opCode >>> I18nCreateOpCode.SHIFT;
        lines.push(`lView[${index}] = document.${isComment ? 'createComment' : 'createText'}(${JSON.stringify(text)});`);
        if (appendNow) lines.push(`parent.appendChild(lView[${index}]);`);
    }
    return lines;
}
function i18nUpdateOpCodesToString(opcodes) {
    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
    let lines = [];
    function consumeOpCode(value) {
        const ref = value >>> 2;
        const opCode = value & 3;
        switch(opCode){
            case 0:
                return `(lView[${ref}] as Text).textContent = $$$`;
            case 1:
                const attrName = parser.consumeString();
                const sanitizationFn = parser.consumeFunction();
                const value1 = sanitizationFn ? `(${sanitizationFn})($$$)` : '$$$';
                return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value1})`;
            case 2:
                return `icuSwitchCase(${ref}, $$$)`;
            case 3:
                return `icuUpdateCase(${ref})`;
        }
        throw new Error('unexpected OpCode');
    }
    while(parser.hasMore()){
        let mask = parser.consumeNumber();
        let size = parser.consumeNumber();
        const end = parser.i + size;
        const statements = [];
        let statement = '';
        while(parser.i < end){
            let value = parser.consumeNumberOrString();
            if (typeof value === 'string') statement += value;
            else if (value < 0) statement += '${lView[i' + value + ']}';
            else {
                const opCodeText = consumeOpCode(value);
                statements.push(opCodeText.replace('$$$', '`' + statement + '`') + ';');
                statement = '';
            }
        }
        lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(' ')} }`);
    }
    return lines;
}
function icuCreateOpCodesToString(opcodes) {
    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
    let lines = [];
    function consumeOpCode(opCode) {
        const parent = getParentFromIcuCreateOpCode(opCode);
        const ref = getRefFromIcuCreateOpCode(opCode);
        switch(getInstructionFromIcuCreateOpCode(opCode)){
            case 0:
                return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
            case 1:
                return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
        }
        throw new Error('Unexpected OpCode: ' + getInstructionFromIcuCreateOpCode(opCode));
    }
    let lastRef = -1;
    while(parser.hasMore()){
        let value = parser.consumeNumberStringOrMarker();
        if (value === ICU_MARKER) {
            const text = parser.consumeString();
            lastRef = parser.consumeNumber();
            lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
        } else if (value === ELEMENT_MARKER) {
            const text = parser.consumeString();
            lastRef = parser.consumeNumber();
            lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
        } else if (typeof value === 'string') {
            lastRef = parser.consumeNumber();
            lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
        } else if (typeof value === 'number') {
            const line = consumeOpCode(value);
            line && lines.push(line);
        } else throw new Error('Unexpected value');
    }
    return lines;
}
function i18nRemoveOpCodesToString(opcodes) {
    const removeCodes = opcodes || (Array.isArray(this) ? this : []);
    let lines = [];
    for(let i = 0; i < removeCodes.length; i++){
        const nodeOrIcuIndex = removeCodes[i];
        if (nodeOrIcuIndex > 0) lines.push(`remove(lView[${nodeOrIcuIndex}])`);
        else lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
    }
    return lines;
}
class OpCodeParser {
    hasMore() {
        return this.i < this.codes.length;
    }
    consumeNumber() {
        let value = this.codes[this.i++];
        assertNumber(value, 'expecting number in OpCode');
        return value;
    }
    consumeString() {
        let value = this.codes[this.i++];
        assertString(value, 'expecting string in OpCode');
        return value;
    }
    consumeFunction() {
        let value = this.codes[this.i++];
        if (value === null || typeof value === 'function') return value;
        throw new Error('expecting function in OpCode');
    }
    consumeNumberOrString() {
        let value = this.codes[this.i++];
        if (typeof value === 'string') return value;
        assertNumber(value, 'expecting number or string in OpCode');
        return value;
    }
    consumeNumberStringOrMarker() {
        let value = this.codes[this.i++];
        if (typeof value === 'string' || typeof value === 'number' || value == ICU_MARKER || value == ELEMENT_MARKER) return value;
        assertNumber(value, 'expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode');
        return value;
    }
    constructor(codes){
        this.i = 0;
        this.codes = codes;
    }
}
const BINDING_REGEXP = /�(\d+):?\d*�/gi;
const ICU_REGEXP = /({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi;
const NESTED_ICU = /�(\d+)�/;
const ICU_BLOCK_REGEXP = /^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/;
const MARKER = `�`;
const SUBTEMPLATE_REGEXP = /�\/?\*(\d+:\d+)�/gi;
const PH_REGEXP = /�(\/?[#*]\d+):?\d*�/gi;
const NGSP_UNICODE_REGEXP = /\uE500/g;
function replaceNgsp(value) {
    return value.replace(NGSP_UNICODE_REGEXP, ' ');
}
function attachDebugGetter(obj, debugGetter) {
    if (ngDevMode) Object.defineProperty(obj, 'debug', {
        get: debugGetter,
        enumerable: false
    });
    else throw new Error('This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');
}
function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
    const rootTNode = getCurrentParentTNode();
    const createOpCodes = [];
    const updateOpCodes = [];
    const existingTNodeStack = [
        []
    ];
    if (ngDevMode) {
        attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
        attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
    }
    message = getTranslationForTemplate(message, subTemplateIndex);
    const msgParts = replaceNgsp(message).split(PH_REGEXP);
    for(let i = 0; i < msgParts.length; i++){
        let value = msgParts[i];
        if ((i & 1) === 0) {
            const parts = i18nParseTextIntoPartsAndICU(value);
            for(let j = 0; j < parts.length; j++){
                let part = parts[j];
                if ((j & 1) === 0) {
                    const text = part;
                    ngDevMode && assertString(text, 'Parsed ICU part should be string');
                    if (text !== '') i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
                } else {
                    const icuExpression = part;
                    if (typeof icuExpression !== 'object') throw new Error(`Unable to parse ICU expression in "${message}" message.`);
                    const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);
                    const icuNodeIndex = icuContainerTNode.index;
                    ngDevMode && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, 'Index must be in absolute LView offset');
                    icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
                }
            }
        } else {
            const isClosing = value.charCodeAt(0) === 47;
            const type = value.charCodeAt(isClosing ? 1 : 0);
            ngDevMode && assertOneOf(type, 42, 35);
            const index = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
            if (isClosing) {
                existingTNodeStack.shift();
                setCurrentTNode(getCurrentParentTNode(), false);
            } else {
                const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);
                existingTNodeStack.unshift([]);
                setCurrentTNode(tNode, true);
            }
        }
    }
    tView.data[index] = {
        create: createOpCodes,
        update: updateOpCodes
    };
}
function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
    const i18nNodeIdx = allocExpando(tView, lView, 1, null);
    let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
    let parentTNode = getCurrentParentTNode();
    if (rootTNode === parentTNode) parentTNode = null;
    if (parentTNode === null) opCode |= I18nCreateOpCode.APPEND_EAGERLY;
    if (isICU) {
        opCode |= I18nCreateOpCode.COMMENT;
        ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
    }
    createOpCodes.push(opCode, text === null ? '' : text);
    const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? '{{?}}' : '' : text, null);
    addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
    const tNodeIdx = tNode.index;
    setCurrentTNode(tNode, false);
    if (parentTNode !== null && rootTNode !== parentTNode) setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
    return tNode;
}
function i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
    const hasBinding = text.match(BINDING_REGEXP);
    const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
    if (hasBinding) generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);
}
function i18nAttributesFirstPass(tView, index, values) {
    const previousElement = getCurrentTNode();
    const previousElementIndex = previousElement.index;
    const updateOpCodes = [];
    if (ngDevMode) attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
    if (tView.firstCreatePass && tView.data[index] === null) {
        for(let i = 0; i < values.length; i += 2){
            const attrName = values[i];
            const message = values[i + 1];
            if (message !== '') {
                if (ICU_REGEXP.test(message)) throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
                generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
            }
        }
        tView.data[index] = updateOpCodes;
    }
}
function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
    ngDevMode && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, 'Index must be in absolute LView offset');
    const maskIndex = updateOpCodes.length;
    const sizeIndex = maskIndex + 1;
    updateOpCodes.push(null, null);
    const startIndex = maskIndex + 2;
    if (ngDevMode) attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
    const textParts = str.split(BINDING_REGEXP);
    let mask = 0;
    for(let j = 0; j < textParts.length; j++){
        const textValue = textParts[j];
        if (j & 1) {
            const bindingIndex = bindingStart + parseInt(textValue, 10);
            updateOpCodes.push(-1 - bindingIndex);
            mask = mask | toMaskBit(bindingIndex);
        } else if (textValue !== '') updateOpCodes.push(textValue);
    }
    updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
    if (attrName) updateOpCodes.push(attrName, sanitizeFn);
    updateOpCodes[maskIndex] = mask;
    updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
    return mask;
}
function countBindings(opCodes) {
    let count = 0;
    for(let i = 0; i < opCodes.length; i++){
        const opCode = opCodes[i];
        if (typeof opCode === 'number' && opCode < 0) count++;
    }
    return count;
}
function toMaskBit(bindingIndex) {
    return 1 << Math.min(bindingIndex, 31);
}
function isRootTemplateMessage(subTemplateIndex) {
    return subTemplateIndex === -1;
}
function removeInnerTemplateTranslation(message) {
    let match;
    let res = '';
    let index = 0;
    let inTemplate = false;
    let tagMatched;
    while((match = SUBTEMPLATE_REGEXP.exec(message)) !== null){
        if (!inTemplate) {
            res += message.substring(index, match.index + match[0].length);
            tagMatched = match[1];
            inTemplate = true;
        } else if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
            index = match.index;
            inTemplate = false;
        }
    }
    ngDevMode && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`);
    res += message.slice(index);
    return res;
}
function getTranslationForTemplate(message, subTemplateIndex) {
    if (isRootTemplateMessage(subTemplateIndex)) return removeInnerTemplateTranslation(message);
    else {
        const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
        const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
        return removeInnerTemplateTranslation(message.substring(start, end));
    }
}
function icuStart(tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
    ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');
    let bindingMask = 0;
    const tIcu = {
        type: icuExpression.type,
        currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
        anchorIdx,
        cases: [],
        create: [],
        remove: [],
        update: []
    };
    addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
    setTIcu(tView, anchorIdx, tIcu);
    const values = icuExpression.values;
    for(let i = 0; i < values.length; i++){
        const valueArr = values[i];
        const nestedIcus = [];
        for(let j = 0; j < valueArr.length; j++){
            const value = valueArr[j];
            if (typeof value !== 'string') {
                const icuIndex = nestedIcus.push(value) - 1;
                valueArr[j] = `<!--�${icuIndex}�-->`;
            }
        }
        bindingMask = parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(''), nestedIcus) | bindingMask;
    }
    if (bindingMask) addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
}
function parseICUBlock(pattern) {
    const cases = [];
    const values = [];
    let icuType = 1;
    let mainBinding = 0;
    pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type) {
        if (type === 'select') icuType = 0;
        else icuType = 1;
        mainBinding = parseInt(binding.slice(1), 10);
        return '';
    });
    const parts = i18nParseTextIntoPartsAndICU(pattern);
    for(let pos = 0; pos < parts.length;){
        let key = parts[pos++].trim();
        if (icuType === 1) key = key.replace(/\s*(?:=)?(\w+)\s*/, '$1');
        if (key.length) cases.push(key);
        const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
        if (cases.length > values.length) values.push(blocks);
    }
    return {
        type: icuType,
        mainBinding: mainBinding,
        cases,
        values
    };
}
function i18nParseTextIntoPartsAndICU(pattern) {
    if (!pattern) return [];
    let prevPos = 0;
    const braceStack = [];
    const results = [];
    const braces = /[{}]/g;
    braces.lastIndex = 0;
    let match;
    while(match = braces.exec(pattern)){
        const pos = match.index;
        if (match[0] == '}') {
            braceStack.pop();
            if (braceStack.length == 0) {
                const block = pattern.substring(prevPos, pos);
                if (ICU_BLOCK_REGEXP.test(block)) results.push(parseICUBlock(block));
                else results.push(block);
                prevPos = pos + 1;
            }
        } else {
            if (braceStack.length == 0) {
                const substring = pattern.substring(prevPos, pos);
                results.push(substring);
                prevPos = pos + 1;
            }
            braceStack.push('{');
        }
    }
    const substring = pattern.substring(prevPos);
    results.push(substring);
    return results;
}
function parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
    const create = [];
    const remove = [];
    const update = [];
    if (ngDevMode) {
        attachDebugGetter(create, icuCreateOpCodesToString);
        attachDebugGetter(remove, i18nRemoveOpCodesToString);
        attachDebugGetter(update, i18nUpdateOpCodesToString);
    }
    tIcu.cases.push(caseName);
    tIcu.create.push(create);
    tIcu.remove.push(remove);
    tIcu.update.push(update);
    const inertBodyHelper = getInertBodyHelper(getDocument());
    const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);
    ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');
    const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
    if (inertRootNode) return walkIcuTree(tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx, nestedIcus, 0);
    else return 0;
}
function walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, parentNode, parentIdx, nestedIcus, depth) {
    let bindingMask = 0;
    let currentNode = parentNode.firstChild;
    while(currentNode){
        const newIndex = allocExpando(tView, lView, 1, null);
        switch(currentNode.nodeType){
            case Node.ELEMENT_NODE:
                const element = currentNode;
                const tagName = element.tagName.toLowerCase();
                if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
                    addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
                    tView.data[newIndex] = tagName;
                    const elAttrs = element.attributes;
                    for(let i = 0; i < elAttrs.length; i++){
                        const attr = elAttrs.item(i);
                        const lowerAttrName = attr.name.toLowerCase();
                        const hasBinding = !!attr.value.match(BINDING_REGEXP);
                        if (hasBinding) {
                            if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                                if (URI_ATTRS[lowerAttrName]) generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                                else generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                            } else ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ` + `${lowerAttrName} on element ${tagName} ` + `(see ${XSS_SECURITY_URL})`);
                        } else addCreateAttribute(create, newIndex, attr);
                    }
                    bindingMask = walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
                    addRemoveNode(remove, newIndex, depth);
                }
                break;
            case Node.TEXT_NODE:
                const value = currentNode.textContent || '';
                const hasBinding = value.match(BINDING_REGEXP);
                addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);
                addRemoveNode(remove, newIndex, depth);
                if (hasBinding) bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
                break;
            case Node.COMMENT_NODE:
                const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');
                if (isNestedIcu) {
                    const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
                    const icuExpression = nestedIcus[nestedIcuIndex];
                    addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx, newIndex);
                    icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
                    addRemoveNestedIcu(remove, newIndex, depth);
                }
                break;
        }
        currentNode = currentNode.nextSibling;
    }
    return bindingMask;
}
function addRemoveNode(remove, index, depth) {
    if (depth === 0) remove.push(index);
}
function addRemoveNestedIcu(remove, index, depth) {
    if (depth === 0) {
        remove.push(~index);
        remove.push(index);
    }
}
function addUpdateIcuSwitch(update, icuExpression, index) {
    update.push(toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding, index << 2 | 2);
}
function addUpdateIcuUpdate(update, bindingMask, index) {
    update.push(bindingMask, 1, index << 2 | 3);
}
function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
    if (marker !== null) create.push(marker);
    create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
}
function addCreateAttribute(create, newIndex, attr) {
    create.push(newIndex << 1 | 1, attr.name, attr.value);
}
const ROOT_TEMPLATE_ID = 0;
const PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]/;
const PP_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]|(�\/?\*\d+:\d+�)/g;
const PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
const PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
const PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\d+)?)�/g;
const PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
const PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
function i18nPostprocess(message, replacements = {}) {
    let result = message;
    if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
        const matches = {};
        const templateIdsStack = [
            ROOT_TEMPLATE_ID
        ];
        result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl)=>{
            const content = phs || tmpl;
            const placeholders = matches[content] || [];
            if (!placeholders.length) {
                content.split('|').forEach((placeholder)=>{
                    const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);
                    const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;
                    const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);
                    placeholders.push([
                        templateId,
                        isCloseTemplateTag,
                        placeholder
                    ]);
                });
                matches[content] = placeholders;
            }
            if (!placeholders.length) throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
            const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
            let idx = 0;
            for(let i = 0; i < placeholders.length; i++)if (placeholders[i][0] === currentTemplateId) {
                idx = i;
                break;
            }
            const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
            if (isCloseTemplateTag) templateIdsStack.pop();
            else if (currentTemplateId !== templateId) templateIdsStack.push(templateId);
            placeholders.splice(idx, 1);
            return placeholder;
        });
    }
    if (!Object.keys(replacements).length) return result;
    result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end)=>{
        return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;
    });
    result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key)=>{
        return replacements.hasOwnProperty(key) ? replacements[key] : match;
    });
    result = result.replace(PP_ICUS_REGEXP, (match, key)=>{
        if (replacements.hasOwnProperty(key)) {
            const list = replacements[key];
            if (!list.length) throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);
            return list.shift();
        }
        return match;
    });
    return result;
}
function ɵɵi18nStart(index, messageIndex, subTemplateIndex = -1) {
    const tView = getTView();
    const lView = getLView();
    const adjustedIndex = HEADER_OFFSET + index;
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const message = getConstant(tView.consts, messageIndex);
    const parentTNode = getCurrentParentTNode();
    if (tView.firstCreatePass) i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
    if (tView.type === 2) {
        const componentLView = lView[DECLARATION_COMPONENT_VIEW];
        componentLView[FLAGS] |= 32;
    } else lView[FLAGS] |= 32;
    const tI18n = tView.data[adjustedIndex];
    const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;
    const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
    const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
    applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
    setInI18nBlock(true);
}
function ɵɵi18nEnd() {
    setInI18nBlock(false);
}
function ɵɵi18n(index, messageIndex, subTemplateIndex) {
    ɵɵi18nStart(index, messageIndex, subTemplateIndex);
    ɵɵi18nEnd();
}
function ɵɵi18nAttributes(index, attrsIndex) {
    const tView = getTView();
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const attrs = getConstant(tView.consts, attrsIndex);
    i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);
}
function ɵɵi18nExp(value) {
    const lView = getLView();
    setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));
    return ɵɵi18nExp;
}
function ɵɵi18nApply(index) {
    applyI18n(getTView(), getLView(), index + HEADER_OFFSET);
}
function ɵɵi18nPostprocess(message, replacements = {}) {
    return i18nPostprocess(message, replacements);
}
function providersResolver(def, providers, viewProviders) {
    const tView = getTView();
    if (tView.firstCreatePass) {
        const isComponent = isComponentDef(def);
        resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent, true);
        resolveProvider(providers, tView.data, tView.blueprint, isComponent, false);
    }
}
function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {
    provider = resolveForwardRef(provider);
    if (Array.isArray(provider)) for(let i = 0; i < provider.length; i++)resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);
    else {
        const tView = getTView();
        const lView = getLView();
        let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
        let providerFactory = providerToFactory(provider);
        const tNode = getCurrentTNode();
        const beginIndex = tNode.providerIndexes & 1048575;
        const endIndex = tNode.directiveStart;
        const cptViewProvidersCount = tNode.providerIndexes >> 20;
        if (isTypeProvider(provider) || !provider.multi) {
            const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject);
            const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
            if (existingFactoryIndex === -1) {
                diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
                registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
                tInjectables.push(token);
                tNode.directiveStart++;
                tNode.directiveEnd++;
                if (isViewProvider) tNode.providerIndexes += 1048576;
                lInjectablesBlueprint.push(factory);
                lView.push(factory);
            } else {
                lInjectablesBlueprint[existingFactoryIndex] = factory;
                lView[existingFactoryIndex] = factory;
            }
        } else {
            const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
            const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
            const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
            const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
            if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
                diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
                const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);
                if (!isViewProvider && doesViewProvidersFactoryExist) lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
                registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
                tInjectables.push(token);
                tNode.directiveStart++;
                tNode.directiveEnd++;
                if (isViewProvider) tNode.providerIndexes += 1048576;
                lInjectablesBlueprint.push(factory);
                lView.push(factory);
            } else {
                const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);
                registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
            }
            if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
        }
    }
}
function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
    const providerIsTypeProvider = isTypeProvider(provider);
    const providerIsClassProvider = isClassProvider(provider);
    if (providerIsTypeProvider || providerIsClassProvider) {
        const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;
        const prototype = classToken.prototype;
        const ngOnDestroy = prototype.ngOnDestroy;
        if (ngOnDestroy) {
            const hooks = tView.destroyHooks || (tView.destroyHooks = []);
            if (!providerIsTypeProvider && provider.multi) {
                ngDevMode && assertDefined(indexInFactory, 'indexInFactory when registering multi factory destroy hook');
                const existingCallbacksIndex = hooks.indexOf(contextIndex);
                if (existingCallbacksIndex === -1) hooks.push(contextIndex, [
                    indexInFactory,
                    ngOnDestroy
                ]);
                else hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
            } else hooks.push(contextIndex, ngOnDestroy);
        }
    }
}
function multiFactoryAdd(multiFactory, factory, isComponentProvider) {
    if (isComponentProvider) multiFactory.componentProviders++;
    return multiFactory.multi.push(factory) - 1;
}
function indexOf(item, arr, begin, end) {
    for(let i = begin; i < end; i++){
        if (arr[i] === item) return i;
    }
    return -1;
}
function multiProvidersFactoryResolver(_, tData, lData, tNode) {
    return multiResolve(this.multi, []);
}
function multiViewProvidersFactoryResolver(_, tData, lView, tNode) {
    const factories = this.multi;
    let result;
    if (this.providerFactory) {
        const componentCount = this.providerFactory.componentProviders;
        const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);
        result = multiProviders.slice(0, componentCount);
        multiResolve(factories, result);
        for(let i = componentCount; i < multiProviders.length; i++)result.push(multiProviders[i]);
    } else {
        result = [];
        multiResolve(factories, result);
    }
    return result;
}
function multiResolve(factories, result) {
    for(let i = 0; i < factories.length; i++){
        const factory = factories[i];
        result.push(factory());
    }
    return result;
}
function multiFactory(factoryFn, index, isViewProvider, isComponent, f) {
    const factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject);
    factory.multi = [];
    factory.index = index;
    factory.componentProviders = 0;
    multiFactoryAdd(factory, f, isComponent && !isViewProvider);
    return factory;
}
function ɵɵProvidersFeature(providers, viewProviders = []) {
    return (definition)=>{
        definition.providersResolver = (def, processProvidersFn)=>{
            return providersResolver(def, processProvidersFn ? processProvidersFn(providers) : providers, viewProviders);
        };
    };
}
class NgModuleRef$1 {
}
class NgModuleFactory$1 {
}
function createNgModule(ngModule, parentInjector) {
    return new NgModuleRef(ngModule, parentInjector !== null && parentInjector !== void 0 ? parentInjector : null, []);
}
class NgModuleRef extends NgModuleRef$1 {
    get injector() {
        return this._r3Injector;
    }
    destroy() {
        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');
        const injector = this._r3Injector;
        !injector.destroyed && injector.destroy();
        this.destroyCbs.forEach((fn)=>fn());
        this.destroyCbs = null;
    }
    onDestroy(callback) {
        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');
        this.destroyCbs.push(callback);
    }
    constructor(ngModuleType, _parent, additionalProviders){
        super();
        this._parent = _parent;
        this._bootstrapComponents = [];
        this.destroyCbs = [];
        this.componentFactoryResolver = new ComponentFactoryResolver(this);
        const ngModuleDef = getNgModuleDef(ngModuleType);
        ngDevMode && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
        this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
        this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [
            {
                provide: NgModuleRef$1,
                useValue: this
            },
            {
                provide: ComponentFactoryResolver$1,
                useValue: this.componentFactoryResolver
            },
            ...additionalProviders
        ], stringify(ngModuleType), new Set([
            'environment'
        ]));
        this._r3Injector.resolveInjectorInitializers();
        this.instance = this._r3Injector.get(ngModuleType);
    }
}
class NgModuleFactory extends NgModuleFactory$1 {
    create(parentInjector) {
        return new NgModuleRef(this.moduleType, parentInjector, []);
    }
    constructor(moduleType){
        super();
        this.moduleType = moduleType;
    }
}
function createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {
    return new NgModuleRef(moduleType, parentInjector, additionalProviders);
}
class EnvironmentNgModuleRefAdapter extends NgModuleRef$1 {
    destroy() {
        this.injector.destroy();
    }
    onDestroy(callback) {
        this.injector.onDestroy(callback);
    }
    constructor(config){
        super();
        this.componentFactoryResolver = new ComponentFactoryResolver(this);
        this.instance = null;
        const injector = new R3Injector([
            ...config.providers,
            {
                provide: NgModuleRef$1,
                useValue: this
            },
            {
                provide: ComponentFactoryResolver$1,
                useValue: this.componentFactoryResolver
            }
        ], config.parent || getNullInjector(), config.debugName, new Set([
            'environment'
        ]));
        this.injector = injector;
        if (config.runEnvironmentInitializers) injector.resolveInjectorInitializers();
    }
}
function createEnvironmentInjector(providers, parent, debugName = null) {
    const adapter = new EnvironmentNgModuleRefAdapter({
        providers,
        parent,
        debugName,
        runEnvironmentInitializers: true
    });
    return adapter.injector;
}
let StandaloneService = (()=>{
    class StandaloneService {
        getOrCreateStandaloneInjector(componentDef) {
            if (!componentDef.standalone) return null;
            if (!this.cachedInjectors.has(componentDef.id)) {
                const providers = internalImportProvidersFrom(false, componentDef.type);
                const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([
                    providers
                ], this._injector, `Standalone[${componentDef.type.name}]`) : null;
                this.cachedInjectors.set(componentDef.id, standaloneInjector);
            }
            return this.cachedInjectors.get(componentDef.id);
        }
        ngOnDestroy() {
            try {
                for (const injector of this.cachedInjectors.values())if (injector !== null) injector.destroy();
            } finally{
                this.cachedInjectors.clear();
            }
        }
        constructor(_injector){
            this._injector = _injector;
            this.cachedInjectors = new Map();
        }
    }
    StandaloneService.ɵprov = ɵɵdefineInjectable({
        token: StandaloneService,
        providedIn: 'environment',
        factory: ()=>new StandaloneService(ɵɵinject(EnvironmentInjector))
    });
    return StandaloneService;
})();
function ɵɵStandaloneFeature(definition) {
    definition.getStandaloneInjector = (parentInjector)=>{
        return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition);
    };
}
function getComponent(element) {
    ngDevMode && assertDomElement(element);
    const context = getLContext(element);
    if (context === null) return null;
    if (context.component === undefined) {
        const lView = context.lView;
        if (lView === null) return null;
        context.component = getComponentAtNodeIndex(context.nodeIndex, lView);
    }
    return context.component;
}
function getContext(element) {
    assertDomElement(element);
    const context = getLContext(element);
    const lView = context ? context.lView : null;
    return lView === null ? null : lView[CONTEXT];
}
function getOwningComponent(elementOrDir) {
    const context = getLContext(elementOrDir);
    let lView = context ? context.lView : null;
    if (lView === null) return null;
    let parent;
    while(lView[TVIEW].type === 2 && (parent = getLViewParent(lView)))lView = parent;
    return lView[FLAGS] & 512 ? null : lView[CONTEXT];
}
function getRootComponents(elementOrDir) {
    const lView = readPatchedLView(elementOrDir);
    return lView !== null ? [
        getRootContext(lView)
    ] : [];
}
function getInjector(elementOrDir) {
    const context = getLContext(elementOrDir);
    const lView = context ? context.lView : null;
    if (lView === null) return Injector.NULL;
    const tNode = lView[TVIEW].data[context.nodeIndex];
    return new NodeInjector(tNode, lView);
}
function getDirectives(node) {
    if (node instanceof Text) return [];
    const context = getLContext(node);
    const lView = context ? context.lView : null;
    if (lView === null) return [];
    const tView = lView[TVIEW];
    const nodeIndex = context.nodeIndex;
    if (!(tView === null || tView === void 0 ? void 0 : tView.data[nodeIndex])) return [];
    if (context.directives === undefined) context.directives = getDirectivesAtNodeIndex(nodeIndex, lView);
    return context.directives === null ? [] : [
        ...context.directives
    ];
}
function getDirectiveMetadata$1(directiveOrComponentInstance) {
    const { constructor  } = directiveOrComponentInstance;
    if (!constructor) throw new Error('Unable to find the instance constructor');
    const componentDef = getComponentDef(constructor);
    if (componentDef) return {
        inputs: componentDef.inputs,
        outputs: componentDef.outputs,
        encapsulation: componentDef.encapsulation,
        changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
    };
    const directiveDef = getDirectiveDef(constructor);
    if (directiveDef) return {
        inputs: directiveDef.inputs,
        outputs: directiveDef.outputs
    };
    return null;
}
function getHostElement(componentOrDirective) {
    return getLContext(componentOrDirective).native;
}
function getListeners(element) {
    ngDevMode && assertDomElement(element);
    const lContext = getLContext(element);
    const lView = lContext === null ? null : lContext.lView;
    if (lView === null) return [];
    const tView = lView[TVIEW];
    const lCleanup = lView[CLEANUP];
    const tCleanup = tView.cleanup;
    const listeners = [];
    if (tCleanup && lCleanup) for(let i = 0; i < tCleanup.length;){
        const firstParam = tCleanup[i++];
        const secondParam = tCleanup[i++];
        if (typeof firstParam === 'string') {
            const name = firstParam;
            const listenerElement = unwrapRNode(lView[secondParam]);
            const callback = lCleanup[tCleanup[i++]];
            const useCaptureOrIndx = tCleanup[i++];
            const type = typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0 ? 'dom' : 'output';
            const useCapture = typeof useCaptureOrIndx === 'boolean' ? useCaptureOrIndx : false;
            if (element == listenerElement) listeners.push({
                element,
                name,
                callback,
                useCapture,
                type
            });
        }
    }
    listeners.sort(sortListeners);
    return listeners;
}
function sortListeners(a, b) {
    if (a.name == b.name) return 0;
    return a.name < b.name ? -1 : 1;
}
function assertDomElement(value) {
    if (typeof Element !== 'undefined' && !(value instanceof Element)) throw new Error('Expecting instance of DOM Element');
}
function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
    return noSideEffects(()=>{
        const clazz = type;
        if (decorators !== null) {
            if (clazz.hasOwnProperty('decorators') && clazz.decorators !== undefined) clazz.decorators.push(...decorators);
            else clazz.decorators = decorators;
        }
        if (ctorParameters !== null) clazz.ctorParameters = ctorParameters;
        if (propDecorators !== null) {
            if (clazz.hasOwnProperty('propDecorators') && clazz.propDecorators !== undefined) clazz.propDecorators = _object_spread._({}, clazz.propDecorators, propDecorators);
            else clazz.propDecorators = propDecorators;
        }
    });
}
function ɵɵpureFunction0(slotOffset, pureFn, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
}
function ɵɵpureFunction1(slotOffset, pureFn, exp, thisArg) {
    return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);
}
function ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
    return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);
}
function ɵɵpureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
    return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
}
function ɵɵpureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
    return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
}
function ɵɵpureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
}
function ɵɵpureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
}
function ɵɵpureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
}
function ɵɵpureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
}
function ɵɵpureFunctionV(slotOffset, pureFn, exps, thisArg) {
    return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);
}
function getPureFunctionReturnValue(lView, returnValueIndex) {
    ngDevMode && assertIndexInRange(lView, returnValueIndex);
    const lastReturnValue = lView[returnValueIndex];
    return lastReturnValue === NO_CHANGE ? undefined : lastReturnValue;
}
function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
}
function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
}
function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
}
function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
}
function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
    let bindingIndex = bindingRoot + slotOffset;
    let different = false;
    for(let i = 0; i < exps.length; i++)bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
    return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
}
function ɵɵpipe(index, pipeName) {
    const tView = getTView();
    let pipeDef;
    const adjustedIndex = index + HEADER_OFFSET;
    if (tView.firstCreatePass) {
        pipeDef = getPipeDef(pipeName, tView.pipeRegistry);
        tView.data[adjustedIndex] = pipeDef;
        if (pipeDef.onDestroy) {
            var _tView;
            var _destroyHooks;
            ((_destroyHooks = (_tView = tView).destroyHooks) !== null && _destroyHooks !== void 0 ? _destroyHooks : _tView.destroyHooks = []).push(adjustedIndex, pipeDef.onDestroy);
        }
    } else pipeDef = tView.data[adjustedIndex];
    const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));
    const previousInjectImplementation = setInjectImplementation(ɵɵdirectiveInject);
    try {
        const previousIncludeViewProviders = setIncludeViewProviders(false);
        const pipeInstance = pipeFactory();
        setIncludeViewProviders(previousIncludeViewProviders);
        store(tView, getLView(), adjustedIndex, pipeInstance);
        return pipeInstance;
    } finally{
        setInjectImplementation(previousInjectImplementation);
    }
}
function getPipeDef(name, registry) {
    if (registry) for(let i = registry.length - 1; i >= 0; i--){
        const pipeDef = registry[i];
        if (name === pipeDef.name) return pipeDef;
    }
    if (ngDevMode) throw new RuntimeError(-302, getPipeNotFoundErrorMessage(name));
}
function getPipeNotFoundErrorMessage(name) {
    const lView = getLView();
    const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
    const context = declarationLView[CONTEXT];
    const hostIsStandalone = isHostComponentStandalone(lView);
    const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';
    const verifyMessage = `Verify that it is ${hostIsStandalone ? 'included in the \'@Component.imports\' of this component' : 'declared or imported in this module'}`;
    const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;
    return errorMessage;
}
function ɵɵpipeBind1(index, slotOffset, v1) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
}
function ɵɵpipeBind2(index, slotOffset, v1, v2) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
}
function ɵɵpipeBind3(index, slotOffset, v1, v2, v3) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
}
function ɵɵpipeBind4(index, slotOffset, v1, v2, v3, v4) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
}
function ɵɵpipeBindV(index, slotOffset, values) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
}
function isPure(lView, index) {
    return lView[TVIEW].data[index].pure;
}
class EventEmitter_ extends _index.Subject {
    emit(value) {
        super.next(value);
    }
    subscribe(observerOrNext, error, complete) {
        let nextFn = observerOrNext;
        let errorFn = error || (()=>null);
        let completeFn = complete;
        if (observerOrNext && typeof observerOrNext === 'object') {
            var _observer_next, _observer_error, _observer_complete;
            const observer = observerOrNext;
            nextFn = (_observer_next = observer.next) === null || _observer_next === void 0 ? void 0 : _observer_next.bind(observer);
            errorFn = (_observer_error = observer.error) === null || _observer_error === void 0 ? void 0 : _observer_error.bind(observer);
            completeFn = (_observer_complete = observer.complete) === null || _observer_complete === void 0 ? void 0 : _observer_complete.bind(observer);
        }
        if (this.__isAsync) {
            errorFn = _wrapInTimeout(errorFn);
            if (nextFn) nextFn = _wrapInTimeout(nextFn);
            if (completeFn) completeFn = _wrapInTimeout(completeFn);
        }
        const sink = super.subscribe({
            next: nextFn,
            error: errorFn,
            complete: completeFn
        });
        if (observerOrNext instanceof _index.Subscription) observerOrNext.add(sink);
        return sink;
    }
    constructor(isAsync = false){
        super();
        this.__isAsync = isAsync;
    }
}
function _wrapInTimeout(fn) {
    return (value)=>{
        setTimeout(fn, undefined, value);
    };
}
const EventEmitter = EventEmitter_;
function symbolIterator() {
    return this._results[Symbol.iterator]();
}
class QueryList {
    get changes() {
        return this._changes || (this._changes = new EventEmitter());
    }
    get(index) {
        return this._results[index];
    }
    map(fn) {
        return this._results.map(fn);
    }
    filter(fn) {
        return this._results.filter(fn);
    }
    find(fn) {
        return this._results.find(fn);
    }
    reduce(fn, init) {
        return this._results.reduce(fn, init);
    }
    forEach(fn) {
        this._results.forEach(fn);
    }
    some(fn) {
        return this._results.some(fn);
    }
    toArray() {
        return this._results.slice();
    }
    toString() {
        return this._results.toString();
    }
    reset(resultsTree, identityAccessor) {
        const self1 = this;
        self1.dirty = false;
        const newResultFlat = flatten(resultsTree);
        if (this._changesDetected = !arrayEquals(self1._results, newResultFlat, identityAccessor)) {
            self1._results = newResultFlat;
            self1.length = newResultFlat.length;
            self1.last = newResultFlat[this.length - 1];
            self1.first = newResultFlat[0];
        }
    }
    notifyOnChanges() {
        if (this._changes && (this._changesDetected || !this._emitDistinctChangesOnly)) this._changes.emit(this);
    }
    setDirty() {
        this.dirty = true;
    }
    destroy() {
        this.changes.complete();
        this.changes.unsubscribe();
    }
    constructor(_emitDistinctChangesOnly = false){
        this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
        this.dirty = true;
        this._results = [];
        this._changesDetected = false;
        this._changes = null;
        this.length = 0;
        this.first = undefined;
        this.last = undefined;
        const proto = QueryList.prototype;
        if (!proto[Symbol.iterator]) proto[Symbol.iterator] = symbolIterator;
    }
}
Symbol.iterator;
let TemplateRef = (()=>{
    class TemplateRef {
    }
    TemplateRef.__NG_ELEMENT_ID__ = injectTemplateRef;
    return TemplateRef;
})();
const ViewEngineTemplateRef = TemplateRef;
const R3TemplateRef = class TemplateRef extends ViewEngineTemplateRef {
    get ssrId() {
        var _this__declarationTContainer_tView;
        return ((_this__declarationTContainer_tView = this._declarationTContainer.tView) === null || _this__declarationTContainer_tView === void 0 ? void 0 : _this__declarationTContainer_tView.ssrId) || null;
    }
    createEmbeddedView(context, injector) {
        return this.createEmbeddedViewImpl(context, injector, null);
    }
    createEmbeddedViewImpl(context, injector, hydrationInfo) {
        const embeddedTView = this._declarationTContainer.tView;
        const embeddedLView = createLView(this._declarationLView, embeddedTView, context, 16, null, embeddedTView.declTNode, null, null, null, injector || null, hydrationInfo || null);
        const declarationLContainer = this._declarationLView[this._declarationTContainer.index];
        ngDevMode && assertLContainer(declarationLContainer);
        embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
        const declarationViewLQueries = this._declarationLView[QUERIES];
        if (declarationViewLQueries !== null) embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
        renderView(embeddedTView, embeddedLView, context);
        return new ViewRef$1(embeddedLView);
    }
    constructor(_declarationLView, _declarationTContainer, elementRef){
        super();
        this._declarationLView = _declarationLView;
        this._declarationTContainer = _declarationTContainer;
        this.elementRef = elementRef;
    }
};
function injectTemplateRef() {
    return createTemplateRef(getCurrentTNode(), getLView());
}
function createTemplateRef(hostTNode, hostLView) {
    if (hostTNode.type & 4) {
        ngDevMode && assertDefined(hostTNode.tView, 'TView must be allocated');
        return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
    }
    return null;
}
let _findMatchingDehydratedViewImpl = (lContainer, template)=>null;
function findMatchingDehydratedView(lContainer, template) {
    return _findMatchingDehydratedViewImpl(lContainer, template);
}
let ViewContainerRef = (()=>{
    class ViewContainerRef {
    }
    ViewContainerRef.__NG_ELEMENT_ID__ = injectViewContainerRef;
    return ViewContainerRef;
})();
function injectViewContainerRef() {
    const previousTNode = getCurrentTNode();
    return createContainerRef(previousTNode, getLView());
}
const VE_ViewContainerRef = ViewContainerRef;
const R3ViewContainerRef = class ViewContainerRef extends VE_ViewContainerRef {
    get element() {
        return createElementRef(this._hostTNode, this._hostLView);
    }
    get injector() {
        return new NodeInjector(this._hostTNode, this._hostLView);
    }
    get parentInjector() {
        const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
        if (hasParentInjector(parentLocation)) {
            const parentView = getParentInjectorView(parentLocation, this._hostLView);
            const injectorIndex = getParentInjectorIndex(parentLocation);
            ngDevMode && assertNodeInjector(parentView, injectorIndex);
            const parentTNode = parentView[TVIEW].data[injectorIndex + 8];
            return new NodeInjector(parentTNode, parentView);
        } else return new NodeInjector(null, this._hostLView);
    }
    clear() {
        while(this.length > 0)this.remove(this.length - 1);
    }
    get(index) {
        const viewRefs = getViewRefs(this._lContainer);
        return viewRefs !== null && viewRefs[index] || null;
    }
    get length() {
        return this._lContainer.length - CONTAINER_HEADER_OFFSET;
    }
    createEmbeddedView(templateRef, context, indexOrOptions) {
        let index;
        let injector;
        if (typeof indexOrOptions === 'number') index = indexOrOptions;
        else if (indexOrOptions != null) {
            index = indexOrOptions.index;
            injector = indexOrOptions.injector;
        }
        const hydrationInfo = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);
        const viewRef = templateRef.createEmbeddedViewImpl(context || {}, injector, hydrationInfo);
        this.insertImpl(viewRef, index, !!hydrationInfo);
        return viewRef;
    }
    createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {
        const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
        let index;
        if (isComponentFactory) {
            if (ngDevMode) assertEqual(typeof indexOrOptions !== 'object', true, "It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)");
            index = indexOrOptions;
        } else {
            if (ngDevMode) {
                assertDefined(getComponentDef(componentFactoryOrType), `Provided Component class doesn't contain Component definition. ` + `Please check whether provided class has @Component decorator.`);
                assertEqual(typeof indexOrOptions !== 'number', true, "It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.");
            }
            const options = indexOrOptions || {};
            if (ngDevMode && options.environmentInjector && options.ngModuleRef) throwError(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);
            index = options.index;
            injector = options.injector;
            projectableNodes = options.projectableNodes;
            environmentInjector = options.environmentInjector || options.ngModuleRef;
        }
        const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory(getComponentDef(componentFactoryOrType));
        const contextInjector = injector || this.parentInjector;
        if (!environmentInjector && componentFactory.ngModule == null) {
            const _injector = isComponentFactory ? contextInjector : this.parentInjector;
            const result = _injector.get(EnvironmentInjector, null);
            if (result) environmentInjector = result;
        }
        var _componentFactory_componentType;
        const componentDef = getComponentDef((_componentFactory_componentType = componentFactory.componentType) !== null && _componentFactory_componentType !== void 0 ? _componentFactory_componentType : {});
        var _componentDef_id;
        const dehydratedView = findMatchingDehydratedView(this._lContainer, (_componentDef_id = componentDef === null || componentDef === void 0 ? void 0 : componentDef.id) !== null && _componentDef_id !== void 0 ? _componentDef_id : null);
        var _dehydratedView_firstChild;
        const rNode = (_dehydratedView_firstChild = dehydratedView === null || dehydratedView === void 0 ? void 0 : dehydratedView.firstChild) !== null && _dehydratedView_firstChild !== void 0 ? _dehydratedView_firstChild : null;
        const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector);
        this.insertImpl(componentRef.hostView, index, !!dehydratedView);
        return componentRef;
    }
    insert(viewRef, index) {
        return this.insertImpl(viewRef, index, false);
    }
    insertImpl(viewRef, index, skipDomInsertion) {
        const lView = viewRef._lView;
        const tView = lView[TVIEW];
        if (ngDevMode && viewRef.destroyed) throw new Error('Cannot insert a destroyed View in a ViewContainer!');
        if (viewAttachedToContainer(lView)) {
            const prevIdx = this.indexOf(viewRef);
            if (prevIdx !== -1) this.detach(prevIdx);
            else {
                const prevLContainer = lView[PARENT];
                ngDevMode && assertEqual(isLContainer(prevLContainer), true, 'An attached view should have its PARENT point to a container.');
                const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);
                prevVCRef.detach(prevVCRef.indexOf(viewRef));
            }
        }
        const adjustedIdx = this._adjustIndex(index);
        const lContainer = this._lContainer;
        insertView(tView, lView, lContainer, adjustedIdx);
        if (!skipDomInsertion) {
            const beforeNode = getBeforeNodeForView(adjustedIdx, lContainer);
            const renderer = lView[RENDERER];
            const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);
            if (parentRNode !== null) addViewToContainer(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
        }
        viewRef.attachToViewContainerRef();
        addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
        return viewRef;
    }
    move(viewRef, newIndex) {
        if (ngDevMode && viewRef.destroyed) throw new Error('Cannot move a destroyed View in a ViewContainer!');
        return this.insert(viewRef, newIndex);
    }
    indexOf(viewRef) {
        const viewRefsArr = getViewRefs(this._lContainer);
        return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
    }
    remove(index) {
        const adjustedIdx = this._adjustIndex(index, -1);
        const detachedView = detachView(this._lContainer, adjustedIdx);
        if (detachedView) {
            removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);
            destroyLView(detachedView[TVIEW], detachedView);
        }
    }
    detach(index) {
        const adjustedIdx = this._adjustIndex(index, -1);
        const view = detachView(this._lContainer, adjustedIdx);
        const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
        return wasDetached ? new ViewRef$1(view) : null;
    }
    _adjustIndex(index, shift = 0) {
        if (index == null) return this.length + shift;
        if (ngDevMode) {
            assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);
            assertLessThan(index, this.length + 1 + shift, 'index');
        }
        return index;
    }
    constructor(_lContainer, _hostTNode, _hostLView){
        super();
        this._lContainer = _lContainer;
        this._hostTNode = _hostTNode;
        this._hostLView = _hostLView;
    }
};
function getViewRefs(lContainer) {
    return lContainer[VIEW_REFS];
}
function getOrCreateViewRefs(lContainer) {
    return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);
}
function createContainerRef(hostTNode, hostLView) {
    ngDevMode && assertTNodeType(hostTNode, 15);
    let lContainer;
    const slotValue = hostLView[hostTNode.index];
    if (isLContainer(slotValue)) lContainer = slotValue;
    else {
        lContainer = createLContainer(slotValue, hostLView, null, hostTNode);
        hostLView[hostTNode.index] = lContainer;
        addToViewTree(hostLView, lContainer);
    }
    _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);
    return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
}
function insertAnchorNode(hostLView, hostTNode) {
    const renderer = hostLView[RENDERER];
    ngDevMode && ngDevMode.rendererCreateComment++;
    const commentNode = renderer.createComment(ngDevMode ? 'container' : '');
    const hostNative = getNativeByTNode(hostTNode, hostLView);
    const parentOfHostNative = nativeParentNode(renderer, hostNative);
    nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);
    return commentNode;
}
let _locateOrCreateAnchorNode = createAnchorNode;
function createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
    if (lContainer[NATIVE]) return;
    let commentNode;
    if (hostTNode.type & 8) commentNode = unwrapRNode(slotValue);
    else commentNode = insertAnchorNode(hostLView, hostTNode);
    lContainer[NATIVE] = commentNode;
}
class LQuery_ {
    clone() {
        return new LQuery_(this.queryList);
    }
    setDirty() {
        this.queryList.setDirty();
    }
    constructor(queryList){
        this.queryList = queryList;
        this.matches = null;
    }
}
class LQueries_ {
    createEmbeddedView(tView) {
        const tQueries = tView.queries;
        if (tQueries !== null) {
            const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
            const viewLQueries = [];
            for(let i = 0; i < noOfInheritedQueries; i++){
                const tQuery = tQueries.getByIndex(i);
                const parentLQuery = this.queries[tQuery.indexInDeclarationView];
                viewLQueries.push(parentLQuery.clone());
            }
            return new LQueries_(viewLQueries);
        }
        return null;
    }
    insertView(tView) {
        this.dirtyQueriesWithMatches(tView);
    }
    detachView(tView) {
        this.dirtyQueriesWithMatches(tView);
    }
    dirtyQueriesWithMatches(tView) {
        for(let i = 0; i < this.queries.length; i++)if (getTQuery(tView, i).matches !== null) this.queries[i].setDirty();
    }
    constructor(queries = []){
        this.queries = queries;
    }
}
class TQueryMetadata_ {
    constructor(predicate, flags, read = null){
        this.predicate = predicate;
        this.flags = flags;
        this.read = read;
    }
}
class TQueries_ {
    elementStart(tView, tNode) {
        ngDevMode && assertFirstCreatePass(tView, 'Queries should collect results on the first template pass only');
        for(let i = 0; i < this.queries.length; i++)this.queries[i].elementStart(tView, tNode);
    }
    elementEnd(tNode) {
        for(let i = 0; i < this.queries.length; i++)this.queries[i].elementEnd(tNode);
    }
    embeddedTView(tNode) {
        let queriesForTemplateRef = null;
        for(let i = 0; i < this.length; i++){
            const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
            const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
            if (tqueryClone) {
                tqueryClone.indexInDeclarationView = i;
                if (queriesForTemplateRef !== null) queriesForTemplateRef.push(tqueryClone);
                else queriesForTemplateRef = [
                    tqueryClone
                ];
            }
        }
        return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;
    }
    template(tView, tNode) {
        ngDevMode && assertFirstCreatePass(tView, 'Queries should collect results on the first template pass only');
        for(let i = 0; i < this.queries.length; i++)this.queries[i].template(tView, tNode);
    }
    getByIndex(index) {
        ngDevMode && assertIndexInRange(this.queries, index);
        return this.queries[index];
    }
    get length() {
        return this.queries.length;
    }
    track(tquery) {
        this.queries.push(tquery);
    }
    constructor(queries = []){
        this.queries = queries;
    }
}
class TQuery_ {
    elementStart(tView, tNode) {
        if (this.isApplyingToNode(tNode)) this.matchTNode(tView, tNode);
    }
    elementEnd(tNode) {
        if (this._declarationNodeIndex === tNode.index) this._appliesToNextNode = false;
    }
    template(tView, tNode) {
        this.elementStart(tView, tNode);
    }
    embeddedTView(tNode, childQueryIndex) {
        if (this.isApplyingToNode(tNode)) {
            this.crossesNgTemplate = true;
            this.addMatch(-tNode.index, childQueryIndex);
            return new TQuery_(this.metadata);
        }
        return null;
    }
    isApplyingToNode(tNode) {
        if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
            const declarationNodeIdx = this._declarationNodeIndex;
            let parent = tNode.parent;
            while(parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx)parent = parent.parent;
            return declarationNodeIdx === (parent !== null ? parent.index : -1);
        }
        return this._appliesToNextNode;
    }
    matchTNode(tView, tNode) {
        const predicate = this.metadata.predicate;
        if (Array.isArray(predicate)) for(let i = 0; i < predicate.length; i++){
            const name = predicate[i];
            this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
            this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
        }
        else {
            if (predicate === TemplateRef) {
                if (tNode.type & 4) this.matchTNodeWithReadOption(tView, tNode, -1);
            } else this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
        }
    }
    matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
        if (nodeMatchIdx !== null) {
            const read = this.metadata.read;
            if (read !== null) {
                if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) this.addMatch(tNode.index, -2);
                else {
                    const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
                    if (directiveOrProviderIdx !== null) this.addMatch(tNode.index, directiveOrProviderIdx);
                }
            } else this.addMatch(tNode.index, nodeMatchIdx);
        }
    }
    addMatch(tNodeIdx, matchIdx) {
        if (this.matches === null) this.matches = [
            tNodeIdx,
            matchIdx
        ];
        else this.matches.push(tNodeIdx, matchIdx);
    }
    constructor(metadata, nodeIndex = -1){
        this.metadata = metadata;
        this.matches = null;
        this.indexInDeclarationView = -1;
        this.crossesNgTemplate = false;
        this._appliesToNextNode = true;
        this._declarationNodeIndex = nodeIndex;
    }
}
function getIdxOfMatchingSelector(tNode, selector) {
    const localNames = tNode.localNames;
    if (localNames !== null) for(let i = 0; i < localNames.length; i += 2){
        if (localNames[i] === selector) return localNames[i + 1];
    }
    return null;
}
function createResultByTNodeType(tNode, currentView) {
    if (tNode.type & 11) return createElementRef(tNode, currentView);
    else if (tNode.type & 4) return createTemplateRef(tNode, currentView);
    return null;
}
function createResultForNode(lView, tNode, matchingIdx, read) {
    if (matchingIdx === -1) return createResultByTNodeType(tNode, lView);
    else if (matchingIdx === -2) return createSpecialToken(lView, tNode, read);
    else return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);
}
function createSpecialToken(lView, tNode, read) {
    if (read === ElementRef) return createElementRef(tNode, lView);
    else if (read === TemplateRef) return createTemplateRef(tNode, lView);
    else if (read === ViewContainerRef) {
        ngDevMode && assertTNodeType(tNode, 15);
        return createContainerRef(tNode, lView);
    } else ngDevMode && throwError(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);
}
function materializeViewResults(tView, lView, tQuery, queryIndex) {
    const lQuery = lView[QUERIES].queries[queryIndex];
    if (lQuery.matches === null) {
        const tViewData = tView.data;
        const tQueryMatches = tQuery.matches;
        const result = [];
        for(let i = 0; i < tQueryMatches.length; i += 2){
            const matchedNodeIdx = tQueryMatches[i];
            if (matchedNodeIdx < 0) result.push(null);
            else {
                ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);
                const tNode = tViewData[matchedNodeIdx];
                result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
            }
        }
        lQuery.matches = result;
    }
    return lQuery.matches;
}
function collectQueryResults(tView, lView, queryIndex, result) {
    const tQuery = tView.queries.getByIndex(queryIndex);
    const tQueryMatches = tQuery.matches;
    if (tQueryMatches !== null) {
        const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
        for(let i = 0; i < tQueryMatches.length; i += 2){
            const tNodeIdx = tQueryMatches[i];
            if (tNodeIdx > 0) result.push(lViewResults[i / 2]);
            else {
                const childQueryIndex = tQueryMatches[i + 1];
                const declarationLContainer = lView[-tNodeIdx];
                ngDevMode && assertLContainer(declarationLContainer);
                for(let i = CONTAINER_HEADER_OFFSET; i < declarationLContainer.length; i++){
                    const embeddedLView = declarationLContainer[i];
                    if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
                }
                if (declarationLContainer[MOVED_VIEWS] !== null) {
                    const embeddedLViews = declarationLContainer[MOVED_VIEWS];
                    for(let i = 0; i < embeddedLViews.length; i++){
                        const embeddedLView = embeddedLViews[i];
                        collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
                    }
                }
            }
        }
    }
    return result;
}
function ɵɵqueryRefresh(queryList) {
    const lView = getLView();
    const tView = getTView();
    const queryIndex = getCurrentQueryIndex();
    setCurrentQueryIndex(queryIndex + 1);
    const tQuery = getTQuery(tView, queryIndex);
    if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2) === 2)) {
        if (tQuery.matches === null) queryList.reset([]);
        else {
            const result = tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
            queryList.reset(result, unwrapElementRef);
            queryList.notifyOnChanges();
        }
        return true;
    }
    return false;
}
function ɵɵviewQuery(predicate, flags, read) {
    ngDevMode && assertNumber(flags, 'Expecting flags');
    const tView = getTView();
    if (tView.firstCreatePass) {
        createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
        if ((flags & 2) === 2) tView.staticViewQueries = true;
    }
    createLQuery(tView, getLView(), flags);
}
function ɵɵcontentQuery(directiveIndex, predicate, flags, read) {
    ngDevMode && assertNumber(flags, 'Expecting flags');
    const tView = getTView();
    if (tView.firstCreatePass) {
        const tNode = getCurrentTNode();
        createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
        saveContentQueryAndDirectiveIndex(tView, directiveIndex);
        if ((flags & 2) === 2) tView.staticContentQueries = true;
    }
    createLQuery(tView, getLView(), flags);
}
function ɵɵloadQuery() {
    return loadQueryInternal(getLView(), getCurrentQueryIndex());
}
function loadQueryInternal(lView, queryIndex) {
    ngDevMode && assertDefined(lView[QUERIES], 'LQueries should be defined when trying to load a query');
    ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);
    return lView[QUERIES].queries[queryIndex].queryList;
}
function createLQuery(tView, lView, flags) {
    const queryList = new QueryList((flags & 4) === 4);
    storeCleanupWithContext(tView, lView, queryList, queryList.destroy);
    if (lView[QUERIES] === null) lView[QUERIES] = new LQueries_();
    lView[QUERIES].queries.push(new LQuery_(queryList));
}
function createTQuery(tView, metadata, nodeIndex) {
    if (tView.queries === null) tView.queries = new TQueries_();
    tView.queries.track(new TQuery_(metadata, nodeIndex));
}
function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
    const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
    const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
    if (directiveIndex !== lastSavedDirectiveIndex) tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
}
function getTQuery(tView, index) {
    ngDevMode && assertDefined(tView.queries, 'TQueries must be defined to retrieve a TQuery');
    return tView.queries.getByIndex(index);
}
function ɵɵtemplateRefExtractor(tNode, lView) {
    return createTemplateRef(tNode, lView);
}
const angularCoreEnv = (()=>({
        'ɵɵattribute': ɵɵattribute,
        'ɵɵattributeInterpolate1': ɵɵattributeInterpolate1,
        'ɵɵattributeInterpolate2': ɵɵattributeInterpolate2,
        'ɵɵattributeInterpolate3': ɵɵattributeInterpolate3,
        'ɵɵattributeInterpolate4': ɵɵattributeInterpolate4,
        'ɵɵattributeInterpolate5': ɵɵattributeInterpolate5,
        'ɵɵattributeInterpolate6': ɵɵattributeInterpolate6,
        'ɵɵattributeInterpolate7': ɵɵattributeInterpolate7,
        'ɵɵattributeInterpolate8': ɵɵattributeInterpolate8,
        'ɵɵattributeInterpolateV': ɵɵattributeInterpolateV,
        'ɵɵdefineComponent': ɵɵdefineComponent,
        'ɵɵdefineDirective': ɵɵdefineDirective,
        'ɵɵdefineInjectable': ɵɵdefineInjectable,
        'ɵɵdefineInjector': ɵɵdefineInjector,
        'ɵɵdefineNgModule': ɵɵdefineNgModule,
        'ɵɵdefinePipe': ɵɵdefinePipe,
        'ɵɵdirectiveInject': ɵɵdirectiveInject,
        'ɵɵgetInheritedFactory': ɵɵgetInheritedFactory,
        'ɵɵinject': ɵɵinject,
        'ɵɵinjectAttribute': ɵɵinjectAttribute,
        'ɵɵinvalidFactory': ɵɵinvalidFactory,
        'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,
        'ɵɵtemplateRefExtractor': ɵɵtemplateRefExtractor,
        'ɵɵresetView': ɵɵresetView,
        'ɵɵHostDirectivesFeature': ɵɵHostDirectivesFeature,
        'ɵɵNgOnChangesFeature': ɵɵNgOnChangesFeature,
        'ɵɵProvidersFeature': ɵɵProvidersFeature,
        'ɵɵCopyDefinitionFeature': ɵɵCopyDefinitionFeature,
        'ɵɵInheritDefinitionFeature': ɵɵInheritDefinitionFeature,
        'ɵɵStandaloneFeature': ɵɵStandaloneFeature,
        'ɵɵnextContext': ɵɵnextContext,
        'ɵɵnamespaceHTML': ɵɵnamespaceHTML,
        'ɵɵnamespaceMathML': ɵɵnamespaceMathML,
        'ɵɵnamespaceSVG': ɵɵnamespaceSVG,
        'ɵɵenableBindings': ɵɵenableBindings,
        'ɵɵdisableBindings': ɵɵdisableBindings,
        'ɵɵelementStart': ɵɵelementStart,
        'ɵɵelementEnd': ɵɵelementEnd,
        'ɵɵelement': ɵɵelement,
        'ɵɵelementContainerStart': ɵɵelementContainerStart,
        'ɵɵelementContainerEnd': ɵɵelementContainerEnd,
        'ɵɵelementContainer': ɵɵelementContainer,
        'ɵɵpureFunction0': ɵɵpureFunction0,
        'ɵɵpureFunction1': ɵɵpureFunction1,
        'ɵɵpureFunction2': ɵɵpureFunction2,
        'ɵɵpureFunction3': ɵɵpureFunction3,
        'ɵɵpureFunction4': ɵɵpureFunction4,
        'ɵɵpureFunction5': ɵɵpureFunction5,
        'ɵɵpureFunction6': ɵɵpureFunction6,
        'ɵɵpureFunction7': ɵɵpureFunction7,
        'ɵɵpureFunction8': ɵɵpureFunction8,
        'ɵɵpureFunctionV': ɵɵpureFunctionV,
        'ɵɵgetCurrentView': ɵɵgetCurrentView,
        'ɵɵrestoreView': ɵɵrestoreView,
        'ɵɵlistener': ɵɵlistener,
        'ɵɵprojection': ɵɵprojection,
        'ɵɵsyntheticHostProperty': ɵɵsyntheticHostProperty,
        'ɵɵsyntheticHostListener': ɵɵsyntheticHostListener,
        'ɵɵpipeBind1': ɵɵpipeBind1,
        'ɵɵpipeBind2': ɵɵpipeBind2,
        'ɵɵpipeBind3': ɵɵpipeBind3,
        'ɵɵpipeBind4': ɵɵpipeBind4,
        'ɵɵpipeBindV': ɵɵpipeBindV,
        'ɵɵprojectionDef': ɵɵprojectionDef,
        'ɵɵhostProperty': ɵɵhostProperty,
        'ɵɵproperty': ɵɵproperty,
        'ɵɵpropertyInterpolate': ɵɵpropertyInterpolate,
        'ɵɵpropertyInterpolate1': ɵɵpropertyInterpolate1,
        'ɵɵpropertyInterpolate2': ɵɵpropertyInterpolate2,
        'ɵɵpropertyInterpolate3': ɵɵpropertyInterpolate3,
        'ɵɵpropertyInterpolate4': ɵɵpropertyInterpolate4,
        'ɵɵpropertyInterpolate5': ɵɵpropertyInterpolate5,
        'ɵɵpropertyInterpolate6': ɵɵpropertyInterpolate6,
        'ɵɵpropertyInterpolate7': ɵɵpropertyInterpolate7,
        'ɵɵpropertyInterpolate8': ɵɵpropertyInterpolate8,
        'ɵɵpropertyInterpolateV': ɵɵpropertyInterpolateV,
        'ɵɵpipe': ɵɵpipe,
        'ɵɵqueryRefresh': ɵɵqueryRefresh,
        'ɵɵviewQuery': ɵɵviewQuery,
        'ɵɵloadQuery': ɵɵloadQuery,
        'ɵɵcontentQuery': ɵɵcontentQuery,
        'ɵɵreference': ɵɵreference,
        'ɵɵclassMap': ɵɵclassMap,
        'ɵɵclassMapInterpolate1': ɵɵclassMapInterpolate1,
        'ɵɵclassMapInterpolate2': ɵɵclassMapInterpolate2,
        'ɵɵclassMapInterpolate3': ɵɵclassMapInterpolate3,
        'ɵɵclassMapInterpolate4': ɵɵclassMapInterpolate4,
        'ɵɵclassMapInterpolate5': ɵɵclassMapInterpolate5,
        'ɵɵclassMapInterpolate6': ɵɵclassMapInterpolate6,
        'ɵɵclassMapInterpolate7': ɵɵclassMapInterpolate7,
        'ɵɵclassMapInterpolate8': ɵɵclassMapInterpolate8,
        'ɵɵclassMapInterpolateV': ɵɵclassMapInterpolateV,
        'ɵɵstyleMap': ɵɵstyleMap,
        'ɵɵstyleMapInterpolate1': ɵɵstyleMapInterpolate1,
        'ɵɵstyleMapInterpolate2': ɵɵstyleMapInterpolate2,
        'ɵɵstyleMapInterpolate3': ɵɵstyleMapInterpolate3,
        'ɵɵstyleMapInterpolate4': ɵɵstyleMapInterpolate4,
        'ɵɵstyleMapInterpolate5': ɵɵstyleMapInterpolate5,
        'ɵɵstyleMapInterpolate6': ɵɵstyleMapInterpolate6,
        'ɵɵstyleMapInterpolate7': ɵɵstyleMapInterpolate7,
        'ɵɵstyleMapInterpolate8': ɵɵstyleMapInterpolate8,
        'ɵɵstyleMapInterpolateV': ɵɵstyleMapInterpolateV,
        'ɵɵstyleProp': ɵɵstyleProp,
        'ɵɵstylePropInterpolate1': ɵɵstylePropInterpolate1,
        'ɵɵstylePropInterpolate2': ɵɵstylePropInterpolate2,
        'ɵɵstylePropInterpolate3': ɵɵstylePropInterpolate3,
        'ɵɵstylePropInterpolate4': ɵɵstylePropInterpolate4,
        'ɵɵstylePropInterpolate5': ɵɵstylePropInterpolate5,
        'ɵɵstylePropInterpolate6': ɵɵstylePropInterpolate6,
        'ɵɵstylePropInterpolate7': ɵɵstylePropInterpolate7,
        'ɵɵstylePropInterpolate8': ɵɵstylePropInterpolate8,
        'ɵɵstylePropInterpolateV': ɵɵstylePropInterpolateV,
        'ɵɵclassProp': ɵɵclassProp,
        'ɵɵadvance': ɵɵadvance,
        'ɵɵtemplate': ɵɵtemplate,
        'ɵɵtext': ɵɵtext,
        'ɵɵtextInterpolate': ɵɵtextInterpolate,
        'ɵɵtextInterpolate1': ɵɵtextInterpolate1,
        'ɵɵtextInterpolate2': ɵɵtextInterpolate2,
        'ɵɵtextInterpolate3': ɵɵtextInterpolate3,
        'ɵɵtextInterpolate4': ɵɵtextInterpolate4,
        'ɵɵtextInterpolate5': ɵɵtextInterpolate5,
        'ɵɵtextInterpolate6': ɵɵtextInterpolate6,
        'ɵɵtextInterpolate7': ɵɵtextInterpolate7,
        'ɵɵtextInterpolate8': ɵɵtextInterpolate8,
        'ɵɵtextInterpolateV': ɵɵtextInterpolateV,
        'ɵɵi18n': ɵɵi18n,
        'ɵɵi18nAttributes': ɵɵi18nAttributes,
        'ɵɵi18nExp': ɵɵi18nExp,
        'ɵɵi18nStart': ɵɵi18nStart,
        'ɵɵi18nEnd': ɵɵi18nEnd,
        'ɵɵi18nApply': ɵɵi18nApply,
        'ɵɵi18nPostprocess': ɵɵi18nPostprocess,
        'ɵɵresolveWindow': ɵɵresolveWindow,
        'ɵɵresolveDocument': ɵɵresolveDocument,
        'ɵɵresolveBody': ɵɵresolveBody,
        'ɵɵsetComponentScope': ɵɵsetComponentScope,
        'ɵɵsetNgModuleScope': ɵɵsetNgModuleScope,
        'ɵɵregisterNgModuleType': registerNgModuleType,
        'ɵɵsanitizeHtml': ɵɵsanitizeHtml,
        'ɵɵsanitizeStyle': ɵɵsanitizeStyle,
        'ɵɵsanitizeResourceUrl': ɵɵsanitizeResourceUrl,
        'ɵɵsanitizeScript': ɵɵsanitizeScript,
        'ɵɵsanitizeUrl': ɵɵsanitizeUrl,
        'ɵɵsanitizeUrlOrResourceUrl': ɵɵsanitizeUrlOrResourceUrl,
        'ɵɵtrustConstantHtml': ɵɵtrustConstantHtml,
        'ɵɵtrustConstantResourceUrl': ɵɵtrustConstantResourceUrl,
        'ɵɵvalidateIframeAttribute': ɵɵvalidateIframeAttribute,
        'forwardRef': forwardRef,
        'resolveForwardRef': resolveForwardRef
    }))();
let jitOptions = null;
function setJitOptions(options) {
    if (jitOptions !== null) {
        if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
            ngDevMode && console.error('Provided value for `defaultEncapsulation` can not be changed once it has been set.');
            return;
        }
        if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
            ngDevMode && console.error('Provided value for `preserveWhitespaces` can not be changed once it has been set.');
            return;
        }
    }
    jitOptions = options;
}
function getJitOptions() {
    return jitOptions;
}
function patchModuleCompilation() {}
function isModuleWithProviders(value) {
    return value.ngModule !== undefined;
}
function isNgModule(value) {
    return !!getNgModuleDef(value);
}
const moduleQueue = [];
function enqueueModuleForDelayedScoping(moduleType, ngModule) {
    moduleQueue.push({
        moduleType,
        ngModule
    });
}
let flushingModuleQueue = false;
function flushModuleScopingQueueAsMuchAsPossible() {
    if (!flushingModuleQueue) {
        flushingModuleQueue = true;
        try {
            for(let i = moduleQueue.length - 1; i >= 0; i--){
                const { moduleType , ngModule  } = moduleQueue[i];
                if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
                    moduleQueue.splice(i, 1);
                    setScopeOnDeclaredComponents(moduleType, ngModule);
                }
            }
        } finally{
            flushingModuleQueue = false;
        }
    }
}
function isResolvedDeclaration(declaration) {
    if (Array.isArray(declaration)) return declaration.every(isResolvedDeclaration);
    return !!resolveForwardRef(declaration);
}
function compileNgModule(moduleType, ngModule = {}) {
    patchModuleCompilation();
    compileNgModuleDefs(moduleType, ngModule);
    if (ngModule.id !== undefined) registerNgModuleType(moduleType, ngModule.id);
    enqueueModuleForDelayedScoping(moduleType, ngModule);
}
function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
    ngDevMode && assertDefined(moduleType, 'Required value moduleType');
    ngDevMode && assertDefined(ngModule, 'Required value ngModule');
    const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
    let ngModuleDef = null;
    Object.defineProperty(moduleType, NG_MOD_DEF, {
        configurable: true,
        get: ()=>{
            if (ngModuleDef === null) {
                if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);
                const compiler = getCompilerFacade({
                    usage: 0,
                    kind: 'NgModule',
                    type: moduleType
                });
                ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/ɵmod.js`, {
                    type: moduleType,
                    bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),
                    declarations: declarations.map(resolveForwardRef),
                    imports: flatten(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
                    exports: flatten(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
                    schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
                    id: ngModule.id || null
                });
                if (!ngModuleDef.schemas) ngModuleDef.schemas = [];
            }
            return ngModuleDef;
        }
    });
    let ngFactoryDef = null;
    Object.defineProperty(moduleType, NG_FACTORY_DEF, {
        get: ()=>{
            if (ngFactoryDef === null) {
                const compiler = getCompilerFacade({
                    usage: 0,
                    kind: 'NgModule',
                    type: moduleType
                });
                ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/ɵfac.js`, {
                    name: moduleType.name,
                    type: moduleType,
                    deps: reflectDependencies(moduleType),
                    target: compiler.FactoryTarget.NgModule,
                    typeArgumentCount: 0
                });
            }
            return ngFactoryDef;
        },
        configurable: !!ngDevMode
    });
    let ngInjectorDef = null;
    Object.defineProperty(moduleType, NG_INJ_DEF, {
        get: ()=>{
            if (ngInjectorDef === null) {
                ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
                const meta = {
                    name: moduleType.name,
                    type: moduleType,
                    providers: ngModule.providers || EMPTY_ARRAY,
                    imports: [
                        (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),
                        (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)
                    ]
                };
                const compiler = getCompilerFacade({
                    usage: 0,
                    kind: 'NgModule',
                    type: moduleType
                });
                ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/ɵinj.js`, meta);
            }
            return ngInjectorDef;
        },
        configurable: !!ngDevMode
    });
}
function generateStandaloneInDeclarationsError(type, location1) {
    const prefix = `Unexpected "${stringifyForError(type)}" found in the "declarations" array of the`;
    const suffix = `"${stringifyForError(type)}" is marked as standalone and can't be declared ` + 'in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?';
    return `${prefix} ${location1}, ${suffix}`;
}
function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
    if (verifiedNgModule.get(moduleType)) return;
    if (isStandalone(moduleType)) return;
    verifiedNgModule.set(moduleType, true);
    moduleType = resolveForwardRef(moduleType);
    let ngModuleDef;
    if (importingModule) {
        ngModuleDef = getNgModuleDef(moduleType);
        if (!ngModuleDef) throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    } else ngModuleDef = getNgModuleDef(moduleType, true);
    const errors = [];
    const declarations = maybeUnwrapFn(ngModuleDef.declarations);
    const imports = maybeUnwrapFn(ngModuleDef.imports);
    flatten(imports).map(unwrapModuleWithProvidersImports).forEach((modOrStandaloneCmpt)=>{
        verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);
        verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);
    });
    const exports1 = maybeUnwrapFn(ngModuleDef.exports);
    declarations.forEach(verifyDeclarationsHaveDefinitions);
    declarations.forEach(verifyDirectivesHaveSelector);
    declarations.forEach((declarationType)=>verifyNotStandalone(declarationType, moduleType));
    const combinedDeclarations = [
        ...declarations.map(resolveForwardRef),
        ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)
    ];
    exports1.forEach(verifyExportsAreDeclaredOrReExported);
    declarations.forEach((decl)=>verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
    const ngModule = getAnnotation(moduleType, 'NgModule');
    if (ngModule) {
        ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod)=>{
            verifySemanticsOfNgModuleImport(mod, moduleType);
            verifySemanticsOfNgModuleDef(mod, false, moduleType);
        });
        ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
        ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
    }
    if (errors.length) throw new Error(errors.join('\n'));
    function verifyDeclarationsHaveDefinitions(type) {
        type = resolveForwardRef(type);
        const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
        if (!def) errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
    }
    function verifyDirectivesHaveSelector(type) {
        type = resolveForwardRef(type);
        const def = getDirectiveDef(type);
        if (!getComponentDef(type) && def && def.selectors.length == 0) errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);
    }
    function verifyNotStandalone(type, moduleType) {
        type = resolveForwardRef(type);
        const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
        if (def === null || def === void 0 ? void 0 : def.standalone) {
            const location1 = `"${stringifyForError(moduleType)}" NgModule`;
            errors.push(generateStandaloneInDeclarationsError(type, location1));
        }
    }
    function verifyExportsAreDeclaredOrReExported(type) {
        type = resolveForwardRef(type);
        const kind = getComponentDef(type) && 'component' || getDirectiveDef(type) && 'directive' || getPipeDef$1(type) && 'pipe';
        if (kind) {
            if (combinedDeclarations.lastIndexOf(type) === -1) errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);
        }
    }
    function verifyDeclarationIsUnique(type, suppressErrors) {
        type = resolveForwardRef(type);
        const existingModule = ownerNgModule.get(type);
        if (existingModule && existingModule !== moduleType) {
            if (!suppressErrors) {
                const modules = [
                    existingModule,
                    moduleType
                ].map(stringifyForError).sort();
                errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules[0]} and ${modules[1]}! ` + `Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules[0]} and ${modules[1]}. ` + `You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`);
            }
        } else ownerNgModule.set(type, moduleType);
    }
    function verifyComponentIsPartOfNgModule(type) {
        type = resolveForwardRef(type);
        const existingModule = ownerNgModule.get(type);
        if (!existingModule && !isStandalone(type)) errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);
    }
    function verifyCorrectBootstrapType(type) {
        type = resolveForwardRef(type);
        if (!getComponentDef(type)) errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);
        if (isStandalone(type)) errors.push(`The \`${stringifyForError(type)}\` class is a standalone component, which can ` + `not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` ` + `function for bootstrap instead.`);
    }
    function verifySemanticsOfNgModuleImport(type, importingModule) {
        type = resolveForwardRef(type);
        const directiveDef = getComponentDef(type) || getDirectiveDef(type);
        if (directiveDef !== null && !directiveDef.standalone) throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
        const pipeDef = getPipeDef$1(type);
        if (pipeDef !== null && !pipeDef.standalone) throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
}
function unwrapModuleWithProvidersImports(typeOrWithProviders) {
    typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
    return typeOrWithProviders.ngModule || typeOrWithProviders;
}
function getAnnotation(type, name) {
    let annotation = null;
    collect(type.__annotations__);
    collect(type.decorators);
    return annotation;
    function collect(annotations) {
        if (annotations) annotations.forEach(readAnnotation);
    }
    function readAnnotation(decorator) {
        if (!annotation) {
            const proto = Object.getPrototypeOf(decorator);
            if (proto.ngMetadataName == name) annotation = decorator;
            else if (decorator.type) {
                const proto = Object.getPrototypeOf(decorator.type);
                if (proto.ngMetadataName == name) annotation = decorator.args[0];
            }
        }
    }
}
let ownerNgModule = new WeakMap();
let verifiedNgModule = new WeakMap();
function computeCombinedExports(type) {
    type = resolveForwardRef(type);
    const ngModuleDef = getNgModuleDef(type);
    if (ngModuleDef === null) return [
        type
    ];
    return [
        ...flatten(maybeUnwrapFn(ngModuleDef.exports).map((type)=>{
            const ngModuleDef = getNgModuleDef(type);
            if (ngModuleDef) {
                verifySemanticsOfNgModuleDef(type, false);
                return computeCombinedExports(type);
            } else return type;
        }))
    ];
}
function setScopeOnDeclaredComponents(moduleType, ngModule) {
    const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
    const transitiveScopes = transitiveScopesFor(moduleType);
    declarations.forEach((declaration)=>{
        declaration = resolveForwardRef(declaration);
        if (declaration.hasOwnProperty(NG_COMP_DEF)) {
            const component = declaration;
            const componentDef = getComponentDef(component);
            patchComponentDefWithScope(componentDef, transitiveScopes);
        } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) declaration.ngSelectorScope = moduleType;
    });
}
function patchComponentDefWithScope(componentDef, transitiveScopes) {
    componentDef.directiveDefs = ()=>Array.from(transitiveScopes.compilation.directives).map((dir)=>dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir)).filter((def)=>!!def);
    componentDef.pipeDefs = ()=>Array.from(transitiveScopes.compilation.pipes).map((pipe)=>getPipeDef$1(pipe));
    componentDef.schemas = transitiveScopes.schemas;
    componentDef.tView = null;
}
function transitiveScopesFor(type) {
    if (isNgModule(type)) return transitiveScopesForNgModule(type);
    else if (isStandalone(type)) {
        const directiveDef = getComponentDef(type) || getDirectiveDef(type);
        if (directiveDef !== null) return {
            schemas: null,
            compilation: {
                directives: new Set(),
                pipes: new Set()
            },
            exported: {
                directives: new Set([
                    type
                ]),
                pipes: new Set()
            }
        };
        const pipeDef = getPipeDef$1(type);
        if (pipeDef !== null) return {
            schemas: null,
            compilation: {
                directives: new Set(),
                pipes: new Set()
            },
            exported: {
                directives: new Set(),
                pipes: new Set([
                    type
                ])
            }
        };
    }
    throw new Error(`${type.name} does not have a module def (ɵmod property)`);
}
function transitiveScopesForNgModule(moduleType) {
    const def = getNgModuleDef(moduleType, true);
    if (def.transitiveCompileScopes !== null) return def.transitiveCompileScopes;
    const scopes = {
        schemas: def.schemas || null,
        compilation: {
            directives: new Set(),
            pipes: new Set()
        },
        exported: {
            directives: new Set(),
            pipes: new Set()
        }
    };
    maybeUnwrapFn(def.imports).forEach((imported)=>{
        const importedScope = transitiveScopesFor(imported);
        importedScope.exported.directives.forEach((entry)=>scopes.compilation.directives.add(entry));
        importedScope.exported.pipes.forEach((entry)=>scopes.compilation.pipes.add(entry));
    });
    maybeUnwrapFn(def.declarations).forEach((declared)=>{
        const declaredWithDefs = declared;
        if (getPipeDef$1(declaredWithDefs)) scopes.compilation.pipes.add(declared);
        else scopes.compilation.directives.add(declared);
    });
    maybeUnwrapFn(def.exports).forEach((exported)=>{
        const exportedType = exported;
        if (isNgModule(exportedType)) {
            const exportedScope = transitiveScopesFor(exportedType);
            exportedScope.exported.directives.forEach((entry)=>{
                scopes.compilation.directives.add(entry);
                scopes.exported.directives.add(entry);
            });
            exportedScope.exported.pipes.forEach((entry)=>{
                scopes.compilation.pipes.add(entry);
                scopes.exported.pipes.add(entry);
            });
        } else if (getPipeDef$1(exportedType)) scopes.exported.pipes.add(exportedType);
        else scopes.exported.directives.add(exportedType);
    });
    def.transitiveCompileScopes = scopes;
    return scopes;
}
function expandModuleWithProviders(value) {
    if (isModuleWithProviders(value)) return value.ngModule;
    return value;
}
let compilationDepth = 0;
function compileComponent(type, metadata) {
    (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();
    let ngComponentDef = null;
    maybeQueueResolutionOfComponentResources(type, metadata);
    addDirectiveFactoryDef(type, metadata);
    Object.defineProperty(type, NG_COMP_DEF, {
        get: ()=>{
            if (ngComponentDef === null) {
                const compiler = getCompilerFacade({
                    usage: 0,
                    kind: 'component',
                    type: type
                });
                if (componentNeedsResolution(metadata)) {
                    const error = [
                        `Component '${type.name}' is not resolved:`
                    ];
                    if (metadata.templateUrl) error.push(` - templateUrl: ${metadata.templateUrl}`);
                    if (metadata.styleUrls && metadata.styleUrls.length) error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
                    error.push(`Did you run and wait for 'resolveComponentResources()'?`);
                    throw new Error(error.join('\n'));
                }
                const options = getJitOptions();
                let preserveWhitespaces = metadata.preserveWhitespaces;
                if (preserveWhitespaces === undefined) {
                    if (options !== null && options.preserveWhitespaces !== undefined) preserveWhitespaces = options.preserveWhitespaces;
                    else preserveWhitespaces = false;
                }
                let encapsulation = metadata.encapsulation;
                if (encapsulation === undefined) {
                    if (options !== null && options.defaultEncapsulation !== undefined) encapsulation = options.defaultEncapsulation;
                    else encapsulation = ViewEncapsulation$1.Emulated;
                }
                const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
                const meta = _object_spread_props._(_object_spread._({}, directiveMetadata(type, metadata)), {
                    typeSourceSpan: compiler.createParseSourceSpan('Component', type.name, templateUrl),
                    template: metadata.template || '',
                    preserveWhitespaces,
                    styles: metadata.styles || EMPTY_ARRAY,
                    animations: metadata.animations,
                    declarations: [],
                    changeDetection: metadata.changeDetection,
                    encapsulation,
                    interpolation: metadata.interpolation,
                    viewProviders: metadata.viewProviders || null
                });
                compilationDepth++;
                try {
                    if (meta.usesInheritance) addDirectiveDefToUndecoratedParents(type);
                    ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
                    if (metadata.standalone) {
                        const imports = flatten(metadata.imports || EMPTY_ARRAY);
                        const { directiveDefs , pipeDefs  } = getStandaloneDefFunctions(type, imports);
                        ngComponentDef.directiveDefs = directiveDefs;
                        ngComponentDef.pipeDefs = pipeDefs;
                        ngComponentDef.dependencies = ()=>imports.map(resolveForwardRef);
                    }
                } finally{
                    compilationDepth--;
                }
                if (compilationDepth === 0) flushModuleScopingQueueAsMuchAsPossible();
                if (hasSelectorScope(type)) {
                    const scopes = transitiveScopesFor(type.ngSelectorScope);
                    patchComponentDefWithScope(ngComponentDef, scopes);
                }
                if (metadata.schemas) {
                    if (metadata.standalone) ngComponentDef.schemas = metadata.schemas;
                    else throw new Error(`The 'schemas' was specified for the ${stringifyForError(type)} but is only valid on a component that is standalone.`);
                } else if (metadata.standalone) ngComponentDef.schemas = [];
            }
            return ngComponentDef;
        },
        configurable: !!ngDevMode
    });
}
function getDependencyTypeForError(type) {
    if (getComponentDef(type)) return 'component';
    if (getDirectiveDef(type)) return 'directive';
    if (getPipeDef$1(type)) return 'pipe';
    return 'type';
}
function verifyStandaloneImport(depType, importingType) {
    if (isForwardRef(depType)) {
        depType = resolveForwardRef(depType);
        if (!depType) throw new Error(`Expected forwardRef function, imported from "${stringifyForError(importingType)}", to return a standalone entity or NgModule but got "${stringifyForError(depType) || depType}".`);
    }
    if (getNgModuleDef(depType) == null) {
        const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef$1(depType);
        if (def != null) {
            if (!def.standalone) throw new Error(`The "${stringifyForError(depType)}" ${getDependencyTypeForError(depType)}, imported from "${stringifyForError(importingType)}", is not standalone. Did you forget to add the standalone: true flag?`);
        } else {
            if (isModuleWithProviders(depType)) throw new Error(`A module with providers was imported from "${stringifyForError(importingType)}". Modules with providers are not supported in standalone components imports.`);
            else throw new Error(`The "${stringifyForError(depType)}" type, imported from "${stringifyForError(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);
        }
    }
}
function getStandaloneDefFunctions(type, imports) {
    let cachedDirectiveDefs = null;
    let cachedPipeDefs = null;
    const directiveDefs = ()=>{
        if (cachedDirectiveDefs === null) {
            cachedDirectiveDefs = [
                getComponentDef(type)
            ];
            const seen = new Set();
            for (const rawDep of imports){
                ngDevMode && verifyStandaloneImport(rawDep, type);
                const dep = resolveForwardRef(rawDep);
                if (seen.has(dep)) continue;
                seen.add(dep);
                if (!!getNgModuleDef(dep)) {
                    const scope = transitiveScopesFor(dep);
                    for (const dir of scope.exported.directives){
                        const def = getComponentDef(dir) || getDirectiveDef(dir);
                        if (def && !seen.has(dir)) {
                            seen.add(dir);
                            cachedDirectiveDefs.push(def);
                        }
                    }
                } else {
                    const def = getComponentDef(dep) || getDirectiveDef(dep);
                    if (def) cachedDirectiveDefs.push(def);
                }
            }
        }
        return cachedDirectiveDefs;
    };
    const pipeDefs = ()=>{
        if (cachedPipeDefs === null) {
            cachedPipeDefs = [];
            const seen = new Set();
            for (const rawDep of imports){
                const dep = resolveForwardRef(rawDep);
                if (seen.has(dep)) continue;
                seen.add(dep);
                if (!!getNgModuleDef(dep)) {
                    const scope = transitiveScopesFor(dep);
                    for (const pipe of scope.exported.pipes){
                        const def = getPipeDef$1(pipe);
                        if (def && !seen.has(pipe)) {
                            seen.add(pipe);
                            cachedPipeDefs.push(def);
                        }
                    }
                } else {
                    const def = getPipeDef$1(dep);
                    if (def) cachedPipeDefs.push(def);
                }
            }
        }
        return cachedPipeDefs;
    };
    return {
        directiveDefs,
        pipeDefs
    };
}
function hasSelectorScope(component) {
    return component.ngSelectorScope !== undefined;
}
function compileDirective(type, directive) {
    let ngDirectiveDef = null;
    addDirectiveFactoryDef(type, directive || {});
    Object.defineProperty(type, NG_DIR_DEF, {
        get: ()=>{
            if (ngDirectiveDef === null) {
                const meta = getDirectiveMetadata(type, directive || {});
                const compiler = getCompilerFacade({
                    usage: 0,
                    kind: 'directive',
                    type
                });
                ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
            }
            return ngDirectiveDef;
        },
        configurable: !!ngDevMode
    });
}
function getDirectiveMetadata(type, metadata) {
    const name = type && type.name;
    const sourceMapUrl = `ng:///${name}/ɵdir.js`;
    const compiler = getCompilerFacade({
        usage: 0,
        kind: 'directive',
        type
    });
    const facade = directiveMetadata(type, metadata);
    facade.typeSourceSpan = compiler.createParseSourceSpan('Directive', name, sourceMapUrl);
    if (facade.usesInheritance) addDirectiveDefToUndecoratedParents(type);
    return {
        metadata: facade,
        sourceMapUrl
    };
}
function addDirectiveFactoryDef(type, metadata) {
    let ngFactoryDef = null;
    Object.defineProperty(type, NG_FACTORY_DEF, {
        get: ()=>{
            if (ngFactoryDef === null) {
                const meta = getDirectiveMetadata(type, metadata);
                const compiler = getCompilerFacade({
                    usage: 0,
                    kind: 'directive',
                    type
                });
                ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/ɵfac.js`, {
                    name: meta.metadata.name,
                    type: meta.metadata.type,
                    typeArgumentCount: 0,
                    deps: reflectDependencies(type),
                    target: compiler.FactoryTarget.Directive
                });
            }
            return ngFactoryDef;
        },
        configurable: !!ngDevMode
    });
}
function extendsDirectlyFromObject(type) {
    return Object.getPrototypeOf(type.prototype) === Object.prototype;
}
function directiveMetadata(type, metadata) {
    var _metadata_hostDirectives;
    const reflect = getReflect();
    const propMetadata = reflect.ownPropMetadata(type);
    return {
        name: type.name,
        type: type,
        selector: metadata.selector !== undefined ? metadata.selector : null,
        host: metadata.host || EMPTY_OBJ,
        propMetadata: propMetadata,
        inputs: metadata.inputs || EMPTY_ARRAY,
        outputs: metadata.outputs || EMPTY_ARRAY,
        queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
        lifecycle: {
            usesOnChanges: reflect.hasLifecycleHook(type, 'ngOnChanges')
        },
        typeSourceSpan: null,
        usesInheritance: !extendsDirectlyFromObject(type),
        exportAs: extractExportAs(metadata.exportAs),
        providers: metadata.providers || null,
        viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),
        isStandalone: !!metadata.standalone,
        hostDirectives: ((_metadata_hostDirectives = metadata.hostDirectives) === null || _metadata_hostDirectives === void 0 ? void 0 : _metadata_hostDirectives.map((directive)=>typeof directive === 'function' ? {
                directive
            } : directive)) || null
    };
}
function addDirectiveDefToUndecoratedParents(type) {
    const objPrototype = Object.prototype;
    let parent = Object.getPrototypeOf(type.prototype).constructor;
    while(parent && parent !== objPrototype){
        if (!getDirectiveDef(parent) && !getComponentDef(parent) && shouldAddAbstractDirective(parent)) compileDirective(parent, null);
        parent = Object.getPrototypeOf(parent);
    }
}
function convertToR3QueryPredicate(selector) {
    return typeof selector === 'string' ? splitByComma(selector) : resolveForwardRef(selector);
}
function convertToR3QueryMetadata(propertyName, ann) {
    return {
        propertyName: propertyName,
        predicate: convertToR3QueryPredicate(ann.selector),
        descendants: ann.descendants,
        first: ann.first,
        read: ann.read ? ann.read : null,
        static: !!ann.static,
        emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly
    };
}
function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
    const queriesMeta = [];
    for(const field in propMetadata)if (propMetadata.hasOwnProperty(field)) {
        const annotations = propMetadata[field];
        annotations.forEach((ann)=>{
            if (isQueryAnn(ann)) {
                if (!ann.selector) throw new Error(`Can't construct a query for the property "${field}" of ` + `"${stringifyForError(type)}" since the query selector wasn't defined.`);
                if (annotations.some(isInputAnnotation)) throw new Error(`Cannot combine @Input decorators with query decorators`);
                queriesMeta.push(convertToR3QueryMetadata(field, ann));
            }
        });
    }
    return queriesMeta;
}
function extractExportAs(exportAs) {
    return exportAs === undefined ? null : splitByComma(exportAs);
}
function isContentQuery(value) {
    const name = value.ngMetadataName;
    return name === 'ContentChild' || name === 'ContentChildren';
}
function isViewQuery(value) {
    const name = value.ngMetadataName;
    return name === 'ViewChild' || name === 'ViewChildren';
}
function isInputAnnotation(value) {
    return value.ngMetadataName === 'Input';
}
function splitByComma(value) {
    return value.split(',').map((piece)=>piece.trim());
}
const LIFECYCLE_HOOKS = [
    'ngOnChanges',
    'ngOnInit',
    'ngOnDestroy',
    'ngDoCheck',
    'ngAfterViewInit',
    'ngAfterViewChecked',
    'ngAfterContentInit',
    'ngAfterContentChecked'
];
function shouldAddAbstractDirective(type) {
    const reflect = getReflect();
    if (LIFECYCLE_HOOKS.some((hookName)=>reflect.hasLifecycleHook(type, hookName))) return true;
    const propMetadata = reflect.propMetadata(type);
    for(const field in propMetadata){
        const annotations = propMetadata[field];
        for(let i = 0; i < annotations.length; i++){
            const current = annotations[i];
            const metadataName = current.ngMetadataName;
            if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === 'Output' || metadataName === 'HostBinding' || metadataName === 'HostListener') return true;
        }
    }
    return false;
}
function compilePipe(type, meta) {
    let ngPipeDef = null;
    let ngFactoryDef = null;
    Object.defineProperty(type, NG_FACTORY_DEF, {
        get: ()=>{
            if (ngFactoryDef === null) {
                const metadata = getPipeMetadata(type, meta);
                const compiler = getCompilerFacade({
                    usage: 0,
                    kind: 'pipe',
                    type: metadata.type
                });
                ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/ɵfac.js`, {
                    name: metadata.name,
                    type: metadata.type,
                    typeArgumentCount: 0,
                    deps: reflectDependencies(type),
                    target: compiler.FactoryTarget.Pipe
                });
            }
            return ngFactoryDef;
        },
        configurable: !!ngDevMode
    });
    Object.defineProperty(type, NG_PIPE_DEF, {
        get: ()=>{
            if (ngPipeDef === null) {
                const metadata = getPipeMetadata(type, meta);
                const compiler = getCompilerFacade({
                    usage: 0,
                    kind: 'pipe',
                    type: metadata.type
                });
                ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/ɵpipe.js`, metadata);
            }
            return ngPipeDef;
        },
        configurable: !!ngDevMode
    });
}
function getPipeMetadata(type, meta) {
    return {
        type: type,
        name: type.name,
        pipeName: meta.name,
        pure: meta.pure !== undefined ? meta.pure : true,
        isStandalone: !!meta.standalone
    };
}
const Directive = makeDecorator('Directive', (dir = {})=>dir, undefined, undefined, (type, meta)=>compileDirective(type, meta));
makeDecorator('Component', (c = {})=>_object_spread._({
        changeDetection: ChangeDetectionStrategy.Default
    }, c), Directive, undefined, (type, meta)=>compileComponent(type, meta));
makeDecorator('Pipe', (p)=>_object_spread._({
        pure: true
    }, p), undefined, undefined, (type, meta)=>compilePipe(type, meta));
makePropDecorator('Input', (arg)=>{
    if (!arg) return {};
    return typeof arg === 'string' ? {
        alias: arg
    } : arg;
});
makePropDecorator('Output', (alias)=>({
        alias
    }));
makePropDecorator('HostBinding', (hostPropertyName)=>({
        hostPropertyName
    }));
makePropDecorator('HostListener', (eventName, args)=>({
        eventName,
        args
    }));
const NgModule = makeDecorator('NgModule', (ngModule)=>ngModule, undefined, undefined, (type, meta)=>compileNgModule(type, meta));
const APP_INITIALIZER = new InjectionToken('Application Initializer');
let ApplicationInitStatus = (()=>{
    class ApplicationInitStatus {
        runInitializers() {
            if (this.initialized) return;
            const asyncInitPromises = [];
            for (const appInits of this.appInits){
                const initResult = appInits();
                if (isPromise(initResult)) asyncInitPromises.push(initResult);
                else if (isSubscribable(initResult)) {
                    const observableAsPromise = new Promise((resolve, reject)=>{
                        initResult.subscribe({
                            complete: resolve,
                            error: reject
                        });
                    });
                    asyncInitPromises.push(observableAsPromise);
                }
            }
            const complete = ()=>{
                this.done = true;
                this.resolve();
            };
            Promise.all(asyncInitPromises).then(()=>{
                complete();
            }).catch((e)=>{
                this.reject(e);
            });
            if (asyncInitPromises.length === 0) complete();
            this.initialized = true;
        }
        constructor(){
            this.initialized = false;
            this.done = false;
            this.donePromise = new Promise((res, rej)=>{
                this.resolve = res;
                this.reject = rej;
            });
            var _inject;
            this.appInits = (_inject = inject(APP_INITIALIZER, {
                optional: true
            })) !== null && _inject !== void 0 ? _inject : [];
            if ((typeof ngDevMode === 'undefined' || ngDevMode) && !Array.isArray(this.appInits)) throw new RuntimeError(-209, 'Unexpected type of the `APP_INITIALIZER` token value ' + `(expected an array, but got ${typeof this.appInits}). ` + 'Please check that the `APP_INITIALIZER` token is configured as a ' + '`multi: true` provider.');
        }
    }
    ApplicationInitStatus.ɵfac = function ApplicationInitStatus_Factory(t) {
        return new (t || ApplicationInitStatus)();
    };
    ApplicationInitStatus.ɵprov = ɵɵdefineInjectable({
        token: ApplicationInitStatus,
        factory: ApplicationInitStatus.ɵfac,
        providedIn: 'root'
    });
    return ApplicationInitStatus;
})();
(function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [
        {
            type: Injectable,
            args: [
                {
                    providedIn: 'root'
                }
            ]
        }
    ], function() {
        return [];
    }, null);
})();
let Console = (()=>{
    class Console {
        log(message) {
            console.log(message);
        }
        warn(message) {
            console.warn(message);
        }
    }
    Console.ɵfac = function Console_Factory(t) {
        return new (t || Console)();
    };
    Console.ɵprov = ɵɵdefineInjectable({
        token: Console,
        factory: Console.ɵfac,
        providedIn: 'platform'
    });
    return Console;
})();
(function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Console, [
        {
            type: Injectable,
            args: [
                {
                    providedIn: 'platform'
                }
            ]
        }
    ], null, null);
})();
function getGlobalLocale() {
    if (typeof ngI18nClosureMode !== 'undefined' && ngI18nClosureMode && typeof goog !== 'undefined' && goog.LOCALE !== 'en') return goog.LOCALE;
    else return typeof $localize !== 'undefined' && $localize.locale || DEFAULT_LOCALE_ID;
}
const LOCALE_ID = new InjectionToken('LocaleId', {
    providedIn: 'root',
    factory: ()=>inject(LOCALE_ID, InjectFlags.Optional | InjectFlags.SkipSelf) || getGlobalLocale()
});
const DEFAULT_CURRENCY_CODE = new InjectionToken('DefaultCurrencyCode', {
    providedIn: 'root',
    factory: ()=>USD_CURRENCY_CODE
});
new InjectionToken('Translations');
new InjectionToken('TranslationsFormat');
var MissingTranslationStrategy = (()=>{
    MissingTranslationStrategy = MissingTranslationStrategy || {};
    MissingTranslationStrategy[MissingTranslationStrategy["Error"] = 0] = "Error";
    MissingTranslationStrategy[MissingTranslationStrategy["Warning"] = 1] = "Warning";
    MissingTranslationStrategy[MissingTranslationStrategy["Ignore"] = 2] = "Ignore";
    return MissingTranslationStrategy;
})();
class ModuleWithComponentFactories {
    constructor(ngModuleFactory, componentFactories){
        this.ngModuleFactory = ngModuleFactory;
        this.componentFactories = componentFactories;
    }
}
let Compiler = (()=>{
    class Compiler {
        compileModuleSync(moduleType) {
            return new NgModuleFactory(moduleType);
        }
        compileModuleAsync(moduleType) {
            return Promise.resolve(this.compileModuleSync(moduleType));
        }
        compileModuleAndAllComponentsSync(moduleType) {
            const ngModuleFactory = this.compileModuleSync(moduleType);
            const moduleDef = getNgModuleDef(moduleType);
            const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration)=>{
                const componentDef = getComponentDef(declaration);
                componentDef && factories.push(new ComponentFactory(componentDef));
                return factories;
            }, []);
            return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
        }
        compileModuleAndAllComponentsAsync(moduleType) {
            return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
        }
        clearCache() {}
        clearCacheFor(type) {}
        getModuleId(moduleType) {
            return undefined;
        }
    }
    Compiler.ɵfac = function Compiler_Factory(t) {
        return new (t || Compiler)();
    };
    Compiler.ɵprov = ɵɵdefineInjectable({
        token: Compiler,
        factory: Compiler.ɵfac,
        providedIn: 'root'
    });
    return Compiler;
})();
(function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Compiler, [
        {
            type: Injectable,
            args: [
                {
                    providedIn: 'root'
                }
            ]
        }
    ], null, null);
})();
const COMPILER_OPTIONS = new InjectionToken('compilerOptions');
function applyChanges(component) {
    ngDevMode && assertDefined(component, 'component');
    markViewDirty(getComponentViewByInstance(component));
    getRootComponents(component).forEach((rootComponent)=>detectChanges(rootComponent));
}
const GLOBAL_PUBLISH_EXPANDO_KEY = 'ng';
let _published = false;
function publishDefaultGlobalUtils$1() {
    if (!_published) {
        _published = true;
        publishGlobalUtil('ɵsetProfiler', setProfiler);
        publishGlobalUtil('getDirectiveMetadata', getDirectiveMetadata$1);
        publishGlobalUtil('getComponent', getComponent);
        publishGlobalUtil('getContext', getContext);
        publishGlobalUtil('getListeners', getListeners);
        publishGlobalUtil('getOwningComponent', getOwningComponent);
        publishGlobalUtil('getHostElement', getHostElement);
        publishGlobalUtil('getInjector', getInjector);
        publishGlobalUtil('getRootComponents', getRootComponents);
        publishGlobalUtil('getDirectives', getDirectives);
        publishGlobalUtil('applyChanges', applyChanges);
    }
}
function publishGlobalUtil(name, fn) {
    if (typeof COMPILED === 'undefined' || !COMPILED) {
        const w = _global;
        ngDevMode && assertDefined(fn, 'function not defined');
        if (w) {
            let container = w[GLOBAL_PUBLISH_EXPANDO_KEY];
            if (!container) container = w[GLOBAL_PUBLISH_EXPANDO_KEY] = {};
            container[name] = fn;
        }
    }
}
const promise = (()=>Promise.resolve(0))();
function scheduleMicroTask(fn) {
    if (typeof Zone === 'undefined') promise.then(()=>{
        fn && fn.apply(null, null);
    });
    else Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
}
function noop(...args) {}
function getNativeRequestAnimationFrame() {
    let nativeRequestAnimationFrame = _global['requestAnimationFrame'];
    let nativeCancelAnimationFrame = _global['cancelAnimationFrame'];
    if (typeof Zone !== 'undefined' && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
        const unpatchedRequestAnimationFrame = nativeRequestAnimationFrame[Zone.__symbol__('OriginalDelegate')];
        if (unpatchedRequestAnimationFrame) nativeRequestAnimationFrame = unpatchedRequestAnimationFrame;
        const unpatchedCancelAnimationFrame = nativeCancelAnimationFrame[Zone.__symbol__('OriginalDelegate')];
        if (unpatchedCancelAnimationFrame) nativeCancelAnimationFrame = unpatchedCancelAnimationFrame;
    }
    return {
        nativeRequestAnimationFrame,
        nativeCancelAnimationFrame
    };
}
class AsyncStackTaggingZoneSpec {
    onScheduleTask(delegate, _current, target, task) {
        task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);
        return delegate.scheduleTask(target, task);
    }
    onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {
        let ret;
        if (task.consoleTask) ret = task.consoleTask.run(()=>delegate.invokeTask(targetZone, task, applyThis, applyArgs));
        else ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);
        return ret;
    }
    constructor(namePrefix, consoleAsyncStackTaggingImpl = console){
        this.name = 'asyncStackTagging for ' + namePrefix;
        var _consoleAsyncStackTaggingImpl_createTask;
        this.createTask = (_consoleAsyncStackTaggingImpl_createTask = consoleAsyncStackTaggingImpl === null || consoleAsyncStackTaggingImpl === void 0 ? void 0 : consoleAsyncStackTaggingImpl.createTask) !== null && _consoleAsyncStackTaggingImpl_createTask !== void 0 ? _consoleAsyncStackTaggingImpl_createTask : ()=>null;
    }
}
class NgZone {
    static isInAngularZone() {
        return typeof Zone !== 'undefined' && Zone.current.get('isAngularZone') === true;
    }
    static assertInAngularZone() {
        if (!NgZone.isInAngularZone()) throw new RuntimeError(909, ngDevMode && 'Expected to be in Angular Zone, but it is not!');
    }
    static assertNotInAngularZone() {
        if (NgZone.isInAngularZone()) throw new RuntimeError(909, ngDevMode && 'Expected to not be in Angular Zone, but it is!');
    }
    run(fn, applyThis, applyArgs) {
        return this._inner.run(fn, applyThis, applyArgs);
    }
    runTask(fn, applyThis, applyArgs, name) {
        const zone = this._inner;
        const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);
        try {
            return zone.runTask(task, applyThis, applyArgs);
        } finally{
            zone.cancelTask(task);
        }
    }
    runGuarded(fn, applyThis, applyArgs) {
        return this._inner.runGuarded(fn, applyThis, applyArgs);
    }
    runOutsideAngular(fn) {
        return this._outer.run(fn);
    }
    constructor({ enableLongStackTrace =false , shouldCoalesceEventChangeDetection =false , shouldCoalesceRunChangeDetection =false  }){
        this.hasPendingMacrotasks = false;
        this.hasPendingMicrotasks = false;
        this.isStable = true;
        this.onUnstable = new EventEmitter(false);
        this.onMicrotaskEmpty = new EventEmitter(false);
        this.onStable = new EventEmitter(false);
        this.onError = new EventEmitter(false);
        if (typeof Zone == 'undefined') throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);
        Zone.assertZonePatched();
        const self1 = this;
        self1._nesting = 0;
        self1._outer = self1._inner = Zone.current;
        if (ngDevMode) self1._inner = self1._inner.fork(new AsyncStackTaggingZoneSpec('Angular'));
        if (Zone['TaskTrackingZoneSpec']) self1._inner = self1._inner.fork(new Zone['TaskTrackingZoneSpec']());
        if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) self1._inner = self1._inner.fork(Zone['longStackTraceZoneSpec']);
        self1.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
        self1.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
        self1.lastRequestAnimationFrameId = -1;
        self1.nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;
        forkInnerZoneWithAngularBehavior(self1);
    }
}
const EMPTY_PAYLOAD = {};
function checkStable(zone) {
    if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) try {
        zone._nesting++;
        zone.onMicrotaskEmpty.emit(null);
    } finally{
        zone._nesting--;
        if (!zone.hasPendingMicrotasks) try {
            zone.runOutsideAngular(()=>zone.onStable.emit(null));
        } finally{
            zone.isStable = true;
        }
    }
}
function delayChangeDetectionForEvents(zone) {
    if (zone.isCheckStableRunning || zone.lastRequestAnimationFrameId !== -1) return;
    zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global, ()=>{
        if (!zone.fakeTopEventTask) zone.fakeTopEventTask = Zone.root.scheduleEventTask('fakeTopEventTask', ()=>{
            zone.lastRequestAnimationFrameId = -1;
            updateMicroTaskStatus(zone);
            zone.isCheckStableRunning = true;
            checkStable(zone);
            zone.isCheckStableRunning = false;
        }, undefined, ()=>{}, ()=>{});
        zone.fakeTopEventTask.invoke();
    });
    updateMicroTaskStatus(zone);
}
function forkInnerZoneWithAngularBehavior(zone) {
    const delayChangeDetectionForEventsDelegate = ()=>{
        delayChangeDetectionForEvents(zone);
    };
    zone._inner = zone._inner.fork({
        name: 'angular',
        properties: {
            'isAngularZone': true
        },
        onInvokeTask: (delegate, current, target, task, applyThis, applyArgs)=>{
            try {
                onEnter(zone);
                return delegate.invokeTask(target, task, applyThis, applyArgs);
            } finally{
                if (zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask' || zone.shouldCoalesceRunChangeDetection) delayChangeDetectionForEventsDelegate();
                onLeave(zone);
            }
        },
        onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source)=>{
            try {
                onEnter(zone);
                return delegate.invoke(target, callback, applyThis, applyArgs, source);
            } finally{
                if (zone.shouldCoalesceRunChangeDetection) delayChangeDetectionForEventsDelegate();
                onLeave(zone);
            }
        },
        onHasTask: (delegate, current, target, hasTaskState)=>{
            delegate.hasTask(target, hasTaskState);
            if (current === target) {
                if (hasTaskState.change == 'microTask') {
                    zone._hasPendingMicrotasks = hasTaskState.microTask;
                    updateMicroTaskStatus(zone);
                    checkStable(zone);
                } else if (hasTaskState.change == 'macroTask') zone.hasPendingMacrotasks = hasTaskState.macroTask;
            }
        },
        onHandleError: (delegate, current, target, error)=>{
            delegate.handleError(target, error);
            zone.runOutsideAngular(()=>zone.onError.emit(error));
            return false;
        }
    });
}
function updateMicroTaskStatus(zone) {
    if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.lastRequestAnimationFrameId !== -1) zone.hasPendingMicrotasks = true;
    else zone.hasPendingMicrotasks = false;
}
function onEnter(zone) {
    zone._nesting++;
    if (zone.isStable) {
        zone.isStable = false;
        zone.onUnstable.emit(null);
    }
}
function onLeave(zone) {
    zone._nesting--;
    checkStable(zone);
}
class NoopNgZone {
    run(fn, applyThis, applyArgs) {
        return fn.apply(applyThis, applyArgs);
    }
    runGuarded(fn, applyThis, applyArgs) {
        return fn.apply(applyThis, applyArgs);
    }
    runOutsideAngular(fn) {
        return fn();
    }
    runTask(fn, applyThis, applyArgs, name) {
        return fn.apply(applyThis, applyArgs);
    }
    constructor(){
        this.hasPendingMicrotasks = false;
        this.hasPendingMacrotasks = false;
        this.isStable = true;
        this.onUnstable = new EventEmitter();
        this.onMicrotaskEmpty = new EventEmitter();
        this.onStable = new EventEmitter();
        this.onError = new EventEmitter();
    }
}
const ZONE_IS_STABLE_OBSERVABLE = new InjectionToken(ngDevMode ? 'isStable Observable' : '', {
    providedIn: 'root',
    factory: isStableFactory
});
function isStableFactory() {
    const zone = inject(NgZone);
    let _stable = true;
    const isCurrentlyStable = new _index.Observable((observer)=>{
        _stable = zone.isStable && !zone.hasPendingMacrotasks && !zone.hasPendingMicrotasks;
        zone.runOutsideAngular(()=>{
            observer.next(_stable);
            observer.complete();
        });
    });
    const isStable = new _index.Observable((observer)=>{
        let stableSub;
        zone.runOutsideAngular(()=>{
            stableSub = zone.onStable.subscribe(()=>{
                NgZone.assertNotInAngularZone();
                scheduleMicroTask(()=>{
                    if (!_stable && !zone.hasPendingMacrotasks && !zone.hasPendingMicrotasks) {
                        _stable = true;
                        observer.next(true);
                    }
                });
            });
        });
        const unstableSub = zone.onUnstable.subscribe(()=>{
            NgZone.assertInAngularZone();
            if (_stable) {
                _stable = false;
                zone.runOutsideAngular(()=>{
                    observer.next(false);
                });
            }
        });
        return ()=>{
            stableSub.unsubscribe();
            unstableSub.unsubscribe();
        };
    });
    return (0, _index.merge)(isCurrentlyStable, isStable.pipe((0, _index1.share)()));
}
const TESTABILITY = new InjectionToken('');
const TESTABILITY_GETTER = new InjectionToken('');
let Testability = (()=>{
    class Testability {
        _watchAngularEvents() {
            this._ngZone.onUnstable.subscribe({
                next: ()=>{
                    this._didWork = true;
                    this._isZoneStable = false;
                }
            });
            this._ngZone.runOutsideAngular(()=>{
                this._ngZone.onStable.subscribe({
                    next: ()=>{
                        NgZone.assertNotInAngularZone();
                        scheduleMicroTask(()=>{
                            this._isZoneStable = true;
                            this._runCallbacksIfReady();
                        });
                    }
                });
            });
        }
        increasePendingRequestCount() {
            this._pendingCount += 1;
            this._didWork = true;
            return this._pendingCount;
        }
        decreasePendingRequestCount() {
            this._pendingCount -= 1;
            if (this._pendingCount < 0) throw new Error('pending async requests below zero');
            this._runCallbacksIfReady();
            return this._pendingCount;
        }
        isStable() {
            return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;
        }
        _runCallbacksIfReady() {
            if (this.isStable()) scheduleMicroTask(()=>{
                while(this._callbacks.length !== 0){
                    let cb = this._callbacks.pop();
                    clearTimeout(cb.timeoutId);
                    cb.doneCb(this._didWork);
                }
                this._didWork = false;
            });
            else {
                let pending = this.getPendingTasks();
                this._callbacks = this._callbacks.filter((cb)=>{
                    if (cb.updateCb && cb.updateCb(pending)) {
                        clearTimeout(cb.timeoutId);
                        return false;
                    }
                    return true;
                });
                this._didWork = true;
            }
        }
        getPendingTasks() {
            if (!this.taskTrackingZone) return [];
            return this.taskTrackingZone.macroTasks.map((t)=>{
                return {
                    source: t.source,
                    creationLocation: t.creationLocation,
                    data: t.data
                };
            });
        }
        addCallback(cb, timeout, updateCb) {
            let timeoutId = -1;
            if (timeout && timeout > 0) timeoutId = setTimeout(()=>{
                this._callbacks = this._callbacks.filter((cb)=>cb.timeoutId !== timeoutId);
                cb(this._didWork, this.getPendingTasks());
            }, timeout);
            this._callbacks.push({
                doneCb: cb,
                timeoutId: timeoutId,
                updateCb: updateCb
            });
        }
        whenStable(doneCb, timeout, updateCb) {
            if (updateCb && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
            this.addCallback(doneCb, timeout, updateCb);
            this._runCallbacksIfReady();
        }
        getPendingRequestCount() {
            return this._pendingCount;
        }
        registerApplication(token) {
            this.registry.registerApplication(token, this);
        }
        unregisterApplication(token) {
            this.registry.unregisterApplication(token);
        }
        findProviders(using, provider, exactMatch) {
            return [];
        }
        constructor(_ngZone, registry, testabilityGetter){
            this._ngZone = _ngZone;
            this.registry = registry;
            this._pendingCount = 0;
            this._isZoneStable = true;
            this._didWork = false;
            this._callbacks = [];
            this.taskTrackingZone = null;
            if (!_testabilityGetter) {
                setTestabilityGetter(testabilityGetter);
                testabilityGetter.addToWindow(registry);
            }
            this._watchAngularEvents();
            _ngZone.run(()=>{
                this.taskTrackingZone = typeof Zone == 'undefined' ? null : Zone.current.get('TaskTrackingZone');
            });
        }
    }
    Testability.ɵfac = function Testability_Factory(t) {
        return new (t || Testability)(ɵɵinject(NgZone), ɵɵinject(TestabilityRegistry), ɵɵinject(TESTABILITY_GETTER));
    };
    Testability.ɵprov = ɵɵdefineInjectable({
        token: Testability,
        factory: Testability.ɵfac
    });
    return Testability;
})();
(function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Testability, [
        {
            type: Injectable
        }
    ], function() {
        return [
            {
                type: NgZone
            },
            {
                type: TestabilityRegistry
            },
            {
                type: undefined,
                decorators: [
                    {
                        type: Inject,
                        args: [
                            TESTABILITY_GETTER
                        ]
                    }
                ]
            }
        ];
    }, null);
})();
let TestabilityRegistry = (()=>{
    class TestabilityRegistry {
        registerApplication(token, testability) {
            this._applications.set(token, testability);
        }
        unregisterApplication(token) {
            this._applications.delete(token);
        }
        unregisterAllApplications() {
            this._applications.clear();
        }
        getTestability(elem) {
            return this._applications.get(elem) || null;
        }
        getAllTestabilities() {
            return Array.from(this._applications.values());
        }
        getAllRootElements() {
            return Array.from(this._applications.keys());
        }
        findTestabilityInTree(elem, findInAncestors = true) {
            var _testabilityGetter_findTestabilityInTree;
            return (_testabilityGetter_findTestabilityInTree = _testabilityGetter === null || _testabilityGetter === void 0 ? void 0 : _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors)) !== null && _testabilityGetter_findTestabilityInTree !== void 0 ? _testabilityGetter_findTestabilityInTree : null;
        }
        constructor(){
            this._applications = new Map();
        }
    }
    TestabilityRegistry.ɵfac = function TestabilityRegistry_Factory(t) {
        return new (t || TestabilityRegistry)();
    };
    TestabilityRegistry.ɵprov = ɵɵdefineInjectable({
        token: TestabilityRegistry,
        factory: TestabilityRegistry.ɵfac,
        providedIn: 'platform'
    });
    return TestabilityRegistry;
})();
(function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TestabilityRegistry, [
        {
            type: Injectable,
            args: [
                {
                    providedIn: 'platform'
                }
            ]
        }
    ], null, null);
})();
function setTestabilityGetter(getter) {
    _testabilityGetter = getter;
}
let _testabilityGetter;
let _platformInjector = null;
const ALLOW_MULTIPLE_PLATFORMS = new InjectionToken('AllowMultipleToken');
const PLATFORM_DESTROY_LISTENERS = new InjectionToken('PlatformDestroyListeners');
const APP_BOOTSTRAP_LISTENER = new InjectionToken('appBootstrapListener');
function compileNgModuleFactory(injector, options, moduleType) {
    ngDevMode && assertNgModuleType(moduleType);
    const moduleFactory = new NgModuleFactory(moduleType);
    if (typeof ngJitMode !== 'undefined' && !ngJitMode) return Promise.resolve(moduleFactory);
    const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);
    setJitOptions({
        defaultEncapsulation: _lastDefined(compilerOptions.map((opts)=>opts.defaultEncapsulation)),
        preserveWhitespaces: _lastDefined(compilerOptions.map((opts)=>opts.preserveWhitespaces))
    });
    if (isComponentResourceResolutionQueueEmpty()) return Promise.resolve(moduleFactory);
    var _option_providers;
    const compilerProviders = compilerOptions.flatMap((option)=>(_option_providers = option.providers) !== null && _option_providers !== void 0 ? _option_providers : []);
    if (compilerProviders.length === 0) return Promise.resolve(moduleFactory);
    const compiler = getCompilerFacade({
        usage: 0,
        kind: 'NgModule',
        type: moduleType
    });
    const compilerInjector = Injector.create({
        providers: compilerProviders
    });
    const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
    return resolveComponentResources((url)=>Promise.resolve(resourceLoader.get(url))).then(()=>moduleFactory);
}
function publishDefaultGlobalUtils() {
    ngDevMode && publishDefaultGlobalUtils$1();
}
function publishSignalConfiguration() {
    setThrowInvalidWriteToSignalError(()=>{
        throw new RuntimeError(600, ngDevMode && "Writing to signals is not allowed in a `computed` or an `effect` by default. Use `allowSignalWrites` in the `CreateEffectOptions` to enable this inside effects.");
    });
}
function isBoundToModule(cf) {
    return cf.isBoundToModule;
}
class NgProbeToken {
    constructor(name, token){
        this.name = name;
        this.token = token;
    }
}
function createPlatform(injector) {
    if (_platformInjector && !_platformInjector.get(ALLOW_MULTIPLE_PLATFORMS, false)) throw new RuntimeError(400, ngDevMode && 'There can be only one platform. Destroy the previous one to create a new one.');
    publishDefaultGlobalUtils();
    publishSignalConfiguration();
    _platformInjector = injector;
    const platform = injector.get(PlatformRef);
    runPlatformInitializers(injector);
    return platform;
}
function runPlatformInitializers(injector) {
    const inits = injector.get(PLATFORM_INITIALIZER, null);
    inits === null || inits === void 0 || inits.forEach((init)=>init());
}
function createPlatformFactory(parentPlatformFactory, name, providers = []) {
    const desc = `Platform: ${name}`;
    const marker = new InjectionToken(desc);
    return (extraProviders = [])=>{
        let platform = getPlatform();
        if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
            const platformProviders = [
                ...providers,
                ...extraProviders,
                {
                    provide: marker,
                    useValue: true
                }
            ];
            if (parentPlatformFactory) parentPlatformFactory(platformProviders);
            else createPlatform(createPlatformInjector(platformProviders, desc));
        }
        return assertPlatform(marker);
    };
}
function assertPlatform(requiredToken) {
    const platform = getPlatform();
    if (!platform) throw new RuntimeError(401, ngDevMode && 'No platform exists!');
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !platform.injector.get(requiredToken, null)) throw new RuntimeError(400, 'A platform with a different configuration has been created. Please destroy it first.');
    return platform;
}
function createPlatformInjector(providers = [], name) {
    return Injector.create({
        name,
        providers: [
            {
                provide: INJECTOR_SCOPE,
                useValue: 'platform'
            },
            {
                provide: PLATFORM_DESTROY_LISTENERS,
                useValue: new Set([
                    ()=>_platformInjector = null
                ])
            },
            ...providers
        ]
    });
}
function getPlatform() {
    var _platformInjector_get;
    return (_platformInjector_get = _platformInjector === null || _platformInjector === void 0 ? void 0 : _platformInjector.get(PlatformRef)) !== null && _platformInjector_get !== void 0 ? _platformInjector_get : null;
}
let PlatformRef = (()=>{
    class PlatformRef {
        bootstrapModuleFactory(moduleFactory, options) {
            const ngZone = getNgZone(options === null || options === void 0 ? void 0 : options.ngZone, getNgZoneOptions({
                eventCoalescing: options === null || options === void 0 ? void 0 : options.ngZoneEventCoalescing,
                runCoalescing: options === null || options === void 0 ? void 0 : options.ngZoneRunCoalescing
            }));
            return ngZone.run(()=>{
                const moduleRef = createNgModuleRefWithProviders(moduleFactory.moduleType, this.injector, internalProvideZoneChangeDetection(()=>ngZone));
                if ((typeof ngDevMode === 'undefined' || ngDevMode) && moduleRef.injector.get(PROVIDED_NG_ZONE, null) !== null) throw new RuntimeError(207, '`bootstrapModule` does not support `provideZoneChangeDetection`. Use `BootstrapOptions` instead.');
                const exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
                if ((typeof ngDevMode === 'undefined' || ngDevMode) && exceptionHandler === null) throw new RuntimeError(402, 'No ErrorHandler. Is platform module (BrowserModule) included?');
                ngZone.runOutsideAngular(()=>{
                    const subscription = ngZone.onError.subscribe({
                        next: (error)=>{
                            exceptionHandler.handleError(error);
                        }
                    });
                    moduleRef.onDestroy(()=>{
                        remove(this._modules, moduleRef);
                        subscription.unsubscribe();
                    });
                });
                return _callAndReportToErrorHandler(exceptionHandler, ngZone, ()=>{
                    const initStatus = moduleRef.injector.get(ApplicationInitStatus);
                    initStatus.runInitializers();
                    return initStatus.donePromise.then(()=>{
                        const localeId = moduleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
                        setLocaleId(localeId || DEFAULT_LOCALE_ID);
                        this._moduleDoBootstrap(moduleRef);
                        return moduleRef;
                    });
                });
            });
        }
        bootstrapModule(moduleType, compilerOptions = []) {
            const options = optionsReducer({}, compilerOptions);
            return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory)=>this.bootstrapModuleFactory(moduleFactory, options));
        }
        _moduleDoBootstrap(moduleRef) {
            const appRef = moduleRef.injector.get(ApplicationRef);
            if (moduleRef._bootstrapComponents.length > 0) moduleRef._bootstrapComponents.forEach((f)=>appRef.bootstrap(f));
            else if (moduleRef.instance.ngDoBootstrap) moduleRef.instance.ngDoBootstrap(appRef);
            else throw new RuntimeError(-403, ngDevMode && `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, ` + `but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. ` + `Please define one of these.`);
            this._modules.push(moduleRef);
        }
        onDestroy(callback) {
            this._destroyListeners.push(callback);
        }
        get injector() {
            return this._injector;
        }
        destroy() {
            if (this._destroyed) throw new RuntimeError(404, ngDevMode && 'The platform has already been destroyed!');
            this._modules.slice().forEach((module)=>module.destroy());
            this._destroyListeners.forEach((listener)=>listener());
            const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);
            if (destroyListeners) {
                destroyListeners.forEach((listener)=>listener());
                destroyListeners.clear();
            }
            this._destroyed = true;
        }
        get destroyed() {
            return this._destroyed;
        }
        constructor(_injector){
            this._injector = _injector;
            this._modules = [];
            this._destroyListeners = [];
            this._destroyed = false;
        }
    }
    PlatformRef.ɵfac = function PlatformRef_Factory(t) {
        return new (t || PlatformRef)(ɵɵinject(Injector));
    };
    PlatformRef.ɵprov = ɵɵdefineInjectable({
        token: PlatformRef,
        factory: PlatformRef.ɵfac,
        providedIn: 'platform'
    });
    return PlatformRef;
})();
(function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformRef, [
        {
            type: Injectable,
            args: [
                {
                    providedIn: 'platform'
                }
            ]
        }
    ], function() {
        return [
            {
                type: Injector
            }
        ];
    }, null);
})();
function getNgZoneOptions(options) {
    var _options_eventCoalescing, _options_runCoalescing;
    return {
        enableLongStackTrace: typeof ngDevMode === 'undefined' ? false : !!ngDevMode,
        shouldCoalesceEventChangeDetection: (_options_eventCoalescing = options === null || options === void 0 ? void 0 : options.eventCoalescing) !== null && _options_eventCoalescing !== void 0 ? _options_eventCoalescing : false,
        shouldCoalesceRunChangeDetection: (_options_runCoalescing = options === null || options === void 0 ? void 0 : options.runCoalescing) !== null && _options_runCoalescing !== void 0 ? _options_runCoalescing : false
    };
}
function getNgZone(ngZoneToUse = 'zone.js', options) {
    if (ngZoneToUse === 'noop') return new NoopNgZone();
    if (ngZoneToUse === 'zone.js') return new NgZone(options);
    return ngZoneToUse;
}
function _callAndReportToErrorHandler(errorHandler, ngZone, callback) {
    try {
        const result = callback();
        if (isPromise(result)) return result.catch((e)=>{
            ngZone.runOutsideAngular(()=>errorHandler.handleError(e));
            throw e;
        });
        return result;
    } catch (e) {
        ngZone.runOutsideAngular(()=>errorHandler.handleError(e));
        throw e;
    }
}
function optionsReducer(dst, objs) {
    if (Array.isArray(objs)) return objs.reduce(optionsReducer, dst);
    return _object_spread._({}, dst, objs);
}
let ApplicationRef = (()=>{
    class ApplicationRef {
        get destroyed() {
            return this._destroyed;
        }
        get injector() {
            return this._injector;
        }
        bootstrap(componentOrFactory, rootSelectorOrNode) {
            (typeof ngDevMode === 'undefined' || ngDevMode) && this.warnIfDestroyed();
            const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;
            const initStatus = this._injector.get(ApplicationInitStatus);
            if (!initStatus.done) {
                const standalone = !isComponentFactory && isStandalone(componentOrFactory);
                const errorMessage = 'Cannot bootstrap as there are still asynchronous initializers running.' + (standalone ? '' : ' Bootstrap components in the `ngDoBootstrap` method of the root module.');
                throw new RuntimeError(405, (typeof ngDevMode === 'undefined' || ngDevMode) && errorMessage);
            }
            let componentFactory;
            if (isComponentFactory) componentFactory = componentOrFactory;
            else {
                const resolver = this._injector.get(ComponentFactoryResolver$1);
                componentFactory = resolver.resolveComponentFactory(componentOrFactory);
            }
            this.componentTypes.push(componentFactory.componentType);
            const ngModule = isBoundToModule(componentFactory) ? undefined : this._injector.get(NgModuleRef$1);
            const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
            const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
            const nativeElement = compRef.location.nativeElement;
            const testability = compRef.injector.get(TESTABILITY, null);
            testability === null || testability === void 0 || testability.registerApplication(nativeElement);
            compRef.onDestroy(()=>{
                this.detachView(compRef.hostView);
                remove(this.components, compRef);
                testability === null || testability === void 0 || testability.unregisterApplication(nativeElement);
            });
            this._loadComponent(compRef);
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                const _console = this._injector.get(Console);
                _console.log(`Angular is running in development mode.`);
            }
            return compRef;
        }
        tick() {
            (typeof ngDevMode === 'undefined' || ngDevMode) && this.warnIfDestroyed();
            if (this._runningTick) throw new RuntimeError(101, ngDevMode && 'ApplicationRef.tick is called recursively');
            try {
                this._runningTick = true;
                for (let view of this._views)view.detectChanges();
                if (typeof ngDevMode === 'undefined' || ngDevMode) for (let view of this._views)view.checkNoChanges();
            } catch (e) {
                this.internalErrorHandler(e);
            } finally{
                this._runningTick = false;
            }
        }
        attachView(viewRef) {
            (typeof ngDevMode === 'undefined' || ngDevMode) && this.warnIfDestroyed();
            const view = viewRef;
            this._views.push(view);
            view.attachToAppRef(this);
        }
        detachView(viewRef) {
            (typeof ngDevMode === 'undefined' || ngDevMode) && this.warnIfDestroyed();
            const view = viewRef;
            remove(this._views, view);
            view.detachFromAppRef();
        }
        _loadComponent(componentRef) {
            this.attachView(componentRef.hostView);
            this.tick();
            this.components.push(componentRef);
            const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []);
            if (ngDevMode && !Array.isArray(listeners)) throw new RuntimeError(-209, 'Unexpected type of the `APP_BOOTSTRAP_LISTENER` token value ' + `(expected an array, but got ${typeof listeners}). ` + 'Please check that the `APP_BOOTSTRAP_LISTENER` token is configured as a ' + '`multi: true` provider.');
            listeners.push(...this._bootstrapListeners);
            listeners.forEach((listener)=>listener(componentRef));
        }
        ngOnDestroy() {
            if (this._destroyed) return;
            try {
                this._destroyListeners.forEach((listener)=>listener());
                this._views.slice().forEach((view)=>view.destroy());
            } finally{
                this._destroyed = true;
                this._views = [];
                this._bootstrapListeners = [];
                this._destroyListeners = [];
            }
        }
        onDestroy(callback) {
            (typeof ngDevMode === 'undefined' || ngDevMode) && this.warnIfDestroyed();
            this._destroyListeners.push(callback);
            return ()=>remove(this._destroyListeners, callback);
        }
        destroy() {
            if (this._destroyed) throw new RuntimeError(406, ngDevMode && 'This instance of the `ApplicationRef` has already been destroyed.');
            const injector = this._injector;
            if (injector.destroy && !injector.destroyed) injector.destroy();
        }
        get viewCount() {
            return this._views.length;
        }
        warnIfDestroyed() {
            if ((typeof ngDevMode === 'undefined' || ngDevMode) && this._destroyed) console.warn(formatRuntimeError(406, 'This instance of the `ApplicationRef` has already been destroyed.'));
        }
        constructor(){
            this._bootstrapListeners = [];
            this._runningTick = false;
            this._destroyed = false;
            this._destroyListeners = [];
            this._views = [];
            this.internalErrorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
            this.componentTypes = [];
            this.components = [];
            this.isStable = inject(ZONE_IS_STABLE_OBSERVABLE);
            this._injector = inject(EnvironmentInjector);
        }
    }
    ApplicationRef.ɵfac = function ApplicationRef_Factory(t) {
        return new (t || ApplicationRef)();
    };
    ApplicationRef.ɵprov = ɵɵdefineInjectable({
        token: ApplicationRef,
        factory: ApplicationRef.ɵfac,
        providedIn: 'root'
    });
    return ApplicationRef;
})();
(function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationRef, [
        {
            type: Injectable,
            args: [
                {
                    providedIn: 'root'
                }
            ]
        }
    ], null, null);
})();
function remove(list, el) {
    const index = list.indexOf(el);
    if (index > -1) list.splice(index, 1);
}
function _lastDefined(args) {
    for(let i = args.length - 1; i >= 0; i--){
        if (args[i] !== undefined) return args[i];
    }
    return undefined;
}
const INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'internal error handler' : '', {
    providedIn: 'root',
    factory: ()=>{
        const userErrorHandler = inject(ErrorHandler);
        return userErrorHandler.handleError.bind(undefined);
    }
});
function ngZoneApplicationErrorHandlerFactory() {
    const zone = inject(NgZone);
    const userErrorHandler = inject(ErrorHandler);
    return (e)=>zone.runOutsideAngular(()=>userErrorHandler.handleError(e));
}
let NgZoneChangeDetectionScheduler = (()=>{
    class NgZoneChangeDetectionScheduler {
        initialize() {
            if (this._onMicrotaskEmptySubscription) return;
            this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
                next: ()=>{
                    this.zone.run(()=>{
                        this.applicationRef.tick();
                    });
                }
            });
        }
        ngOnDestroy() {
            var _this__onMicrotaskEmptySubscription;
            (_this__onMicrotaskEmptySubscription = this._onMicrotaskEmptySubscription) === null || _this__onMicrotaskEmptySubscription === void 0 || _this__onMicrotaskEmptySubscription.unsubscribe();
        }
        constructor(){
            this.zone = inject(NgZone);
            this.applicationRef = inject(ApplicationRef);
        }
    }
    NgZoneChangeDetectionScheduler.ɵfac = function NgZoneChangeDetectionScheduler_Factory(t) {
        return new (t || NgZoneChangeDetectionScheduler)();
    };
    NgZoneChangeDetectionScheduler.ɵprov = ɵɵdefineInjectable({
        token: NgZoneChangeDetectionScheduler,
        factory: NgZoneChangeDetectionScheduler.ɵfac,
        providedIn: 'root'
    });
    return NgZoneChangeDetectionScheduler;
})();
(function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgZoneChangeDetectionScheduler, [
        {
            type: Injectable,
            args: [
                {
                    providedIn: 'root'
                }
            ]
        }
    ], null, null);
})();
const PROVIDED_NG_ZONE = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'provideZoneChangeDetection token' : '');
function internalProvideZoneChangeDetection(ngZoneFactory) {
    return [
        {
            provide: NgZone,
            useFactory: ngZoneFactory
        },
        {
            provide: ENVIRONMENT_INITIALIZER,
            multi: true,
            useFactory: ()=>{
                const ngZoneChangeDetectionScheduler = inject(NgZoneChangeDetectionScheduler, {
                    optional: true
                });
                if ((typeof ngDevMode === 'undefined' || ngDevMode) && ngZoneChangeDetectionScheduler === null) throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. ` + 'If you are bootstrapping an NgModule, make sure that the `BrowserModule` is imported.');
                return ()=>ngZoneChangeDetectionScheduler.initialize();
            }
        },
        {
            provide: INTERNAL_APPLICATION_ERROR_HANDLER,
            useFactory: ngZoneApplicationErrorHandlerFactory
        },
        {
            provide: ZONE_IS_STABLE_OBSERVABLE,
            useFactory: isStableFactory
        }
    ];
}
let ChangeDetectorRef = (()=>{
    class ChangeDetectorRef {
    }
    ChangeDetectorRef.__NG_ELEMENT_ID__ = injectChangeDetectorRef;
    return ChangeDetectorRef;
})();
function injectChangeDetectorRef(flags) {
    return createViewRef(getCurrentTNode(), getLView(), (flags & 16) === 16);
}
function createViewRef(tNode, lView, isPipe) {
    if (isComponentHost(tNode) && !isPipe) {
        const componentView = getComponentLViewByIndex(tNode.index, lView);
        return new ViewRef$1(componentView, componentView);
    } else if (tNode.type & 47) {
        const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];
        return new ViewRef$1(hostComponentView, lView);
    }
    return null;
}
new Map();
class DefaultIterableDifferFactory {
    supports(obj) {
        return isListLikeIterable(obj);
    }
    create(trackByFn) {
        return new DefaultIterableDiffer(trackByFn);
    }
    constructor(){}
}
const trackByIdentity = (index, item)=>item;
class DefaultIterableDiffer {
    forEachItem(fn) {
        let record;
        for(record = this._itHead; record !== null; record = record._next)fn(record);
    }
    forEachOperation(fn) {
        let nextIt = this._itHead;
        let nextRemove = this._removalsHead;
        let addRemoveOffset = 0;
        let moveOffsets = null;
        while(nextIt || nextRemove){
            const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
            const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
            const currentIndex = record.currentIndex;
            if (record === nextRemove) {
                addRemoveOffset--;
                nextRemove = nextRemove._nextRemoved;
            } else {
                nextIt = nextIt._next;
                if (record.previousIndex == null) addRemoveOffset++;
                else {
                    if (!moveOffsets) moveOffsets = [];
                    const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
                    const localCurrentIndex = currentIndex - addRemoveOffset;
                    if (localMovePreviousIndex != localCurrentIndex) {
                        for(let i = 0; i < localMovePreviousIndex; i++){
                            const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
                            const index = offset + i;
                            if (localCurrentIndex <= index && index < localMovePreviousIndex) moveOffsets[i] = offset + 1;
                        }
                        const previousIndex = record.previousIndex;
                        moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
                    }
                }
            }
            if (adjPreviousIndex !== currentIndex) fn(record, adjPreviousIndex, currentIndex);
        }
    }
    forEachPreviousItem(fn) {
        let record;
        for(record = this._previousItHead; record !== null; record = record._nextPrevious)fn(record);
    }
    forEachAddedItem(fn) {
        let record;
        for(record = this._additionsHead; record !== null; record = record._nextAdded)fn(record);
    }
    forEachMovedItem(fn) {
        let record;
        for(record = this._movesHead; record !== null; record = record._nextMoved)fn(record);
    }
    forEachRemovedItem(fn) {
        let record;
        for(record = this._removalsHead; record !== null; record = record._nextRemoved)fn(record);
    }
    forEachIdentityChange(fn) {
        let record;
        for(record = this._identityChangesHead; record !== null; record = record._nextIdentityChange)fn(record);
    }
    diff(collection) {
        if (collection == null) collection = [];
        if (!isListLikeIterable(collection)) throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);
        if (this.check(collection)) return this;
        else return null;
    }
    onDestroy() {}
    check(collection) {
        this._reset();
        let record = this._itHead;
        let mayBeDirty = false;
        let index;
        let item;
        let itemTrackBy;
        if (Array.isArray(collection)) {
            this.length = collection.length;
            for(let index = 0; index < this.length; index++){
                item = collection[index];
                itemTrackBy = this._trackByFn(index, item);
                if (record === null || !Object.is(record.trackById, itemTrackBy)) {
                    record = this._mismatch(record, item, itemTrackBy, index);
                    mayBeDirty = true;
                } else {
                    if (mayBeDirty) record = this._verifyReinsertion(record, item, itemTrackBy, index);
                    if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
                }
                record = record._next;
            }
        } else {
            index = 0;
            iterateListLike(collection, (item)=>{
                itemTrackBy = this._trackByFn(index, item);
                if (record === null || !Object.is(record.trackById, itemTrackBy)) {
                    record = this._mismatch(record, item, itemTrackBy, index);
                    mayBeDirty = true;
                } else {
                    if (mayBeDirty) record = this._verifyReinsertion(record, item, itemTrackBy, index);
                    if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
                }
                record = record._next;
                index++;
            });
            this.length = index;
        }
        this._truncate(record);
        this.collection = collection;
        return this.isDirty;
    }
    get isDirty() {
        return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
    }
    _reset() {
        if (this.isDirty) {
            let record;
            for(record = this._previousItHead = this._itHead; record !== null; record = record._next)record._nextPrevious = record._next;
            for(record = this._additionsHead; record !== null; record = record._nextAdded)record.previousIndex = record.currentIndex;
            this._additionsHead = this._additionsTail = null;
            for(record = this._movesHead; record !== null; record = record._nextMoved)record.previousIndex = record.currentIndex;
            this._movesHead = this._movesTail = null;
            this._removalsHead = this._removalsTail = null;
            this._identityChangesHead = this._identityChangesTail = null;
        }
    }
    _mismatch(record, item, itemTrackBy, index) {
        let previousRecord;
        if (record === null) previousRecord = this._itTail;
        else {
            previousRecord = record._prev;
            this._remove(record);
        }
        record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
        if (record !== null) {
            if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
            this._reinsertAfter(record, previousRecord, index);
        } else {
            record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
            if (record !== null) {
                if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
                this._moveAfter(record, previousRecord, index);
            } else record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
        }
        return record;
    }
    _verifyReinsertion(record, item, itemTrackBy, index) {
        let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
        if (reinsertRecord !== null) record = this._reinsertAfter(reinsertRecord, record._prev, index);
        else if (record.currentIndex != index) {
            record.currentIndex = index;
            this._addToMoves(record, index);
        }
        return record;
    }
    _truncate(record) {
        while(record !== null){
            const nextRecord = record._next;
            this._addToRemovals(this._unlink(record));
            record = nextRecord;
        }
        if (this._unlinkedRecords !== null) this._unlinkedRecords.clear();
        if (this._additionsTail !== null) this._additionsTail._nextAdded = null;
        if (this._movesTail !== null) this._movesTail._nextMoved = null;
        if (this._itTail !== null) this._itTail._next = null;
        if (this._removalsTail !== null) this._removalsTail._nextRemoved = null;
        if (this._identityChangesTail !== null) this._identityChangesTail._nextIdentityChange = null;
    }
    _reinsertAfter(record, prevRecord, index) {
        if (this._unlinkedRecords !== null) this._unlinkedRecords.remove(record);
        const prev = record._prevRemoved;
        const next = record._nextRemoved;
        if (prev === null) this._removalsHead = next;
        else prev._nextRemoved = next;
        if (next === null) this._removalsTail = prev;
        else next._prevRemoved = prev;
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
    }
    _moveAfter(record, prevRecord, index) {
        this._unlink(record);
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
    }
    _addAfter(record, prevRecord, index) {
        this._insertAfter(record, prevRecord, index);
        if (this._additionsTail === null) this._additionsTail = this._additionsHead = record;
        else this._additionsTail = this._additionsTail._nextAdded = record;
        return record;
    }
    _insertAfter(record, prevRecord, index) {
        const next = prevRecord === null ? this._itHead : prevRecord._next;
        record._next = next;
        record._prev = prevRecord;
        if (next === null) this._itTail = record;
        else next._prev = record;
        if (prevRecord === null) this._itHead = record;
        else prevRecord._next = record;
        if (this._linkedRecords === null) this._linkedRecords = new _DuplicateMap();
        this._linkedRecords.put(record);
        record.currentIndex = index;
        return record;
    }
    _remove(record) {
        return this._addToRemovals(this._unlink(record));
    }
    _unlink(record) {
        if (this._linkedRecords !== null) this._linkedRecords.remove(record);
        const prev = record._prev;
        const next = record._next;
        if (prev === null) this._itHead = next;
        else prev._next = next;
        if (next === null) this._itTail = prev;
        else next._prev = prev;
        return record;
    }
    _addToMoves(record, toIndex) {
        if (record.previousIndex === toIndex) return record;
        if (this._movesTail === null) this._movesTail = this._movesHead = record;
        else this._movesTail = this._movesTail._nextMoved = record;
        return record;
    }
    _addToRemovals(record) {
        if (this._unlinkedRecords === null) this._unlinkedRecords = new _DuplicateMap();
        this._unlinkedRecords.put(record);
        record.currentIndex = null;
        record._nextRemoved = null;
        if (this._removalsTail === null) {
            this._removalsTail = this._removalsHead = record;
            record._prevRemoved = null;
        } else {
            record._prevRemoved = this._removalsTail;
            this._removalsTail = this._removalsTail._nextRemoved = record;
        }
        return record;
    }
    _addIdentityChange(record, item) {
        record.item = item;
        if (this._identityChangesTail === null) this._identityChangesTail = this._identityChangesHead = record;
        else this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
        return record;
    }
    constructor(trackByFn){
        this.length = 0;
        this._linkedRecords = null;
        this._unlinkedRecords = null;
        this._previousItHead = null;
        this._itHead = null;
        this._itTail = null;
        this._additionsHead = null;
        this._additionsTail = null;
        this._movesHead = null;
        this._movesTail = null;
        this._removalsHead = null;
        this._removalsTail = null;
        this._identityChangesHead = null;
        this._identityChangesTail = null;
        this._trackByFn = trackByFn || trackByIdentity;
    }
}
class IterableChangeRecord_ {
    constructor(item, trackById){
        this.item = item;
        this.trackById = trackById;
        this.currentIndex = null;
        this.previousIndex = null;
        this._nextPrevious = null;
        this._prev = null;
        this._next = null;
        this._prevDup = null;
        this._nextDup = null;
        this._prevRemoved = null;
        this._nextRemoved = null;
        this._nextAdded = null;
        this._nextMoved = null;
        this._nextIdentityChange = null;
    }
}
class _DuplicateItemRecordList {
    add(record) {
        if (this._head === null) {
            this._head = this._tail = record;
            record._nextDup = null;
            record._prevDup = null;
        } else {
            this._tail._nextDup = record;
            record._prevDup = this._tail;
            record._nextDup = null;
            this._tail = record;
        }
    }
    get(trackById, atOrAfterIndex) {
        let record;
        for(record = this._head; record !== null; record = record._nextDup){
            if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) return record;
        }
        return null;
    }
    remove(record) {
        const prev = record._prevDup;
        const next = record._nextDup;
        if (prev === null) this._head = next;
        else prev._nextDup = next;
        if (next === null) this._tail = prev;
        else next._prevDup = prev;
        return this._head === null;
    }
    constructor(){
        this._head = null;
        this._tail = null;
    }
}
class _DuplicateMap {
    put(record) {
        const key = record.trackById;
        let duplicates = this.map.get(key);
        if (!duplicates) {
            duplicates = new _DuplicateItemRecordList();
            this.map.set(key, duplicates);
        }
        duplicates.add(record);
    }
    get(trackById, atOrAfterIndex) {
        const key = trackById;
        const recordList = this.map.get(key);
        return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
    }
    remove(record) {
        const key = record.trackById;
        const recordList = this.map.get(key);
        if (recordList.remove(record)) this.map.delete(key);
        return record;
    }
    get isEmpty() {
        return this.map.size === 0;
    }
    clear() {
        this.map.clear();
    }
    constructor(){
        this.map = new Map();
    }
}
function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
    const previousIndex = item.previousIndex;
    if (previousIndex === null) return previousIndex;
    let moveOffset = 0;
    if (moveOffsets && previousIndex < moveOffsets.length) moveOffset = moveOffsets[previousIndex];
    return previousIndex + addRemoveOffset + moveOffset;
}
class DefaultKeyValueDifferFactory {
    supports(obj) {
        return obj instanceof Map || isJsObject(obj);
    }
    create() {
        return new DefaultKeyValueDiffer();
    }
    constructor(){}
}
class DefaultKeyValueDiffer {
    get isDirty() {
        return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
    }
    forEachItem(fn) {
        let record;
        for(record = this._mapHead; record !== null; record = record._next)fn(record);
    }
    forEachPreviousItem(fn) {
        let record;
        for(record = this._previousMapHead; record !== null; record = record._nextPrevious)fn(record);
    }
    forEachChangedItem(fn) {
        let record;
        for(record = this._changesHead; record !== null; record = record._nextChanged)fn(record);
    }
    forEachAddedItem(fn) {
        let record;
        for(record = this._additionsHead; record !== null; record = record._nextAdded)fn(record);
    }
    forEachRemovedItem(fn) {
        let record;
        for(record = this._removalsHead; record !== null; record = record._nextRemoved)fn(record);
    }
    diff(map) {
        if (!map) map = new Map();
        else if (!(map instanceof Map || isJsObject(map))) throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(map)}'. Only maps and objects are allowed`);
        return this.check(map) ? this : null;
    }
    onDestroy() {}
    check(map) {
        this._reset();
        let insertBefore = this._mapHead;
        this._appendAfter = null;
        this._forEach(map, (value, key)=>{
            if (insertBefore && insertBefore.key === key) {
                this._maybeAddToChanges(insertBefore, value);
                this._appendAfter = insertBefore;
                insertBefore = insertBefore._next;
            } else {
                const record = this._getOrCreateRecordForKey(key, value);
                insertBefore = this._insertBeforeOrAppend(insertBefore, record);
            }
        });
        if (insertBefore) {
            if (insertBefore._prev) insertBefore._prev._next = null;
            this._removalsHead = insertBefore;
            for(let record = insertBefore; record !== null; record = record._nextRemoved){
                if (record === this._mapHead) this._mapHead = null;
                this._records.delete(record.key);
                record._nextRemoved = record._next;
                record.previousValue = record.currentValue;
                record.currentValue = null;
                record._prev = null;
                record._next = null;
            }
        }
        if (this._changesTail) this._changesTail._nextChanged = null;
        if (this._additionsTail) this._additionsTail._nextAdded = null;
        return this.isDirty;
    }
    _insertBeforeOrAppend(before, record) {
        if (before) {
            const prev = before._prev;
            record._next = before;
            record._prev = prev;
            before._prev = record;
            if (prev) prev._next = record;
            if (before === this._mapHead) this._mapHead = record;
            this._appendAfter = before;
            return before;
        }
        if (this._appendAfter) {
            this._appendAfter._next = record;
            record._prev = this._appendAfter;
        } else this._mapHead = record;
        this._appendAfter = record;
        return null;
    }
    _getOrCreateRecordForKey(key, value) {
        if (this._records.has(key)) {
            const record = this._records.get(key);
            this._maybeAddToChanges(record, value);
            const prev = record._prev;
            const next = record._next;
            if (prev) prev._next = next;
            if (next) next._prev = prev;
            record._next = null;
            record._prev = null;
            return record;
        }
        const record = new KeyValueChangeRecord_(key);
        this._records.set(key, record);
        record.currentValue = value;
        this._addToAdditions(record);
        return record;
    }
    _reset() {
        if (this.isDirty) {
            let record;
            this._previousMapHead = this._mapHead;
            for(record = this._previousMapHead; record !== null; record = record._next)record._nextPrevious = record._next;
            for(record = this._changesHead; record !== null; record = record._nextChanged)record.previousValue = record.currentValue;
            for(record = this._additionsHead; record != null; record = record._nextAdded)record.previousValue = record.currentValue;
            this._changesHead = this._changesTail = null;
            this._additionsHead = this._additionsTail = null;
            this._removalsHead = null;
        }
    }
    _maybeAddToChanges(record, newValue) {
        if (!Object.is(newValue, record.currentValue)) {
            record.previousValue = record.currentValue;
            record.currentValue = newValue;
            this._addToChanges(record);
        }
    }
    _addToAdditions(record) {
        if (this._additionsHead === null) this._additionsHead = this._additionsTail = record;
        else {
            this._additionsTail._nextAdded = record;
            this._additionsTail = record;
        }
    }
    _addToChanges(record) {
        if (this._changesHead === null) this._changesHead = this._changesTail = record;
        else {
            this._changesTail._nextChanged = record;
            this._changesTail = record;
        }
    }
    _forEach(obj, fn) {
        if (obj instanceof Map) obj.forEach(fn);
        else Object.keys(obj).forEach((k)=>fn(obj[k], k));
    }
    constructor(){
        this._records = new Map();
        this._mapHead = null;
        this._appendAfter = null;
        this._previousMapHead = null;
        this._changesHead = null;
        this._changesTail = null;
        this._additionsHead = null;
        this._additionsTail = null;
        this._removalsHead = null;
        this._removalsTail = null;
    }
}
class KeyValueChangeRecord_ {
    constructor(key){
        this.key = key;
        this.previousValue = null;
        this.currentValue = null;
        this._nextPrevious = null;
        this._next = null;
        this._prev = null;
        this._nextAdded = null;
        this._nextRemoved = null;
        this._nextChanged = null;
    }
}
function defaultIterableDiffersFactory() {
    return new IterableDiffers([
        new DefaultIterableDifferFactory()
    ]);
}
let IterableDiffers = (()=>{
    class IterableDiffers {
        static create(factories, parent) {
            if (parent != null) {
                const copied = parent.factories.slice();
                factories = factories.concat(copied);
            }
            return new IterableDiffers(factories);
        }
        static extend(factories) {
            return {
                provide: IterableDiffers,
                useFactory: (parent)=>{
                    return IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());
                },
                deps: [
                    [
                        IterableDiffers,
                        new SkipSelf(),
                        new Optional()
                    ]
                ]
            };
        }
        find(iterable) {
            const factory = this.factories.find((f)=>f.supports(iterable));
            if (factory != null) return factory;
            else throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);
        }
        constructor(factories){
            this.factories = factories;
        }
    }
    IterableDiffers.ɵprov = ɵɵdefineInjectable({
        token: IterableDiffers,
        providedIn: 'root',
        factory: defaultIterableDiffersFactory
    });
    return IterableDiffers;
})();
function getTypeNameForDebugging(type) {
    return type['name'] || typeof type;
}
function defaultKeyValueDiffersFactory() {
    return new KeyValueDiffers([
        new DefaultKeyValueDifferFactory()
    ]);
}
let KeyValueDiffers = (()=>{
    class KeyValueDiffers {
        static create(factories, parent) {
            if (parent) {
                const copied = parent.factories.slice();
                factories = factories.concat(copied);
            }
            return new KeyValueDiffers(factories);
        }
        static extend(factories) {
            return {
                provide: KeyValueDiffers,
                useFactory: (parent)=>{
                    return KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());
                },
                deps: [
                    [
                        KeyValueDiffers,
                        new SkipSelf(),
                        new Optional()
                    ]
                ]
            };
        }
        find(kv) {
            const factory = this.factories.find((f)=>f.supports(kv));
            if (factory) return factory;
            throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${kv}'`);
        }
        constructor(factories){
            this.factories = factories;
        }
    }
    KeyValueDiffers.ɵprov = ɵɵdefineInjectable({
        token: KeyValueDiffers,
        providedIn: 'root',
        factory: defaultKeyValueDiffersFactory
    });
    return KeyValueDiffers;
})();
const keyValDiff = [
    new DefaultKeyValueDifferFactory()
];
const iterableDiff = [
    new DefaultIterableDifferFactory()
];
new IterableDiffers(iterableDiff);
new KeyValueDiffers(keyValDiff);
const platformCore = createPlatformFactory(null, 'core', []);
let ApplicationModule = (()=>{
    class ApplicationModule {
        constructor(appRef){}
    }
    ApplicationModule.ɵfac = function ApplicationModule_Factory(t) {
        return new (t || ApplicationModule)(ɵɵinject(ApplicationRef));
    };
    ApplicationModule.ɵmod = ɵɵdefineNgModule({
        type: ApplicationModule
    });
    ApplicationModule.ɵinj = ɵɵdefineInjector({});
    return ApplicationModule;
})();
(function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationModule, [
        {
            type: NgModule
        }
    ], function() {
        return [
            {
                type: ApplicationRef
            }
        ];
    }, null);
})();
let InitialRenderPendingTasks = (()=>{
    class InitialRenderPendingTasks {
        get whenAllTasksComplete() {
            if (this.collection.size === 0) this.complete();
            return this.promise;
        }
        add() {
            if (this.completed) return -1;
            const taskId = this.taskId++;
            this.collection.add(taskId);
            return taskId;
        }
        remove(taskId) {
            if (this.completed) return;
            this.collection.delete(taskId);
            if (this.collection.size === 0) this.complete();
        }
        ngOnDestroy() {
            this.complete();
            this.collection.clear();
        }
        complete() {
            this.completed = true;
            this.resolve();
        }
        constructor(){
            this.taskId = 0;
            this.collection = new Set();
            this.ngZone = inject(NgZone);
            this.completed = false;
            this.ngZone.runOutsideAngular(()=>{
                this.promise = new Promise((resolve)=>{
                    this.resolve = resolve;
                });
            });
        }
    }
    InitialRenderPendingTasks.ɵfac = function InitialRenderPendingTasks_Factory(t) {
        return new (t || InitialRenderPendingTasks)();
    };
    InitialRenderPendingTasks.ɵprov = ɵɵdefineInjectable({
        token: InitialRenderPendingTasks,
        factory: InitialRenderPendingTasks.ɵfac,
        providedIn: 'root'
    });
    return InitialRenderPendingTasks;
})();
(function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InitialRenderPendingTasks, [
        {
            type: Injectable,
            args: [
                {
                    providedIn: 'root'
                }
            ]
        }
    ], function() {
        return [];
    }, null);
})();
function coerceToBoolean(value) {
    return typeof value === 'boolean' ? value : value != null && value !== 'false';
}
function reflectComponentType(component) {
    const componentDef = getComponentDef(component);
    if (!componentDef) return null;
    const factory = new ComponentFactory(componentDef);
    return {
        get selector () {
            return factory.selector;
        },
        get type () {
            return factory.componentType;
        },
        get inputs () {
            return factory.inputs;
        },
        get outputs () {
            return factory.outputs;
        },
        get ngContentSelectors () {
            return factory.ngContentSelectors;
        },
        get isStandalone () {
            return componentDef.standalone;
        }
    };
}
if (typeof ngDevMode !== 'undefined' && ngDevMode) _global.$localize = _global.$localize || function() {
    throw new Error("It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a global `$localize()` function that needs to be loaded.\nPlease run `ng add @angular/localize` from the Angular CLI.\n(For non-CLI projects, add `import '@angular/localize/init';` to your `polyfills.ts` file.\nFor server-side rendering applications add the import to your `main.server.ts` file.)");
};