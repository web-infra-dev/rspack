"use strict";
(self["webpackChunkrspack_basic_example"] =
	self["webpackChunkrspack_basic_example"] || []).push([
	[
		"vendors-node_modules_pnpm_three_0_169_0_node_modules_three_examples_jsm_postprocessing_Unreal-fac73e"
	],
	{
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/examples/jsm/postprocessing/Pass.js":
			/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/examples/jsm/postprocessing/Pass.js ***!
  \*****************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					FullScreenQuad: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three-render-pass.FullScreenQuad"] */ FullScreenQuad,
					Pass: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three-render-pass.Pass"] */ Pass
				});
				/* ESM import */ var three__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! three */ "webpack/sharing/consume/default/three/three"
					);

				class Pass {
					constructor() {
						this.isPass = true;

						// if set to true, the pass is processed by the composer
						this.enabled = true;

						// if set to true, the pass indicates to swap read and write buffer after rendering
						this.needsSwap = true;

						// if set to true, the pass clears its buffer before rendering
						this.clear = false;

						// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
						this.renderToScreen = false;
					}

					setSize(/* width, height */) {}

					render(/* renderer, writeBuffer, readBuffer, deltaTime, maskActive */) {
						console.error(
							"THREE.Pass: .render() must be implemented in derived pass."
						);
					}

					dispose() {}
				}

				// Helper for passes that need to fill the viewport with a single quad.

				const _camera =
					new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(
						-1,
						1,
						1,
						-1,
						0,
						1
					);

				// https://github.com/mrdoob/three.js/pull/21358

				class FullscreenTriangleGeometry extends three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry {
					constructor() {
						super();

						this.setAttribute(
							"position",
							new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(
								[-1, 3, 0, -1, -1, 0, 3, -1, 0],
								3
							)
						);
						this.setAttribute(
							"uv",
							new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(
								[0, 2, 0, 0, 2, 0],
								2
							)
						);
					}
				}

				const _geometry = new FullscreenTriangleGeometry();

				class FullScreenQuad {
					constructor(material) {
						this._mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(
							_geometry,
							material
						);
					}

					dispose() {
						this._mesh.geometry.dispose();
					}

					render(renderer) {
						renderer.render(this._mesh, _camera);
					}

					get material() {
						return this._mesh.material;
					}

					set material(value) {
						this._mesh.material = value;
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js":
			/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js ***!
  \****************************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.r(__webpack_exports__);
				__webpack_require__.d(__webpack_exports__, {
					UnrealBloomPass: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three-bloom-pass.UnrealBloomPass"] */ UnrealBloomPass
				});
				/* ESM import */ var three__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! three */ "webpack/sharing/consume/default/three/three"
					);
				/* ESM import */ var _Pass_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Pass.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/examples/jsm/postprocessing/Pass.js"
					);
				/* ESM import */ var _shaders_CopyShader_js__WEBPACK_IMPORTED_MODULE_3__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../shaders/CopyShader.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/examples/jsm/shaders/CopyShader.js"
					);
				/* ESM import */ var _shaders_LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_2__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../shaders/LuminosityHighPassShader.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js"
					);

				/**
				 * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a
				 * mip map chain of bloom textures and blurs them with different radii. Because
				 * of the weighted combination of mips, and because larger blurs are done on
				 * higher mips, this effect provides good quality and performance.
				 *
				 * Reference:
				 * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
				 */
				class UnrealBloomPass extends _Pass_js__WEBPACK_IMPORTED_MODULE_1__.Pass {
					constructor(resolution, strength, radius, threshold) {
						super();

						this.strength = strength !== undefined ? strength : 1;
						this.radius = radius;
						this.threshold = threshold;
						this.resolution =
							resolution !== undefined
								? new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(
										resolution.x,
										resolution.y
									)
								: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(256, 256);

						// create color only once here, reuse it later inside the render function
						this.clearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(
							0,
							0,
							0
						);

						// render targets
						this.renderTargetsHorizontal = [];
						this.renderTargetsVertical = [];
						this.nMips = 5;
						let resx = Math.round(this.resolution.x / 2);
						let resy = Math.round(this.resolution.y / 2);

						this.renderTargetBright =
							new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(
								resx,
								resy,
								{ type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType }
							);
						this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
						this.renderTargetBright.texture.generateMipmaps = false;

						for (let i = 0; i < this.nMips; i++) {
							const renderTargetHorizontal =
								new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(
									resx,
									resy,
									{ type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType }
								);

							renderTargetHorizontal.texture.name = "UnrealBloomPass.h" + i;
							renderTargetHorizontal.texture.generateMipmaps = false;

							this.renderTargetsHorizontal.push(renderTargetHorizontal);

							const renderTargetVertical =
								new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(
									resx,
									resy,
									{ type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType }
								);

							renderTargetVertical.texture.name = "UnrealBloomPass.v" + i;
							renderTargetVertical.texture.generateMipmaps = false;

							this.renderTargetsVertical.push(renderTargetVertical);

							resx = Math.round(resx / 2);

							resy = Math.round(resy / 2);
						}

						// luminosity high pass material

						const highPassShader =
							_shaders_LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_2__.LuminosityHighPassShader;
						this.highPassUniforms =
							three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone(
								highPassShader.uniforms
							);

						this.highPassUniforms["luminosityThreshold"].value = threshold;
						this.highPassUniforms["smoothWidth"].value = 0.01;

						this.materialHighPassFilter =
							new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({
								uniforms: this.highPassUniforms,
								vertexShader: highPassShader.vertexShader,
								fragmentShader: highPassShader.fragmentShader
							});

						// gaussian blur materials

						this.separableBlurMaterials = [];
						const kernelSizeArray = [3, 5, 7, 9, 11];
						resx = Math.round(this.resolution.x / 2);
						resy = Math.round(this.resolution.y / 2);

						for (let i = 0; i < this.nMips; i++) {
							this.separableBlurMaterials.push(
								this.getSeperableBlurMaterial(kernelSizeArray[i])
							);

							this.separableBlurMaterials[i].uniforms["invSize"].value =
								new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(
									1 / resx,
									1 / resy
								);

							resx = Math.round(resx / 2);

							resy = Math.round(resy / 2);
						}

						// composite material

						this.compositeMaterial = this.getCompositeMaterial(this.nMips);
						this.compositeMaterial.uniforms["blurTexture1"].value =
							this.renderTargetsVertical[0].texture;
						this.compositeMaterial.uniforms["blurTexture2"].value =
							this.renderTargetsVertical[1].texture;
						this.compositeMaterial.uniforms["blurTexture3"].value =
							this.renderTargetsVertical[2].texture;
						this.compositeMaterial.uniforms["blurTexture4"].value =
							this.renderTargetsVertical[3].texture;
						this.compositeMaterial.uniforms["blurTexture5"].value =
							this.renderTargetsVertical[4].texture;
						this.compositeMaterial.uniforms["bloomStrength"].value = strength;
						this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;

						const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
						this.compositeMaterial.uniforms["bloomFactors"].value =
							bloomFactors;
						this.bloomTintColors = [
							new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1),
							new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1),
							new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1),
							new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1),
							new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1)
						];
						this.compositeMaterial.uniforms["bloomTintColors"].value =
							this.bloomTintColors;

						// blend material

						const copyShader =
							_shaders_CopyShader_js__WEBPACK_IMPORTED_MODULE_3__.CopyShader;

						this.copyUniforms =
							three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone(
								copyShader.uniforms
							);

						this.blendMaterial =
							new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({
								uniforms: this.copyUniforms,
								vertexShader: copyShader.vertexShader,
								fragmentShader: copyShader.fragmentShader,
								blending: three__WEBPACK_IMPORTED_MODULE_0__.AdditiveBlending,
								depthTest: false,
								depthWrite: false,
								transparent: true
							});

						this.enabled = true;
						this.needsSwap = false;

						this._oldClearColor =
							new three__WEBPACK_IMPORTED_MODULE_0__.Color();
						this.oldClearAlpha = 1;

						this.basic =
							new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial();

						this.fsQuad =
							new _Pass_js__WEBPACK_IMPORTED_MODULE_1__.FullScreenQuad(null);
					}

					dispose() {
						for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {
							this.renderTargetsHorizontal[i].dispose();
						}

						for (let i = 0; i < this.renderTargetsVertical.length; i++) {
							this.renderTargetsVertical[i].dispose();
						}

						this.renderTargetBright.dispose();

						//

						for (let i = 0; i < this.separableBlurMaterials.length; i++) {
							this.separableBlurMaterials[i].dispose();
						}

						this.compositeMaterial.dispose();
						this.blendMaterial.dispose();
						this.basic.dispose();

						//

						this.fsQuad.dispose();
					}

					setSize(width, height) {
						let resx = Math.round(width / 2);
						let resy = Math.round(height / 2);

						this.renderTargetBright.setSize(resx, resy);

						for (let i = 0; i < this.nMips; i++) {
							this.renderTargetsHorizontal[i].setSize(resx, resy);
							this.renderTargetsVertical[i].setSize(resx, resy);

							this.separableBlurMaterials[i].uniforms["invSize"].value =
								new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(
									1 / resx,
									1 / resy
								);

							resx = Math.round(resx / 2);
							resy = Math.round(resy / 2);
						}
					}

					render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
						renderer.getClearColor(this._oldClearColor);
						this.oldClearAlpha = renderer.getClearAlpha();
						const oldAutoClear = renderer.autoClear;
						renderer.autoClear = false;

						renderer.setClearColor(this.clearColor, 0);

						if (maskActive) renderer.state.buffers.stencil.setTest(false);

						// Render input to screen

						if (this.renderToScreen) {
							this.fsQuad.material = this.basic;
							this.basic.map = readBuffer.texture;

							renderer.setRenderTarget(null);
							renderer.clear();
							this.fsQuad.render(renderer);
						}

						// 1. Extract Bright Areas

						this.highPassUniforms["tDiffuse"].value = readBuffer.texture;
						this.highPassUniforms["luminosityThreshold"].value = this.threshold;
						this.fsQuad.material = this.materialHighPassFilter;

						renderer.setRenderTarget(this.renderTargetBright);
						renderer.clear();
						this.fsQuad.render(renderer);

						// 2. Blur All the mips progressively

						let inputRenderTarget = this.renderTargetBright;

						for (let i = 0; i < this.nMips; i++) {
							this.fsQuad.material = this.separableBlurMaterials[i];

							this.separableBlurMaterials[i].uniforms["colorTexture"].value =
								inputRenderTarget.texture;
							this.separableBlurMaterials[i].uniforms["direction"].value =
								UnrealBloomPass.BlurDirectionX;
							renderer.setRenderTarget(this.renderTargetsHorizontal[i]);
							renderer.clear();
							this.fsQuad.render(renderer);

							this.separableBlurMaterials[i].uniforms["colorTexture"].value =
								this.renderTargetsHorizontal[i].texture;
							this.separableBlurMaterials[i].uniforms["direction"].value =
								UnrealBloomPass.BlurDirectionY;
							renderer.setRenderTarget(this.renderTargetsVertical[i]);
							renderer.clear();
							this.fsQuad.render(renderer);

							inputRenderTarget = this.renderTargetsVertical[i];
						}

						// Composite All the mips

						this.fsQuad.material = this.compositeMaterial;
						this.compositeMaterial.uniforms["bloomStrength"].value =
							this.strength;
						this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
						this.compositeMaterial.uniforms["bloomTintColors"].value =
							this.bloomTintColors;

						renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
						renderer.clear();
						this.fsQuad.render(renderer);

						// Blend it additively over the input texture

						this.fsQuad.material = this.blendMaterial;
						this.copyUniforms["tDiffuse"].value =
							this.renderTargetsHorizontal[0].texture;

						if (maskActive) renderer.state.buffers.stencil.setTest(true);

						if (this.renderToScreen) {
							renderer.setRenderTarget(null);
							this.fsQuad.render(renderer);
						} else {
							renderer.setRenderTarget(readBuffer);
							this.fsQuad.render(renderer);
						}

						// Restore renderer settings

						renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
						renderer.autoClear = oldAutoClear;
					}

					getSeperableBlurMaterial(kernelRadius) {
						const coefficients = [];

						for (let i = 0; i < kernelRadius; i++) {
							coefficients.push(
								(0.39894 *
									Math.exp((-0.5 * i * i) / (kernelRadius * kernelRadius))) /
									kernelRadius
							);
						}

						return new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({
							defines: {
								KERNEL_RADIUS: kernelRadius
							},

							uniforms: {
								colorTexture: { value: null },
								invSize: {
									value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(
										0.5,
										0.5
									)
								}, // inverse texture size
								direction: {
									value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(
										0.5,
										0.5
									)
								},
								gaussianCoefficients: { value: coefficients } // precomputed Gaussian coefficients
							},

							vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,

							fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
						});
					}

					getCompositeMaterial(nMips) {
						return new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({
							defines: {
								NUM_MIPS: nMips
							},

							uniforms: {
								blurTexture1: { value: null },
								blurTexture2: { value: null },
								blurTexture3: { value: null },
								blurTexture4: { value: null },
								blurTexture5: { value: null },
								bloomStrength: { value: 1.0 },
								bloomFactors: { value: null },
								bloomTintColors: { value: null },
								bloomRadius: { value: 0.0 }
							},

							vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,

							fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
						});
					}
				}

				UnrealBloomPass.BlurDirectionX =
					new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1.0, 0.0);
				UnrealBloomPass.BlurDirectionY =
					new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.0, 1.0);
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/examples/jsm/shaders/CopyShader.js":
			/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/examples/jsm/shaders/CopyShader.js ***!
  \****************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					CopyShader: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three-bloom-pass.CopyShader"] */ CopyShader
				});
				/**
				 * Full-screen textured quad shader
				 */

				const CopyShader = {
					name: "CopyShader",

					uniforms: {
						tDiffuse: { value: null },
						opacity: { value: 1.0 }
					},

					vertexShader: /* glsl */ `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

					fragmentShader: /* glsl */ `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
				};
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js":
			/*!******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js ***!
  \******************************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					LuminosityHighPassShader: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three-bloom-pass.LuminosityHighPassShader"] */ LuminosityHighPassShader
				});
				/* ESM import */ var three__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! three */ "webpack/sharing/consume/default/three/three"
					);

				/**
				 * Luminosity
				 * http://en.wikipedia.org/wiki/Luminosity
				 */

				const LuminosityHighPassShader = {
					name: "LuminosityHighPassShader",

					shaderID: "luminosityHighPass",

					uniforms: {
						tDiffuse: { value: null },
						luminosityThreshold: { value: 1.0 },
						smoothWidth: { value: 1.0 },
						defaultColor: {
							value: new three__WEBPACK_IMPORTED_MODULE_0__.Color(0x000000)
						},
						defaultOpacity: { value: 0.0 }
					},

					vertexShader: /* glsl */ `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

					fragmentShader: /* glsl */ `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			float v = luminance( texel.xyz );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
				};
			}
	}
]);
