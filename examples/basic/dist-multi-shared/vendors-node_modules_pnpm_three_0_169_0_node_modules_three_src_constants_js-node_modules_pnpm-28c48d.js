"use strict";
(self["webpackChunkrspack_basic_example"] =
	self["webpackChunkrspack_basic_example"] || []).push([
	[
		"vendors-node_modules_pnpm_three_0_169_0_node_modules_three_src_constants_js-node_modules_pnpm-28c48d"
	],
	{
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js":
			/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js ***!
  \**********************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					AddEquation: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.AddEquation"] */ AddEquation,
					AdditiveAnimationBlendMode: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.AdditiveAnimationBlendMode"] */ AdditiveAnimationBlendMode,
					AlwaysStencilFunc: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.AlwaysStencilFunc"] */ AlwaysStencilFunc,
					DisplayP3ColorSpace: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.DisplayP3ColorSpace"] */ DisplayP3ColorSpace,
					FloatType: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.FloatType"] */ FloatType,
					FrontSide: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.FrontSide"] */ FrontSide,
					InterpolateDiscrete: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.InterpolateDiscrete"] */ InterpolateDiscrete,
					InterpolateLinear: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.InterpolateLinear"] */ InterpolateLinear,
					InterpolateSmooth: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.InterpolateSmooth"] */ InterpolateSmooth,
					KeepStencilOp: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.KeepStencilOp"] */ KeepStencilOp,
					LessEqualDepth: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.LessEqualDepth"] */ LessEqualDepth,
					LinearDisplayP3ColorSpace: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.LinearDisplayP3ColorSpace"] */ LinearDisplayP3ColorSpace,
					LinearSRGBColorSpace: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.LinearSRGBColorSpace"] */ LinearSRGBColorSpace,
					LinearTransfer: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.LinearTransfer"] */ LinearTransfer,
					LoopOnce: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.LoopOnce"] */ LoopOnce,
					LoopPingPong: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.LoopPingPong"] */ LoopPingPong,
					LoopRepeat: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.LoopRepeat"] */ LoopRepeat,
					NoColorSpace: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.NoColorSpace"] */ NoColorSpace,
					NormalAnimationBlendMode: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.NormalAnimationBlendMode"] */ NormalAnimationBlendMode,
					NormalBlending: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.NormalBlending"] */ NormalBlending,
					OneMinusSrcAlphaFactor: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.OneMinusSrcAlphaFactor"] */ OneMinusSrcAlphaFactor,
					P3Primaries: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.P3Primaries"] */ P3Primaries,
					Rec709Primaries: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.Rec709Primaries"] */ Rec709Primaries,
					SRGBColorSpace: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.SRGBColorSpace"] */ SRGBColorSpace,
					SRGBTransfer: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.SRGBTransfer"] */ SRGBTransfer,
					SrcAlphaFactor: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.SrcAlphaFactor"] */ SrcAlphaFactor,
					StaticDrawUsage: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.StaticDrawUsage"] */ StaticDrawUsage,
					WebGLCoordinateSystem: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.WebGLCoordinateSystem"] */ WebGLCoordinateSystem,
					WebGPUCoordinateSystem: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.WebGPUCoordinateSystem"] */ WebGPUCoordinateSystem,
					WrapAroundEnding: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.WrapAroundEnding"] */ WrapAroundEnding,
					ZeroCurvatureEnding: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.ZeroCurvatureEnding"] */ ZeroCurvatureEnding,
					ZeroSlopeEnding: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.ZeroSlopeEnding"] */ ZeroSlopeEnding
				});
				const REVISION = "169";

				const MOUSE = /* unused pure expression or super */ null && {
					LEFT: 0,
					MIDDLE: 1,
					RIGHT: 2,
					ROTATE: 0,
					DOLLY: 1,
					PAN: 2
				};
				const TOUCH = /* unused pure expression or super */ null && {
					ROTATE: 0,
					PAN: 1,
					DOLLY_PAN: 2,
					DOLLY_ROTATE: 3
				};
				const CullFaceNone = 0;
				const CullFaceBack = 1;
				const CullFaceFront = 2;
				const CullFaceFrontBack = 3;
				const BasicShadowMap = 0;
				const PCFShadowMap = 1;
				const PCFSoftShadowMap = 2;
				const VSMShadowMap = 3;
				const FrontSide = 0;
				const BackSide = 1;
				const DoubleSide = 2;
				const NoBlending = 0;
				const NormalBlending = 1;
				const AdditiveBlending = 2;
				const SubtractiveBlending = 3;
				const MultiplyBlending = 4;
				const CustomBlending = 5;
				const AddEquation = 100;
				const SubtractEquation = 101;
				const ReverseSubtractEquation = 102;
				const MinEquation = 103;
				const MaxEquation = 104;
				const ZeroFactor = 200;
				const OneFactor = 201;
				const SrcColorFactor = 202;
				const OneMinusSrcColorFactor = 203;
				const SrcAlphaFactor = 204;
				const OneMinusSrcAlphaFactor = 205;
				const DstAlphaFactor = 206;
				const OneMinusDstAlphaFactor = 207;
				const DstColorFactor = 208;
				const OneMinusDstColorFactor = 209;
				const SrcAlphaSaturateFactor = 210;
				const ConstantColorFactor = 211;
				const OneMinusConstantColorFactor = 212;
				const ConstantAlphaFactor = 213;
				const OneMinusConstantAlphaFactor = 214;
				const NeverDepth = 0;
				const AlwaysDepth = 1;
				const LessDepth = 2;
				const LessEqualDepth = 3;
				const EqualDepth = 4;
				const GreaterEqualDepth = 5;
				const GreaterDepth = 6;
				const NotEqualDepth = 7;
				const MultiplyOperation = 0;
				const MixOperation = 1;
				const AddOperation = 2;
				const NoToneMapping = 0;
				const LinearToneMapping = 1;
				const ReinhardToneMapping = 2;
				const CineonToneMapping = 3;
				const ACESFilmicToneMapping = 4;
				const CustomToneMapping = 5;
				const AgXToneMapping = 6;
				const NeutralToneMapping = 7;
				const AttachedBindMode = "attached";
				const DetachedBindMode = "detached";

				const UVMapping = 300;
				const CubeReflectionMapping = 301;
				const CubeRefractionMapping = 302;
				const EquirectangularReflectionMapping = 303;
				const EquirectangularRefractionMapping = 304;
				const CubeUVReflectionMapping = 306;
				const RepeatWrapping = 1000;
				const ClampToEdgeWrapping = 1001;
				const MirroredRepeatWrapping = 1002;
				const NearestFilter = 1003;
				const NearestMipmapNearestFilter = 1004;
				const NearestMipMapNearestFilter = 1004;
				const NearestMipmapLinearFilter = 1005;
				const NearestMipMapLinearFilter = 1005;
				const LinearFilter = 1006;
				const LinearMipmapNearestFilter = 1007;
				const LinearMipMapNearestFilter = 1007;
				const LinearMipmapLinearFilter = 1008;
				const LinearMipMapLinearFilter = 1008;
				const UnsignedByteType = 1009;
				const ByteType = 1010;
				const ShortType = 1011;
				const UnsignedShortType = 1012;
				const IntType = 1013;
				const UnsignedIntType = 1014;
				const FloatType = 1015;
				const HalfFloatType = 1016;
				const UnsignedShort4444Type = 1017;
				const UnsignedShort5551Type = 1018;
				const UnsignedInt248Type = 1020;
				const UnsignedInt5999Type = 35902;
				const AlphaFormat = 1021;
				const RGBFormat = 1022;
				const RGBAFormat = 1023;
				const LuminanceFormat = 1024;
				const LuminanceAlphaFormat = 1025;
				const DepthFormat = 1026;
				const DepthStencilFormat = 1027;
				const RedFormat = 1028;
				const RedIntegerFormat = 1029;
				const RGFormat = 1030;
				const RGIntegerFormat = 1031;
				const RGBIntegerFormat = 1032;
				const RGBAIntegerFormat = 1033;

				const RGB_S3TC_DXT1_Format = 33776;
				const RGBA_S3TC_DXT1_Format = 33777;
				const RGBA_S3TC_DXT3_Format = 33778;
				const RGBA_S3TC_DXT5_Format = 33779;
				const RGB_PVRTC_4BPPV1_Format = 35840;
				const RGB_PVRTC_2BPPV1_Format = 35841;
				const RGBA_PVRTC_4BPPV1_Format = 35842;
				const RGBA_PVRTC_2BPPV1_Format = 35843;
				const RGB_ETC1_Format = 36196;
				const RGB_ETC2_Format = 37492;
				const RGBA_ETC2_EAC_Format = 37496;
				const RGBA_ASTC_4x4_Format = 37808;
				const RGBA_ASTC_5x4_Format = 37809;
				const RGBA_ASTC_5x5_Format = 37810;
				const RGBA_ASTC_6x5_Format = 37811;
				const RGBA_ASTC_6x6_Format = 37812;
				const RGBA_ASTC_8x5_Format = 37813;
				const RGBA_ASTC_8x6_Format = 37814;
				const RGBA_ASTC_8x8_Format = 37815;
				const RGBA_ASTC_10x5_Format = 37816;
				const RGBA_ASTC_10x6_Format = 37817;
				const RGBA_ASTC_10x8_Format = 37818;
				const RGBA_ASTC_10x10_Format = 37819;
				const RGBA_ASTC_12x10_Format = 37820;
				const RGBA_ASTC_12x12_Format = 37821;
				const RGBA_BPTC_Format = 36492;
				const RGB_BPTC_SIGNED_Format = 36494;
				const RGB_BPTC_UNSIGNED_Format = 36495;
				const RED_RGTC1_Format = 36283;
				const SIGNED_RED_RGTC1_Format = 36284;
				const RED_GREEN_RGTC2_Format = 36285;
				const SIGNED_RED_GREEN_RGTC2_Format = 36286;
				const LoopOnce = 2200;
				const LoopRepeat = 2201;
				const LoopPingPong = 2202;
				const InterpolateDiscrete = 2300;
				const InterpolateLinear = 2301;
				const InterpolateSmooth = 2302;
				const ZeroCurvatureEnding = 2400;
				const ZeroSlopeEnding = 2401;
				const WrapAroundEnding = 2402;
				const NormalAnimationBlendMode = 2500;
				const AdditiveAnimationBlendMode = 2501;
				const TrianglesDrawMode = 0;
				const TriangleStripDrawMode = 1;
				const TriangleFanDrawMode = 2;
				const BasicDepthPacking = 3200;
				const RGBADepthPacking = 3201;
				const RGBDepthPacking = 3202;
				const RGDepthPacking = 3203;
				const TangentSpaceNormalMap = 0;
				const ObjectSpaceNormalMap = 1;

				// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
				const NoColorSpace = "";
				const SRGBColorSpace = "srgb";
				const LinearSRGBColorSpace = "srgb-linear";
				const DisplayP3ColorSpace = "display-p3";
				const LinearDisplayP3ColorSpace = "display-p3-linear";

				const LinearTransfer = "linear";
				const SRGBTransfer = "srgb";

				const Rec709Primaries = "rec709";
				const P3Primaries = "p3";

				const ZeroStencilOp = 0;
				const KeepStencilOp = 7680;
				const ReplaceStencilOp = 7681;
				const IncrementStencilOp = 7682;
				const DecrementStencilOp = 7683;
				const IncrementWrapStencilOp = 34055;
				const DecrementWrapStencilOp = 34056;
				const InvertStencilOp = 5386;

				const NeverStencilFunc = 512;
				const LessStencilFunc = 513;
				const EqualStencilFunc = 514;
				const LessEqualStencilFunc = 515;
				const GreaterStencilFunc = 516;
				const NotEqualStencilFunc = 517;
				const GreaterEqualStencilFunc = 518;
				const AlwaysStencilFunc = 519;

				const NeverCompare = 512;
				const LessCompare = 513;
				const EqualCompare = 514;
				const LessEqualCompare = 515;
				const GreaterCompare = 516;
				const NotEqualCompare = 517;
				const GreaterEqualCompare = 518;
				const AlwaysCompare = 519;

				const StaticDrawUsage = 35044;
				const DynamicDrawUsage = 35048;
				const StreamDrawUsage = 35040;
				const StaticReadUsage = 35045;
				const DynamicReadUsage = 35049;
				const StreamReadUsage = 35041;
				const StaticCopyUsage = 35046;
				const DynamicCopyUsage = 35050;
				const StreamCopyUsage = 35042;

				const GLSL1 = "100";
				const GLSL3 = "300 es";

				const WebGLCoordinateSystem = 2000;
				const WebGPUCoordinateSystem = 2001;
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/EventDispatcher.js":
			/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/EventDispatcher.js ***!
  \*********************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					EventDispatcher: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.EventDispatcher"] */ EventDispatcher
				});
				/**
				 * https://github.com/mrdoob/eventdispatcher.js/
				 */

				class EventDispatcher {
					addEventListener(type, listener) {
						if (this._listeners === undefined) this._listeners = {};

						const listeners = this._listeners;

						if (listeners[type] === undefined) {
							listeners[type] = [];
						}

						if (listeners[type].indexOf(listener) === -1) {
							listeners[type].push(listener);
						}
					}

					hasEventListener(type, listener) {
						if (this._listeners === undefined) return false;

						const listeners = this._listeners;

						return (
							listeners[type] !== undefined &&
							listeners[type].indexOf(listener) !== -1
						);
					}

					removeEventListener(type, listener) {
						if (this._listeners === undefined) return;

						const listeners = this._listeners;
						const listenerArray = listeners[type];

						if (listenerArray !== undefined) {
							const index = listenerArray.indexOf(listener);

							if (index !== -1) {
								listenerArray.splice(index, 1);
							}
						}
					}

					dispatchEvent(event) {
						if (this._listeners === undefined) return;

						const listeners = this._listeners;
						const listenerArray = listeners[event.type];

						if (listenerArray !== undefined) {
							event.target = this;

							// Make a copy, in case listeners are removed while iterating.
							const array = listenerArray.slice(0);

							for (let i = 0, l = array.length; i < l; i++) {
								array[i].call(this, event);
							}

							event.target = null;
						}
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/MathUtils.js":
			/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/MathUtils.js ***!
  \***************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					clamp: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.clamp"] */ clamp,
					denormalize: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.denormalize"] */ denormalize,
					euclideanModulo: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.euclideanModulo"] */ euclideanModulo,
					generateUUID: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.generateUUID"] */ generateUUID,
					lerp: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.lerp"] */ lerp,
					normalize: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.normalize"] */ normalize
				});
				const _lut = [
					"00",
					"01",
					"02",
					"03",
					"04",
					"05",
					"06",
					"07",
					"08",
					"09",
					"0a",
					"0b",
					"0c",
					"0d",
					"0e",
					"0f",
					"10",
					"11",
					"12",
					"13",
					"14",
					"15",
					"16",
					"17",
					"18",
					"19",
					"1a",
					"1b",
					"1c",
					"1d",
					"1e",
					"1f",
					"20",
					"21",
					"22",
					"23",
					"24",
					"25",
					"26",
					"27",
					"28",
					"29",
					"2a",
					"2b",
					"2c",
					"2d",
					"2e",
					"2f",
					"30",
					"31",
					"32",
					"33",
					"34",
					"35",
					"36",
					"37",
					"38",
					"39",
					"3a",
					"3b",
					"3c",
					"3d",
					"3e",
					"3f",
					"40",
					"41",
					"42",
					"43",
					"44",
					"45",
					"46",
					"47",
					"48",
					"49",
					"4a",
					"4b",
					"4c",
					"4d",
					"4e",
					"4f",
					"50",
					"51",
					"52",
					"53",
					"54",
					"55",
					"56",
					"57",
					"58",
					"59",
					"5a",
					"5b",
					"5c",
					"5d",
					"5e",
					"5f",
					"60",
					"61",
					"62",
					"63",
					"64",
					"65",
					"66",
					"67",
					"68",
					"69",
					"6a",
					"6b",
					"6c",
					"6d",
					"6e",
					"6f",
					"70",
					"71",
					"72",
					"73",
					"74",
					"75",
					"76",
					"77",
					"78",
					"79",
					"7a",
					"7b",
					"7c",
					"7d",
					"7e",
					"7f",
					"80",
					"81",
					"82",
					"83",
					"84",
					"85",
					"86",
					"87",
					"88",
					"89",
					"8a",
					"8b",
					"8c",
					"8d",
					"8e",
					"8f",
					"90",
					"91",
					"92",
					"93",
					"94",
					"95",
					"96",
					"97",
					"98",
					"99",
					"9a",
					"9b",
					"9c",
					"9d",
					"9e",
					"9f",
					"a0",
					"a1",
					"a2",
					"a3",
					"a4",
					"a5",
					"a6",
					"a7",
					"a8",
					"a9",
					"aa",
					"ab",
					"ac",
					"ad",
					"ae",
					"af",
					"b0",
					"b1",
					"b2",
					"b3",
					"b4",
					"b5",
					"b6",
					"b7",
					"b8",
					"b9",
					"ba",
					"bb",
					"bc",
					"bd",
					"be",
					"bf",
					"c0",
					"c1",
					"c2",
					"c3",
					"c4",
					"c5",
					"c6",
					"c7",
					"c8",
					"c9",
					"ca",
					"cb",
					"cc",
					"cd",
					"ce",
					"cf",
					"d0",
					"d1",
					"d2",
					"d3",
					"d4",
					"d5",
					"d6",
					"d7",
					"d8",
					"d9",
					"da",
					"db",
					"dc",
					"dd",
					"de",
					"df",
					"e0",
					"e1",
					"e2",
					"e3",
					"e4",
					"e5",
					"e6",
					"e7",
					"e8",
					"e9",
					"ea",
					"eb",
					"ec",
					"ed",
					"ee",
					"ef",
					"f0",
					"f1",
					"f2",
					"f3",
					"f4",
					"f5",
					"f6",
					"f7",
					"f8",
					"f9",
					"fa",
					"fb",
					"fc",
					"fd",
					"fe",
					"ff"
				];

				let _seed = 1234567;

				const DEG2RAD =
					/* unused pure expression or super */ null && Math.PI / 180;
				const RAD2DEG =
					/* unused pure expression or super */ null && 180 / Math.PI;

				// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
				function generateUUID() {
					const d0 = (Math.random() * 0xffffffff) | 0;
					const d1 = (Math.random() * 0xffffffff) | 0;
					const d2 = (Math.random() * 0xffffffff) | 0;
					const d3 = (Math.random() * 0xffffffff) | 0;
					const uuid =
						_lut[d0 & 0xff] +
						_lut[(d0 >> 8) & 0xff] +
						_lut[(d0 >> 16) & 0xff] +
						_lut[(d0 >> 24) & 0xff] +
						"-" +
						_lut[d1 & 0xff] +
						_lut[(d1 >> 8) & 0xff] +
						"-" +
						_lut[((d1 >> 16) & 0x0f) | 0x40] +
						_lut[(d1 >> 24) & 0xff] +
						"-" +
						_lut[(d2 & 0x3f) | 0x80] +
						_lut[(d2 >> 8) & 0xff] +
						"-" +
						_lut[(d2 >> 16) & 0xff] +
						_lut[(d2 >> 24) & 0xff] +
						_lut[d3 & 0xff] +
						_lut[(d3 >> 8) & 0xff] +
						_lut[(d3 >> 16) & 0xff] +
						_lut[(d3 >> 24) & 0xff];

					// .toLowerCase() here flattens concatenated strings to save heap memory space.
					return uuid.toLowerCase();
				}

				function clamp(value, min, max) {
					return Math.max(min, Math.min(max, value));
				}

				// compute euclidean modulo of m % n
				// https://en.wikipedia.org/wiki/Modulo_operation
				function euclideanModulo(n, m) {
					return ((n % m) + m) % m;
				}

				// Linear mapping from range <a1, a2> to range <b1, b2>
				function mapLinear(x, a1, a2, b1, b2) {
					return b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);
				}

				// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
				function inverseLerp(x, y, value) {
					if (x !== y) {
						return (value - x) / (y - x);
					} else {
						return 0;
					}
				}

				// https://en.wikipedia.org/wiki/Linear_interpolation
				function lerp(x, y, t) {
					return (1 - t) * x + t * y;
				}

				// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
				function damp(x, y, lambda, dt) {
					return lerp(x, y, 1 - Math.exp(-lambda * dt));
				}

				// https://www.desmos.com/calculator/vcsjnyz7x4
				function pingpong(x, length = 1) {
					return length - Math.abs(euclideanModulo(x, length * 2) - length);
				}

				// http://en.wikipedia.org/wiki/Smoothstep
				function smoothstep(x, min, max) {
					if (x <= min) return 0;
					if (x >= max) return 1;

					x = (x - min) / (max - min);

					return x * x * (3 - 2 * x);
				}

				function smootherstep(x, min, max) {
					if (x <= min) return 0;
					if (x >= max) return 1;

					x = (x - min) / (max - min);

					return x * x * x * (x * (x * 6 - 15) + 10);
				}

				// Random integer from <low, high> interval
				function randInt(low, high) {
					return low + Math.floor(Math.random() * (high - low + 1));
				}

				// Random float from <low, high> interval
				function randFloat(low, high) {
					return low + Math.random() * (high - low);
				}

				// Random float from <-range/2, range/2> interval
				function randFloatSpread(range) {
					return range * (0.5 - Math.random());
				}

				// Deterministic pseudo-random float in the interval [ 0, 1 ]
				function seededRandom(s) {
					if (s !== undefined) _seed = s;

					// Mulberry32 generator

					let t = (_seed += 0x6d2b79f5);

					t = Math.imul(t ^ (t >>> 15), t | 1);

					t ^= t + Math.imul(t ^ (t >>> 7), t | 61);

					return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
				}

				function degToRad(degrees) {
					return degrees * DEG2RAD;
				}

				function radToDeg(radians) {
					return radians * RAD2DEG;
				}

				function isPowerOfTwo(value) {
					return (value & (value - 1)) === 0 && value !== 0;
				}

				function ceilPowerOfTwo(value) {
					return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
				}

				function floorPowerOfTwo(value) {
					return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
				}

				function setQuaternionFromProperEuler(q, a, b, c, order) {
					// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

					// rotations are applied to the axes in the order specified by 'order'
					// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
					// angles are in radians

					const cos = Math.cos;
					const sin = Math.sin;

					const c2 = cos(b / 2);
					const s2 = sin(b / 2);

					const c13 = cos((a + c) / 2);
					const s13 = sin((a + c) / 2);

					const c1_3 = cos((a - c) / 2);
					const s1_3 = sin((a - c) / 2);

					const c3_1 = cos((c - a) / 2);
					const s3_1 = sin((c - a) / 2);

					switch (order) {
						case "XYX":
							q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
							break;

						case "YZY":
							q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
							break;

						case "ZXZ":
							q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
							break;

						case "XZX":
							q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
							break;

						case "YXY":
							q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
							break;

						case "ZYZ":
							q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
							break;

						default:
							console.warn(
								"THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
									order
							);
					}
				}

				function denormalize(value, array) {
					switch (array.constructor) {
						case Float32Array:
							return value;

						case Uint32Array:
							return value / 4294967295.0;

						case Uint16Array:
							return value / 65535.0;

						case Uint8Array:
							return value / 255.0;

						case Int32Array:
							return Math.max(value / 2147483647.0, -1.0);

						case Int16Array:
							return Math.max(value / 32767.0, -1.0);

						case Int8Array:
							return Math.max(value / 127.0, -1.0);

						default:
							throw new Error("Invalid component type.");
					}
				}

				function normalize(value, array) {
					switch (array.constructor) {
						case Float32Array:
							return value;

						case Uint32Array:
							return Math.round(value * 4294967295.0);

						case Uint16Array:
							return Math.round(value * 65535.0);

						case Uint8Array:
							return Math.round(value * 255.0);

						case Int32Array:
							return Math.round(value * 2147483647.0);

						case Int16Array:
							return Math.round(value * 32767.0);

						case Int8Array:
							return Math.round(value * 127.0);

						default:
							throw new Error("Invalid component type.");
					}
				}

				const MathUtils = /* unused pure expression or super */ null && {
					DEG2RAD: DEG2RAD,
					RAD2DEG: RAD2DEG,
					generateUUID: generateUUID,
					clamp: clamp,
					euclideanModulo: euclideanModulo,
					mapLinear: mapLinear,
					inverseLerp: inverseLerp,
					lerp: lerp,
					damp: damp,
					pingpong: pingpong,
					smoothstep: smoothstep,
					smootherstep: smootherstep,
					randInt: randInt,
					randFloat: randFloat,
					randFloatSpread: randFloatSpread,
					seededRandom: seededRandom,
					degToRad: degToRad,
					radToDeg: radToDeg,
					isPowerOfTwo: isPowerOfTwo,
					ceilPowerOfTwo: ceilPowerOfTwo,
					floorPowerOfTwo: floorPowerOfTwo,
					setQuaternionFromProperEuler: setQuaternionFromProperEuler,
					normalize: normalize,
					denormalize: denormalize
				};
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Quaternion.js":
			/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Quaternion.js ***!
  \****************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Quaternion: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.Quaternion"] */ Quaternion
				});
				/* ESM import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./MathUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/MathUtils.js"
					);

				class Quaternion {
					constructor(x = 0, y = 0, z = 0, w = 1) {
						this.isQuaternion = true;

						this._x = x;
						this._y = y;
						this._z = z;
						this._w = w;
					}

					static slerpFlat(
						dst,
						dstOffset,
						src0,
						srcOffset0,
						src1,
						srcOffset1,
						t
					) {
						// fuzz-free, array-based Quaternion SLERP operation

						let x0 = src0[srcOffset0 + 0],
							y0 = src0[srcOffset0 + 1],
							z0 = src0[srcOffset0 + 2],
							w0 = src0[srcOffset0 + 3];

						const x1 = src1[srcOffset1 + 0],
							y1 = src1[srcOffset1 + 1],
							z1 = src1[srcOffset1 + 2],
							w1 = src1[srcOffset1 + 3];

						if (t === 0) {
							dst[dstOffset + 0] = x0;
							dst[dstOffset + 1] = y0;
							dst[dstOffset + 2] = z0;
							dst[dstOffset + 3] = w0;
							return;
						}

						if (t === 1) {
							dst[dstOffset + 0] = x1;
							dst[dstOffset + 1] = y1;
							dst[dstOffset + 2] = z1;
							dst[dstOffset + 3] = w1;
							return;
						}

						if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
							let s = 1 - t;
							const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
								dir = cos >= 0 ? 1 : -1,
								sqrSin = 1 - cos * cos;

							// Skip the Slerp for tiny steps to avoid numeric problems:
							if (sqrSin > Number.EPSILON) {
								const sin = Math.sqrt(sqrSin),
									len = Math.atan2(sin, cos * dir);

								s = Math.sin(s * len) / sin;
								t = Math.sin(t * len) / sin;
							}

							const tDir = t * dir;

							x0 = x0 * s + x1 * tDir;
							y0 = y0 * s + y1 * tDir;
							z0 = z0 * s + z1 * tDir;
							w0 = w0 * s + w1 * tDir;

							// Normalize in case we just did a lerp:
							if (s === 1 - t) {
								const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);

								x0 *= f;
								y0 *= f;
								z0 *= f;
								w0 *= f;
							}
						}

						dst[dstOffset] = x0;
						dst[dstOffset + 1] = y0;
						dst[dstOffset + 2] = z0;
						dst[dstOffset + 3] = w0;
					}

					static multiplyQuaternionsFlat(
						dst,
						dstOffset,
						src0,
						srcOffset0,
						src1,
						srcOffset1
					) {
						const x0 = src0[srcOffset0];
						const y0 = src0[srcOffset0 + 1];
						const z0 = src0[srcOffset0 + 2];
						const w0 = src0[srcOffset0 + 3];

						const x1 = src1[srcOffset1];
						const y1 = src1[srcOffset1 + 1];
						const z1 = src1[srcOffset1 + 2];
						const w1 = src1[srcOffset1 + 3];

						dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
						dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
						dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
						dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

						return dst;
					}

					get x() {
						return this._x;
					}

					set x(value) {
						this._x = value;
						this._onChangeCallback();
					}

					get y() {
						return this._y;
					}

					set y(value) {
						this._y = value;
						this._onChangeCallback();
					}

					get z() {
						return this._z;
					}

					set z(value) {
						this._z = value;
						this._onChangeCallback();
					}

					get w() {
						return this._w;
					}

					set w(value) {
						this._w = value;
						this._onChangeCallback();
					}

					set(x, y, z, w) {
						this._x = x;
						this._y = y;
						this._z = z;
						this._w = w;

						this._onChangeCallback();

						return this;
					}

					clone() {
						return new this.constructor(this._x, this._y, this._z, this._w);
					}

					copy(quaternion) {
						this._x = quaternion.x;
						this._y = quaternion.y;
						this._z = quaternion.z;
						this._w = quaternion.w;

						this._onChangeCallback();

						return this;
					}

					setFromEuler(euler, update = true) {
						const x = euler._x,
							y = euler._y,
							z = euler._z,
							order = euler._order;

						// http://www.mathworks.com/matlabcentral/fileexchange/
						// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
						//	content/SpinCalc.m

						const cos = Math.cos;
						const sin = Math.sin;

						const c1 = cos(x / 2);
						const c2 = cos(y / 2);
						const c3 = cos(z / 2);

						const s1 = sin(x / 2);
						const s2 = sin(y / 2);
						const s3 = sin(z / 2);

						switch (order) {
							case "XYZ":
								this._x = s1 * c2 * c3 + c1 * s2 * s3;
								this._y = c1 * s2 * c3 - s1 * c2 * s3;
								this._z = c1 * c2 * s3 + s1 * s2 * c3;
								this._w = c1 * c2 * c3 - s1 * s2 * s3;
								break;

							case "YXZ":
								this._x = s1 * c2 * c3 + c1 * s2 * s3;
								this._y = c1 * s2 * c3 - s1 * c2 * s3;
								this._z = c1 * c2 * s3 - s1 * s2 * c3;
								this._w = c1 * c2 * c3 + s1 * s2 * s3;
								break;

							case "ZXY":
								this._x = s1 * c2 * c3 - c1 * s2 * s3;
								this._y = c1 * s2 * c3 + s1 * c2 * s3;
								this._z = c1 * c2 * s3 + s1 * s2 * c3;
								this._w = c1 * c2 * c3 - s1 * s2 * s3;
								break;

							case "ZYX":
								this._x = s1 * c2 * c3 - c1 * s2 * s3;
								this._y = c1 * s2 * c3 + s1 * c2 * s3;
								this._z = c1 * c2 * s3 - s1 * s2 * c3;
								this._w = c1 * c2 * c3 + s1 * s2 * s3;
								break;

							case "YZX":
								this._x = s1 * c2 * c3 + c1 * s2 * s3;
								this._y = c1 * s2 * c3 + s1 * c2 * s3;
								this._z = c1 * c2 * s3 - s1 * s2 * c3;
								this._w = c1 * c2 * c3 - s1 * s2 * s3;
								break;

							case "XZY":
								this._x = s1 * c2 * c3 - c1 * s2 * s3;
								this._y = c1 * s2 * c3 - s1 * c2 * s3;
								this._z = c1 * c2 * s3 + s1 * s2 * c3;
								this._w = c1 * c2 * c3 + s1 * s2 * s3;
								break;

							default:
								console.warn(
									"THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
										order
								);
						}

						if (update === true) this._onChangeCallback();

						return this;
					}

					setFromAxisAngle(axis, angle) {
						// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

						// assumes axis is normalized

						const halfAngle = angle / 2,
							s = Math.sin(halfAngle);

						this._x = axis.x * s;
						this._y = axis.y * s;
						this._z = axis.z * s;
						this._w = Math.cos(halfAngle);

						this._onChangeCallback();

						return this;
					}

					setFromRotationMatrix(m) {
						// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

						// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

						const te = m.elements,
							m11 = te[0],
							m12 = te[4],
							m13 = te[8],
							m21 = te[1],
							m22 = te[5],
							m23 = te[9],
							m31 = te[2],
							m32 = te[6],
							m33 = te[10],
							trace = m11 + m22 + m33;

						if (trace > 0) {
							const s = 0.5 / Math.sqrt(trace + 1.0);

							this._w = 0.25 / s;
							this._x = (m32 - m23) * s;
							this._y = (m13 - m31) * s;
							this._z = (m21 - m12) * s;
						} else if (m11 > m22 && m11 > m33) {
							const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

							this._w = (m32 - m23) / s;
							this._x = 0.25 * s;
							this._y = (m12 + m21) / s;
							this._z = (m13 + m31) / s;
						} else if (m22 > m33) {
							const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

							this._w = (m13 - m31) / s;
							this._x = (m12 + m21) / s;
							this._y = 0.25 * s;
							this._z = (m23 + m32) / s;
						} else {
							const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

							this._w = (m21 - m12) / s;
							this._x = (m13 + m31) / s;
							this._y = (m23 + m32) / s;
							this._z = 0.25 * s;
						}

						this._onChangeCallback();

						return this;
					}

					setFromUnitVectors(vFrom, vTo) {
						// assumes direction vectors vFrom and vTo are normalized

						let r = vFrom.dot(vTo) + 1;

						if (r < Number.EPSILON) {
							// vFrom and vTo point in opposite directions

							r = 0;

							if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
								this._x = -vFrom.y;
								this._y = vFrom.x;
								this._z = 0;
								this._w = r;
							} else {
								this._x = 0;
								this._y = -vFrom.z;
								this._z = vFrom.y;
								this._w = r;
							}
						} else {
							// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

							this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
							this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
							this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
							this._w = r;
						}

						return this.normalize();
					}

					angleTo(q) {
						return (
							2 *
							Math.acos(
								Math.abs(
									_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__.clamp(
										this.dot(q),
										-1,
										1
									)
								)
							)
						);
					}

					rotateTowards(q, step) {
						const angle = this.angleTo(q);

						if (angle === 0) return this;

						const t = Math.min(1, step / angle);

						this.slerp(q, t);

						return this;
					}

					identity() {
						return this.set(0, 0, 0, 1);
					}

					invert() {
						// quaternion is assumed to have unit length

						return this.conjugate();
					}

					conjugate() {
						this._x *= -1;
						this._y *= -1;
						this._z *= -1;

						this._onChangeCallback();

						return this;
					}

					dot(v) {
						return (
							this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w
						);
					}

					lengthSq() {
						return (
							this._x * this._x +
							this._y * this._y +
							this._z * this._z +
							this._w * this._w
						);
					}

					length() {
						return Math.sqrt(
							this._x * this._x +
								this._y * this._y +
								this._z * this._z +
								this._w * this._w
						);
					}

					normalize() {
						let l = this.length();

						if (l === 0) {
							this._x = 0;
							this._y = 0;
							this._z = 0;
							this._w = 1;
						} else {
							l = 1 / l;

							this._x = this._x * l;
							this._y = this._y * l;
							this._z = this._z * l;
							this._w = this._w * l;
						}

						this._onChangeCallback();

						return this;
					}

					multiply(q) {
						return this.multiplyQuaternions(this, q);
					}

					premultiply(q) {
						return this.multiplyQuaternions(q, this);
					}

					multiplyQuaternions(a, b) {
						// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

						const qax = a._x,
							qay = a._y,
							qaz = a._z,
							qaw = a._w;
						const qbx = b._x,
							qby = b._y,
							qbz = b._z,
							qbw = b._w;

						this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
						this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
						this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
						this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

						this._onChangeCallback();

						return this;
					}

					slerp(qb, t) {
						if (t === 0) return this;
						if (t === 1) return this.copy(qb);

						const x = this._x,
							y = this._y,
							z = this._z,
							w = this._w;

						// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

						let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

						if (cosHalfTheta < 0) {
							this._w = -qb._w;
							this._x = -qb._x;
							this._y = -qb._y;
							this._z = -qb._z;

							cosHalfTheta = -cosHalfTheta;
						} else {
							this.copy(qb);
						}

						if (cosHalfTheta >= 1.0) {
							this._w = w;
							this._x = x;
							this._y = y;
							this._z = z;

							return this;
						}

						const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

						if (sqrSinHalfTheta <= Number.EPSILON) {
							const s = 1 - t;
							this._w = s * w + t * this._w;
							this._x = s * x + t * this._x;
							this._y = s * y + t * this._y;
							this._z = s * z + t * this._z;

							this.normalize(); // normalize calls _onChangeCallback()

							return this;
						}

						const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
						const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
						const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
							ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

						this._w = w * ratioA + this._w * ratioB;
						this._x = x * ratioA + this._x * ratioB;
						this._y = y * ratioA + this._y * ratioB;
						this._z = z * ratioA + this._z * ratioB;

						this._onChangeCallback();

						return this;
					}

					slerpQuaternions(qa, qb, t) {
						return this.copy(qa).slerp(qb, t);
					}

					random() {
						// sets this quaternion to a uniform random unit quaternnion

						// Ken Shoemake
						// Uniform random rotations
						// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

						const theta1 = 2 * Math.PI * Math.random();
						const theta2 = 2 * Math.PI * Math.random();

						const x0 = Math.random();
						const r1 = Math.sqrt(1 - x0);
						const r2 = Math.sqrt(x0);

						return this.set(
							r1 * Math.sin(theta1),
							r1 * Math.cos(theta1),
							r2 * Math.sin(theta2),
							r2 * Math.cos(theta2)
						);
					}

					equals(quaternion) {
						return (
							quaternion._x === this._x &&
							quaternion._y === this._y &&
							quaternion._z === this._z &&
							quaternion._w === this._w
						);
					}

					fromArray(array, offset = 0) {
						this._x = array[offset];
						this._y = array[offset + 1];
						this._z = array[offset + 2];
						this._w = array[offset + 3];

						this._onChangeCallback();

						return this;
					}

					toArray(array = [], offset = 0) {
						array[offset] = this._x;
						array[offset + 1] = this._y;
						array[offset + 2] = this._z;
						array[offset + 3] = this._w;

						return array;
					}

					fromBufferAttribute(attribute, index) {
						this._x = attribute.getX(index);
						this._y = attribute.getY(index);
						this._z = attribute.getZ(index);
						this._w = attribute.getW(index);

						this._onChangeCallback();

						return this;
					}

					toJSON() {
						return this.toArray();
					}

					_onChange(callback) {
						this._onChangeCallback = callback;

						return this;
					}

					_onChangeCallback() {}

					*[Symbol.iterator]() {
						yield this._x;
						yield this._y;
						yield this._z;
						yield this._w;
					}
				}
			}
	}
]);
