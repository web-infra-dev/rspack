"use strict";
(self["webpackChunkrspack_basic_example"] =
	self["webpackChunkrspack_basic_example"] || []).push([
	[
		"vendors-node_modules_pnpm_three_0_169_0_node_modules_three_src_animation_AnimationMixer_js"
	],
	{
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/AnimationAction.js":
			/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/AnimationAction.js ***!
  \**************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					AnimationAction: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.AnimationAction"] */ AnimationAction
				});
				/* ESM import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../constants.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js"
					);

				class AnimationAction {
					constructor(
						mixer,
						clip,
						localRoot = null,
						blendMode = clip.blendMode
					) {
						this._mixer = mixer;
						this._clip = clip;
						this._localRoot = localRoot;
						this.blendMode = blendMode;

						const tracks = clip.tracks,
							nTracks = tracks.length,
							interpolants = new Array(nTracks);

						const interpolantSettings = {
							endingStart:
								_constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroCurvatureEnding,
							endingEnd:
								_constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroCurvatureEnding
						};

						for (let i = 0; i !== nTracks; ++i) {
							const interpolant = tracks[i].createInterpolant(null);
							interpolants[i] = interpolant;
							interpolant.settings = interpolantSettings;
						}

						this._interpolantSettings = interpolantSettings;

						this._interpolants = interpolants; // bound by the mixer

						// inside: PropertyMixer (managed by the mixer)
						this._propertyBindings = new Array(nTracks);

						this._cacheIndex = null; // for the memory manager
						this._byClipCacheIndex = null; // for the memory manager

						this._timeScaleInterpolant = null;
						this._weightInterpolant = null;

						this.loop = _constants_js__WEBPACK_IMPORTED_MODULE_0__.LoopRepeat;
						this._loopCount = -1;

						// global mixer time when the action is to be started
						// it's set back to 'null' upon start of the action
						this._startTime = null;

						// scaled local time of the action
						// gets clamped or wrapped to 0..clip.duration according to loop
						this.time = 0;

						this.timeScale = 1;
						this._effectiveTimeScale = 1;

						this.weight = 1;
						this._effectiveWeight = 1;

						this.repetitions = Infinity; // no. of repetitions when looping

						this.paused = false; // true -> zero effective time scale
						this.enabled = true; // false -> zero effective weight

						this.clampWhenFinished = false; // keep feeding the last frame?

						this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
						this.zeroSlopeAtEnd = true; // clips for start, loop and end
					}

					// State & Scheduling

					play() {
						this._mixer._activateAction(this);

						return this;
					}

					stop() {
						this._mixer._deactivateAction(this);

						return this.reset();
					}

					reset() {
						this.paused = false;
						this.enabled = true;

						this.time = 0; // restart clip
						this._loopCount = -1; // forget previous loops
						this._startTime = null; // forget scheduling

						return this.stopFading().stopWarping();
					}

					isRunning() {
						return (
							this.enabled &&
							!this.paused &&
							this.timeScale !== 0 &&
							this._startTime === null &&
							this._mixer._isActiveAction(this)
						);
					}

					// return true when play has been called
					isScheduled() {
						return this._mixer._isActiveAction(this);
					}

					startAt(time) {
						this._startTime = time;

						return this;
					}

					setLoop(mode, repetitions) {
						this.loop = mode;
						this.repetitions = repetitions;

						return this;
					}

					// Weight

					// set the weight stopping any scheduled fading
					// although .enabled = false yields an effective weight of zero, this
					// method does *not* change .enabled, because it would be confusing
					setEffectiveWeight(weight) {
						this.weight = weight;

						// note: same logic as when updated at runtime
						this._effectiveWeight = this.enabled ? weight : 0;

						return this.stopFading();
					}

					// return the weight considering fading and .enabled
					getEffectiveWeight() {
						return this._effectiveWeight;
					}

					fadeIn(duration) {
						return this._scheduleFading(duration, 0, 1);
					}

					fadeOut(duration) {
						return this._scheduleFading(duration, 1, 0);
					}

					crossFadeFrom(fadeOutAction, duration, warp) {
						fadeOutAction.fadeOut(duration);
						this.fadeIn(duration);

						if (warp) {
							const fadeInDuration = this._clip.duration,
								fadeOutDuration = fadeOutAction._clip.duration,
								startEndRatio = fadeOutDuration / fadeInDuration,
								endStartRatio = fadeInDuration / fadeOutDuration;

							fadeOutAction.warp(1.0, startEndRatio, duration);
							this.warp(endStartRatio, 1.0, duration);
						}

						return this;
					}

					crossFadeTo(fadeInAction, duration, warp) {
						return fadeInAction.crossFadeFrom(this, duration, warp);
					}

					stopFading() {
						const weightInterpolant = this._weightInterpolant;

						if (weightInterpolant !== null) {
							this._weightInterpolant = null;
							this._mixer._takeBackControlInterpolant(weightInterpolant);
						}

						return this;
					}

					// Time Scale Control

					// set the time scale stopping any scheduled warping
					// although .paused = true yields an effective time scale of zero, this
					// method does *not* change .paused, because it would be confusing
					setEffectiveTimeScale(timeScale) {
						this.timeScale = timeScale;
						this._effectiveTimeScale = this.paused ? 0 : timeScale;

						return this.stopWarping();
					}

					// return the time scale considering warping and .paused
					getEffectiveTimeScale() {
						return this._effectiveTimeScale;
					}

					setDuration(duration) {
						this.timeScale = this._clip.duration / duration;

						return this.stopWarping();
					}

					syncWith(action) {
						this.time = action.time;
						this.timeScale = action.timeScale;

						return this.stopWarping();
					}

					halt(duration) {
						return this.warp(this._effectiveTimeScale, 0, duration);
					}

					warp(startTimeScale, endTimeScale, duration) {
						const mixer = this._mixer,
							now = mixer.time,
							timeScale = this.timeScale;

						let interpolant = this._timeScaleInterpolant;

						if (interpolant === null) {
							interpolant = mixer._lendControlInterpolant();
							this._timeScaleInterpolant = interpolant;
						}

						const times = interpolant.parameterPositions,
							values = interpolant.sampleValues;

						times[0] = now;
						times[1] = now + duration;

						values[0] = startTimeScale / timeScale;
						values[1] = endTimeScale / timeScale;

						return this;
					}

					stopWarping() {
						const timeScaleInterpolant = this._timeScaleInterpolant;

						if (timeScaleInterpolant !== null) {
							this._timeScaleInterpolant = null;
							this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
						}

						return this;
					}

					// Object Accessors

					getMixer() {
						return this._mixer;
					}

					getClip() {
						return this._clip;
					}

					getRoot() {
						return this._localRoot || this._mixer._root;
					}

					// Interna

					_update(time, deltaTime, timeDirection, accuIndex) {
						// called by the mixer

						if (!this.enabled) {
							// call ._updateWeight() to update ._effectiveWeight

							this._updateWeight(time);
							return;
						}

						const startTime = this._startTime;

						if (startTime !== null) {
							// check for scheduled start of action

							const timeRunning = (time - startTime) * timeDirection;
							if (timeRunning < 0 || timeDirection === 0) {
								deltaTime = 0;
							} else {
								this._startTime = null; // unschedule
								deltaTime = timeDirection * timeRunning;
							}
						}

						// apply time scale and advance time

						deltaTime *= this._updateTimeScale(time);
						const clipTime = this._updateTime(deltaTime);

						// note: _updateTime may disable the action resulting in
						// an effective weight of 0

						const weight = this._updateWeight(time);

						if (weight > 0) {
							const interpolants = this._interpolants;
							const propertyMixers = this._propertyBindings;

							switch (this.blendMode) {
								case _constants_js__WEBPACK_IMPORTED_MODULE_0__.AdditiveAnimationBlendMode:
									for (let j = 0, m = interpolants.length; j !== m; ++j) {
										interpolants[j].evaluate(clipTime);
										propertyMixers[j].accumulateAdditive(weight);
									}

									break;

								case _constants_js__WEBPACK_IMPORTED_MODULE_0__.NormalAnimationBlendMode:
								default:
									for (let j = 0, m = interpolants.length; j !== m; ++j) {
										interpolants[j].evaluate(clipTime);
										propertyMixers[j].accumulate(accuIndex, weight);
									}
							}
						}
					}

					_updateWeight(time) {
						let weight = 0;

						if (this.enabled) {
							weight = this.weight;
							const interpolant = this._weightInterpolant;

							if (interpolant !== null) {
								const interpolantValue = interpolant.evaluate(time)[0];

								weight *= interpolantValue;

								if (time > interpolant.parameterPositions[1]) {
									this.stopFading();

									if (interpolantValue === 0) {
										// faded out, disable
										this.enabled = false;
									}
								}
							}
						}

						this._effectiveWeight = weight;
						return weight;
					}

					_updateTimeScale(time) {
						let timeScale = 0;

						if (!this.paused) {
							timeScale = this.timeScale;

							const interpolant = this._timeScaleInterpolant;

							if (interpolant !== null) {
								const interpolantValue = interpolant.evaluate(time)[0];

								timeScale *= interpolantValue;

								if (time > interpolant.parameterPositions[1]) {
									this.stopWarping();

									if (timeScale === 0) {
										// motion has halted, pause
										this.paused = true;
									} else {
										// warp done - apply final time scale
										this.timeScale = timeScale;
									}
								}
							}
						}

						this._effectiveTimeScale = timeScale;
						return timeScale;
					}

					_updateTime(deltaTime) {
						const duration = this._clip.duration;
						const loop = this.loop;

						let time = this.time + deltaTime;
						let loopCount = this._loopCount;

						const pingPong =
							loop === _constants_js__WEBPACK_IMPORTED_MODULE_0__.LoopPingPong;

						if (deltaTime === 0) {
							if (loopCount === -1) return time;

							return pingPong && (loopCount & 1) === 1 ? duration - time : time;
						}

						if (loop === _constants_js__WEBPACK_IMPORTED_MODULE_0__.LoopOnce) {
							if (loopCount === -1) {
								// just started

								this._loopCount = 0;
								this._setEndings(true, true, false);
							}

							handle_stop: {
								if (time >= duration) {
									time = duration;
								} else if (time < 0) {
									time = 0;
								} else {
									this.time = time;

									break handle_stop;
								}

								if (this.clampWhenFinished) this.paused = true;
								else this.enabled = false;

								this.time = time;

								this._mixer.dispatchEvent({
									type: "finished",
									action: this,
									direction: deltaTime < 0 ? -1 : 1
								});
							}
						} else {
							// repetitive Repeat or PingPong

							if (loopCount === -1) {
								// just started

								if (deltaTime >= 0) {
									loopCount = 0;

									this._setEndings(true, this.repetitions === 0, pingPong);
								} else {
									// when looping in reverse direction, the initial
									// transition through zero counts as a repetition,
									// so leave loopCount at -1

									this._setEndings(this.repetitions === 0, true, pingPong);
								}
							}

							if (time >= duration || time < 0) {
								// wrap around

								const loopDelta = Math.floor(time / duration); // signed
								time -= duration * loopDelta;

								loopCount += Math.abs(loopDelta);

								const pending = this.repetitions - loopCount;

								if (pending <= 0) {
									// have to stop (switch state, clamp time, fire event)

									if (this.clampWhenFinished) this.paused = true;
									else this.enabled = false;

									time = deltaTime > 0 ? duration : 0;

									this.time = time;

									this._mixer.dispatchEvent({
										type: "finished",
										action: this,
										direction: deltaTime > 0 ? 1 : -1
									});
								} else {
									// keep running

									if (pending === 1) {
										// entering the last round

										const atStart = deltaTime < 0;
										this._setEndings(atStart, !atStart, pingPong);
									} else {
										this._setEndings(false, false, pingPong);
									}

									this._loopCount = loopCount;

									this.time = time;

									this._mixer.dispatchEvent({
										type: "loop",
										action: this,
										loopDelta: loopDelta
									});
								}
							} else {
								this.time = time;
							}

							if (pingPong && (loopCount & 1) === 1) {
								// invert time for the "pong round"

								return duration - time;
							}
						}

						return time;
					}

					_setEndings(atStart, atEnd, pingPong) {
						const settings = this._interpolantSettings;

						if (pingPong) {
							settings.endingStart =
								_constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroSlopeEnding;
							settings.endingEnd =
								_constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroSlopeEnding;
						} else {
							// assuming for LoopOnce atStart == atEnd == true

							if (atStart) {
								settings.endingStart = this.zeroSlopeAtStart
									? _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroSlopeEnding
									: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroCurvatureEnding;
							} else {
								settings.endingStart =
									_constants_js__WEBPACK_IMPORTED_MODULE_0__.WrapAroundEnding;
							}

							if (atEnd) {
								settings.endingEnd = this.zeroSlopeAtEnd
									? _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroSlopeEnding
									: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroCurvatureEnding;
							} else {
								settings.endingEnd =
									_constants_js__WEBPACK_IMPORTED_MODULE_0__.WrapAroundEnding;
							}
						}
					}

					_scheduleFading(duration, weightNow, weightThen) {
						const mixer = this._mixer,
							now = mixer.time;
						let interpolant = this._weightInterpolant;

						if (interpolant === null) {
							interpolant = mixer._lendControlInterpolant();
							this._weightInterpolant = interpolant;
						}

						const times = interpolant.parameterPositions,
							values = interpolant.sampleValues;

						times[0] = now;
						values[0] = weightNow;
						times[1] = now + duration;
						values[1] = weightThen;

						return this;
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/AnimationClip.js":
			/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/AnimationClip.js ***!
  \************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					AnimationClip: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.AnimationClip"] */ AnimationClip
				});
				/* ESM import */ var _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_3__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./AnimationUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/AnimationUtils.js"
					);
				/* ESM import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./KeyframeTrack.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/KeyframeTrack.js"
					);
				/* ESM import */ var _tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_8__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./tracks/BooleanKeyframeTrack.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/BooleanKeyframeTrack.js"
					);
				/* ESM import */ var _tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./tracks/ColorKeyframeTrack.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/ColorKeyframeTrack.js"
					);
				/* ESM import */ var _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./tracks/NumberKeyframeTrack.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/NumberKeyframeTrack.js"
					);
				/* ESM import */ var _tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_6__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./tracks/QuaternionKeyframeTrack.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/QuaternionKeyframeTrack.js"
					);
				/* ESM import */ var _tracks_StringKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_9__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./tracks/StringKeyframeTrack.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/StringKeyframeTrack.js"
					);
				/* ESM import */ var _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./tracks/VectorKeyframeTrack.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/VectorKeyframeTrack.js"
					);
				/* ESM import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/MathUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/MathUtils.js"
					);
				/* ESM import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../constants.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js"
					);

				class AnimationClip {
					constructor(
						name = "",
						duration = -1,
						tracks = [],
						blendMode = _constants_js__WEBPACK_IMPORTED_MODULE_0__.NormalAnimationBlendMode
					) {
						this.name = name;
						this.tracks = tracks;
						this.duration = duration;
						this.blendMode = blendMode;

						this.uuid =
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__.generateUUID();

						// this means it should figure out its duration by scanning the tracks
						if (this.duration < 0) {
							this.resetDuration();
						}
					}

					static parse(json) {
						const tracks = [],
							jsonTracks = json.tracks,
							frameTime = 1.0 / (json.fps || 1.0);

						for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
							tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
						}

						const clip = new this(
							json.name,
							json.duration,
							tracks,
							json.blendMode
						);
						clip.uuid = json.uuid;

						return clip;
					}

					static toJSON(clip) {
						const tracks = [],
							clipTracks = clip.tracks;

						const json = {
							name: clip.name,
							duration: clip.duration,
							tracks: tracks,
							uuid: clip.uuid,
							blendMode: clip.blendMode
						};

						for (let i = 0, n = clipTracks.length; i !== n; ++i) {
							tracks.push(
								_KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__.KeyframeTrack.toJSON(
									clipTracks[i]
								)
							);
						}

						return json;
					}

					static CreateFromMorphTargetSequence(
						name,
						morphTargetSequence,
						fps,
						noLoop
					) {
						const numMorphTargets = morphTargetSequence.length;
						const tracks = [];

						for (let i = 0; i < numMorphTargets; i++) {
							let times = [];
							let values = [];

							times.push(
								(i + numMorphTargets - 1) % numMorphTargets,
								i,
								(i + 1) % numMorphTargets
							);

							values.push(0, 1, 0);

							const order =
								_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_3__.getKeyframeOrder(
									times
								);
							times =
								_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_3__.sortedArray(
									times,
									1,
									order
								);
							values =
								_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_3__.sortedArray(
									values,
									1,
									order
								);

							// if there is a key at the first frame, duplicate it as the
							// last frame as well for perfect loop.
							if (!noLoop && times[0] === 0) {
								times.push(numMorphTargets);
								values.push(values[0]);
							}

							tracks.push(
								new _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__.NumberKeyframeTrack(
									".morphTargetInfluences[" + morphTargetSequence[i].name + "]",
									times,
									values
								).scale(1.0 / fps)
							);
						}

						return new this(name, -1, tracks);
					}

					static findByName(objectOrClipArray, name) {
						let clipArray = objectOrClipArray;

						if (!Array.isArray(objectOrClipArray)) {
							const o = objectOrClipArray;
							clipArray = (o.geometry && o.geometry.animations) || o.animations;
						}

						for (let i = 0; i < clipArray.length; i++) {
							if (clipArray[i].name === name) {
								return clipArray[i];
							}
						}

						return null;
					}

					static CreateClipsFromMorphTargetSequences(
						morphTargets,
						fps,
						noLoop
					) {
						const animationToMorphTargets = {};

						// tested with https://regex101.com/ on trick sequences
						// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
						const pattern = /^([\w-]*?)([\d]+)$/;

						// sort morph target names into animation groups based
						// patterns like Walk_001, Walk_002, Run_001, Run_002
						for (let i = 0, il = morphTargets.length; i < il; i++) {
							const morphTarget = morphTargets[i];
							const parts = morphTarget.name.match(pattern);

							if (parts && parts.length > 1) {
								const name = parts[1];

								let animationMorphTargets = animationToMorphTargets[name];

								if (!animationMorphTargets) {
									animationToMorphTargets[name] = animationMorphTargets = [];
								}

								animationMorphTargets.push(morphTarget);
							}
						}

						const clips = [];

						for (const name in animationToMorphTargets) {
							clips.push(
								this.CreateFromMorphTargetSequence(
									name,
									animationToMorphTargets[name],
									fps,
									noLoop
								)
							);
						}

						return clips;
					}

					// parse the animation.hierarchy format
					static parseAnimation(animation, bones) {
						if (!animation) {
							console.error(
								"THREE.AnimationClip: No animation in JSONLoader data."
							);
							return null;
						}

						const addNonemptyTrack = function (
							trackType,
							trackName,
							animationKeys,
							propertyName,
							destTracks
						) {
							// only return track if there are actually keys.
							if (animationKeys.length !== 0) {
								const times = [];
								const values = [];

								_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_3__.flattenJSON(
									animationKeys,
									times,
									values,
									propertyName
								);

								// empty keys are filtered out, so check again
								if (times.length !== 0) {
									destTracks.push(new trackType(trackName, times, values));
								}
							}
						};

						const tracks = [];

						const clipName = animation.name || "default";
						const fps = animation.fps || 30;
						const blendMode = animation.blendMode;

						// automatic length determination in AnimationClip.
						let duration = animation.length || -1;

						const hierarchyTracks = animation.hierarchy || [];

						for (let h = 0; h < hierarchyTracks.length; h++) {
							const animationKeys = hierarchyTracks[h].keys;

							// skip empty tracks
							if (!animationKeys || animationKeys.length === 0) continue;

							// process morph targets
							if (animationKeys[0].morphTargets) {
								// figure out all morph targets used in this track
								const morphTargetNames = {};

								let k;

								for (k = 0; k < animationKeys.length; k++) {
									if (animationKeys[k].morphTargets) {
										for (
											let m = 0;
											m < animationKeys[k].morphTargets.length;
											m++
										) {
											morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
										}
									}
								}

								// create a track for each morph target with all zero
								// morphTargetInfluences except for the keys in which
								// the morphTarget is named.
								for (const morphTargetName in morphTargetNames) {
									const times = [];
									const values = [];

									for (
										let m = 0;
										m !== animationKeys[k].morphTargets.length;
										++m
									) {
										const animationKey = animationKeys[k];

										times.push(animationKey.time);
										values.push(
											animationKey.morphTarget === morphTargetName ? 1 : 0
										);
									}

									tracks.push(
										new _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__.NumberKeyframeTrack(
											".morphTargetInfluence[" + morphTargetName + "]",
											times,
											values
										)
									);
								}

								duration = morphTargetNames.length * fps;
							} else {
								// ...assume skeletal animation

								const boneName = ".bones[" + bones[h].name + "]";

								addNonemptyTrack(
									_tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__.VectorKeyframeTrack,
									boneName + ".position",
									animationKeys,
									"pos",
									tracks
								);

								addNonemptyTrack(
									_tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_6__.QuaternionKeyframeTrack,
									boneName + ".quaternion",
									animationKeys,
									"rot",
									tracks
								);

								addNonemptyTrack(
									_tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__.VectorKeyframeTrack,
									boneName + ".scale",
									animationKeys,
									"scl",
									tracks
								);
							}
						}

						if (tracks.length === 0) {
							return null;
						}

						const clip = new this(clipName, duration, tracks, blendMode);

						return clip;
					}

					resetDuration() {
						const tracks = this.tracks;
						let duration = 0;

						for (let i = 0, n = tracks.length; i !== n; ++i) {
							const track = this.tracks[i];

							duration = Math.max(
								duration,
								track.times[track.times.length - 1]
							);
						}

						this.duration = duration;

						return this;
					}

					trim() {
						for (let i = 0; i < this.tracks.length; i++) {
							this.tracks[i].trim(0, this.duration);
						}

						return this;
					}

					validate() {
						let valid = true;

						for (let i = 0; i < this.tracks.length; i++) {
							valid = valid && this.tracks[i].validate();
						}

						return valid;
					}

					optimize() {
						for (let i = 0; i < this.tracks.length; i++) {
							this.tracks[i].optimize();
						}

						return this;
					}

					clone() {
						const tracks = [];

						for (let i = 0; i < this.tracks.length; i++) {
							tracks.push(this.tracks[i].clone());
						}

						return new this.constructor(
							this.name,
							this.duration,
							tracks,
							this.blendMode
						);
					}

					toJSON() {
						return this.constructor.toJSON(this);
					}
				}

				function getTrackTypeForValueTypeName(typeName) {
					switch (typeName.toLowerCase()) {
						case "scalar":
						case "double":
						case "float":
						case "number":
						case "integer":
							return _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__.NumberKeyframeTrack;

						case "vector":
						case "vector2":
						case "vector3":
						case "vector4":
							return _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__.VectorKeyframeTrack;

						case "color":
							return _tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__.ColorKeyframeTrack;

						case "quaternion":
							return _tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_6__.QuaternionKeyframeTrack;

						case "bool":
						case "boolean":
							return _tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_8__.BooleanKeyframeTrack;

						case "string":
							return _tracks_StringKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_9__.StringKeyframeTrack;
					}

					throw new Error(
						"THREE.KeyframeTrack: Unsupported typeName: " + typeName
					);
				}

				function parseKeyframeTrack(json) {
					if (json.type === undefined) {
						throw new Error(
							"THREE.KeyframeTrack: track type undefined, can not parse"
						);
					}

					const trackType = getTrackTypeForValueTypeName(json.type);

					if (json.times === undefined) {
						const times = [],
							values = [];

						_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_3__.flattenJSON(
							json.keys,
							times,
							values,
							"value"
						);

						json.times = times;
						json.values = values;
					}

					// derived classes can define a static parse method
					if (trackType.parse !== undefined) {
						return trackType.parse(json);
					} else {
						// by default, we assume a constructor compatible with the base
						return new trackType(
							json.name,
							json.times,
							json.values,
							json.interpolation
						);
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/AnimationMixer.js":
			/*!*************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/AnimationMixer.js ***!
  \*************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.r(__webpack_exports__);
				__webpack_require__.d(__webpack_exports__, {
					AnimationMixer: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.AnimationMixer"] */ AnimationMixer
				});
				/* ESM import */ var _AnimationAction_js__WEBPACK_IMPORTED_MODULE_6__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./AnimationAction.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/AnimationAction.js"
					);
				/* ESM import */ var _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../core/EventDispatcher.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/EventDispatcher.js"
					);
				/* ESM import */ var _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_3__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/interpolants/LinearInterpolant.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/interpolants/LinearInterpolant.js"
					);
				/* ESM import */ var _PropertyBinding_js__WEBPACK_IMPORTED_MODULE_2__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./PropertyBinding.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/PropertyBinding.js"
					);
				/* ESM import */ var _PropertyMixer_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./PropertyMixer.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/PropertyMixer.js"
					);
				/* ESM import */ var _AnimationClip_js__WEBPACK_IMPORTED_MODULE_4__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./AnimationClip.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/AnimationClip.js"
					);
				/* ESM import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../constants.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js"
					);

				const _controlInterpolantsResultBuffer = new Float32Array(1);

				class AnimationMixer extends _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {
					constructor(root) {
						super();

						this._root = root;
						this._initMemoryManager();
						this._accuIndex = 0;
						this.time = 0;
						this.timeScale = 1.0;
					}

					_bindAction(action, prototypeAction) {
						const root = action._localRoot || this._root,
							tracks = action._clip.tracks,
							nTracks = tracks.length,
							bindings = action._propertyBindings,
							interpolants = action._interpolants,
							rootUuid = root.uuid,
							bindingsByRoot = this._bindingsByRootAndName;

						let bindingsByName = bindingsByRoot[rootUuid];

						if (bindingsByName === undefined) {
							bindingsByName = {};
							bindingsByRoot[rootUuid] = bindingsByName;
						}

						for (let i = 0; i !== nTracks; ++i) {
							const track = tracks[i],
								trackName = track.name;

							let binding = bindingsByName[trackName];

							if (binding !== undefined) {
								++binding.referenceCount;
								bindings[i] = binding;
							} else {
								binding = bindings[i];

								if (binding !== undefined) {
									// existing binding, make sure the cache knows

									if (binding._cacheIndex === null) {
										++binding.referenceCount;
										this._addInactiveBinding(binding, rootUuid, trackName);
									}

									continue;
								}

								const path =
									prototypeAction &&
									prototypeAction._propertyBindings[i].binding.parsedPath;

								binding =
									new _PropertyMixer_js__WEBPACK_IMPORTED_MODULE_1__.PropertyMixer(
										_PropertyBinding_js__WEBPACK_IMPORTED_MODULE_2__.PropertyBinding.create(
											root,
											trackName,
											path
										),
										track.ValueTypeName,
										track.getValueSize()
									);

								++binding.referenceCount;
								this._addInactiveBinding(binding, rootUuid, trackName);

								bindings[i] = binding;
							}

							interpolants[i].resultBuffer = binding.buffer;
						}
					}

					_activateAction(action) {
						if (!this._isActiveAction(action)) {
							if (action._cacheIndex === null) {
								// this action has been forgotten by the cache, but the user
								// appears to be still using it -> rebind

								const rootUuid = (action._localRoot || this._root).uuid,
									clipUuid = action._clip.uuid,
									actionsForClip = this._actionsByClip[clipUuid];

								this._bindAction(
									action,
									actionsForClip && actionsForClip.knownActions[0]
								);

								this._addInactiveAction(action, clipUuid, rootUuid);
							}

							const bindings = action._propertyBindings;

							// increment reference counts / sort out state
							for (let i = 0, n = bindings.length; i !== n; ++i) {
								const binding = bindings[i];

								if (binding.useCount++ === 0) {
									this._lendBinding(binding);
									binding.saveOriginalState();
								}
							}

							this._lendAction(action);
						}
					}

					_deactivateAction(action) {
						if (this._isActiveAction(action)) {
							const bindings = action._propertyBindings;

							// decrement reference counts / sort out state
							for (let i = 0, n = bindings.length; i !== n; ++i) {
								const binding = bindings[i];

								if (--binding.useCount === 0) {
									binding.restoreOriginalState();
									this._takeBackBinding(binding);
								}
							}

							this._takeBackAction(action);
						}
					}

					// Memory manager

					_initMemoryManager() {
						this._actions = []; // 'nActiveActions' followed by inactive ones
						this._nActiveActions = 0;

						this._actionsByClip = {};
						// inside:
						// {
						// 	knownActions: Array< AnimationAction > - used as prototypes
						// 	actionByRoot: AnimationAction - lookup
						// }

						this._bindings = []; // 'nActiveBindings' followed by inactive ones
						this._nActiveBindings = 0;

						this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

						this._controlInterpolants = []; // same game as above
						this._nActiveControlInterpolants = 0;

						const scope = this;

						this.stats = {
							actions: {
								get total() {
									return scope._actions.length;
								},
								get inUse() {
									return scope._nActiveActions;
								}
							},
							bindings: {
								get total() {
									return scope._bindings.length;
								},
								get inUse() {
									return scope._nActiveBindings;
								}
							},
							controlInterpolants: {
								get total() {
									return scope._controlInterpolants.length;
								},
								get inUse() {
									return scope._nActiveControlInterpolants;
								}
							}
						};
					}

					// Memory management for AnimationAction objects

					_isActiveAction(action) {
						const index = action._cacheIndex;
						return index !== null && index < this._nActiveActions;
					}

					_addInactiveAction(action, clipUuid, rootUuid) {
						const actions = this._actions,
							actionsByClip = this._actionsByClip;

						let actionsForClip = actionsByClip[clipUuid];

						if (actionsForClip === undefined) {
							actionsForClip = {
								knownActions: [action],
								actionByRoot: {}
							};

							action._byClipCacheIndex = 0;

							actionsByClip[clipUuid] = actionsForClip;
						} else {
							const knownActions = actionsForClip.knownActions;

							action._byClipCacheIndex = knownActions.length;
							knownActions.push(action);
						}

						action._cacheIndex = actions.length;
						actions.push(action);

						actionsForClip.actionByRoot[rootUuid] = action;
					}

					_removeInactiveAction(action) {
						const actions = this._actions,
							lastInactiveAction = actions[actions.length - 1],
							cacheIndex = action._cacheIndex;

						lastInactiveAction._cacheIndex = cacheIndex;
						actions[cacheIndex] = lastInactiveAction;
						actions.pop();

						action._cacheIndex = null;

						const clipUuid = action._clip.uuid,
							actionsByClip = this._actionsByClip,
							actionsForClip = actionsByClip[clipUuid],
							knownActionsForClip = actionsForClip.knownActions,
							lastKnownAction =
								knownActionsForClip[knownActionsForClip.length - 1],
							byClipCacheIndex = action._byClipCacheIndex;

						lastKnownAction._byClipCacheIndex = byClipCacheIndex;
						knownActionsForClip[byClipCacheIndex] = lastKnownAction;
						knownActionsForClip.pop();

						action._byClipCacheIndex = null;

						const actionByRoot = actionsForClip.actionByRoot,
							rootUuid = (action._localRoot || this._root).uuid;

						delete actionByRoot[rootUuid];

						if (knownActionsForClip.length === 0) {
							delete actionsByClip[clipUuid];
						}

						this._removeInactiveBindingsForAction(action);
					}

					_removeInactiveBindingsForAction(action) {
						const bindings = action._propertyBindings;

						for (let i = 0, n = bindings.length; i !== n; ++i) {
							const binding = bindings[i];

							if (--binding.referenceCount === 0) {
								this._removeInactiveBinding(binding);
							}
						}
					}

					_lendAction(action) {
						// [ active actions |  inactive actions  ]
						// [  active actions >| inactive actions ]
						//                 s        a
						//                  <-swap->
						//                 a        s

						const actions = this._actions,
							prevIndex = action._cacheIndex,
							lastActiveIndex = this._nActiveActions++,
							firstInactiveAction = actions[lastActiveIndex];

						action._cacheIndex = lastActiveIndex;
						actions[lastActiveIndex] = action;

						firstInactiveAction._cacheIndex = prevIndex;
						actions[prevIndex] = firstInactiveAction;
					}

					_takeBackAction(action) {
						// [  active actions  | inactive actions ]
						// [ active actions |< inactive actions  ]
						//        a        s
						//         <-swap->
						//        s        a

						const actions = this._actions,
							prevIndex = action._cacheIndex,
							firstInactiveIndex = --this._nActiveActions,
							lastActiveAction = actions[firstInactiveIndex];

						action._cacheIndex = firstInactiveIndex;
						actions[firstInactiveIndex] = action;

						lastActiveAction._cacheIndex = prevIndex;
						actions[prevIndex] = lastActiveAction;
					}

					// Memory management for PropertyMixer objects

					_addInactiveBinding(binding, rootUuid, trackName) {
						const bindingsByRoot = this._bindingsByRootAndName,
							bindings = this._bindings;

						let bindingByName = bindingsByRoot[rootUuid];

						if (bindingByName === undefined) {
							bindingByName = {};
							bindingsByRoot[rootUuid] = bindingByName;
						}

						bindingByName[trackName] = binding;

						binding._cacheIndex = bindings.length;
						bindings.push(binding);
					}

					_removeInactiveBinding(binding) {
						const bindings = this._bindings,
							propBinding = binding.binding,
							rootUuid = propBinding.rootNode.uuid,
							trackName = propBinding.path,
							bindingsByRoot = this._bindingsByRootAndName,
							bindingByName = bindingsByRoot[rootUuid],
							lastInactiveBinding = bindings[bindings.length - 1],
							cacheIndex = binding._cacheIndex;

						lastInactiveBinding._cacheIndex = cacheIndex;
						bindings[cacheIndex] = lastInactiveBinding;
						bindings.pop();

						delete bindingByName[trackName];

						if (Object.keys(bindingByName).length === 0) {
							delete bindingsByRoot[rootUuid];
						}
					}

					_lendBinding(binding) {
						const bindings = this._bindings,
							prevIndex = binding._cacheIndex,
							lastActiveIndex = this._nActiveBindings++,
							firstInactiveBinding = bindings[lastActiveIndex];

						binding._cacheIndex = lastActiveIndex;
						bindings[lastActiveIndex] = binding;

						firstInactiveBinding._cacheIndex = prevIndex;
						bindings[prevIndex] = firstInactiveBinding;
					}

					_takeBackBinding(binding) {
						const bindings = this._bindings,
							prevIndex = binding._cacheIndex,
							firstInactiveIndex = --this._nActiveBindings,
							lastActiveBinding = bindings[firstInactiveIndex];

						binding._cacheIndex = firstInactiveIndex;
						bindings[firstInactiveIndex] = binding;

						lastActiveBinding._cacheIndex = prevIndex;
						bindings[prevIndex] = lastActiveBinding;
					}

					// Memory management of Interpolants for weight and time scale

					_lendControlInterpolant() {
						const interpolants = this._controlInterpolants,
							lastActiveIndex = this._nActiveControlInterpolants++;

						let interpolant = interpolants[lastActiveIndex];

						if (interpolant === undefined) {
							interpolant =
								new _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_3__.LinearInterpolant(
									new Float32Array(2),
									new Float32Array(2),
									1,
									_controlInterpolantsResultBuffer
								);

							interpolant.__cacheIndex = lastActiveIndex;
							interpolants[lastActiveIndex] = interpolant;
						}

						return interpolant;
					}

					_takeBackControlInterpolant(interpolant) {
						const interpolants = this._controlInterpolants,
							prevIndex = interpolant.__cacheIndex,
							firstInactiveIndex = --this._nActiveControlInterpolants,
							lastActiveInterpolant = interpolants[firstInactiveIndex];

						interpolant.__cacheIndex = firstInactiveIndex;
						interpolants[firstInactiveIndex] = interpolant;

						lastActiveInterpolant.__cacheIndex = prevIndex;
						interpolants[prevIndex] = lastActiveInterpolant;
					}

					// return an action for a clip optionally using a custom root target
					// object (this method allocates a lot of dynamic memory in case a
					// previously unknown clip/root combination is specified)
					clipAction(clip, optionalRoot, blendMode) {
						const root = optionalRoot || this._root,
							rootUuid = root.uuid;

						let clipObject =
							typeof clip === "string"
								? _AnimationClip_js__WEBPACK_IMPORTED_MODULE_4__.AnimationClip.findByName(
										root,
										clip
									)
								: clip;

						const clipUuid = clipObject !== null ? clipObject.uuid : clip;

						const actionsForClip = this._actionsByClip[clipUuid];
						let prototypeAction = null;

						if (blendMode === undefined) {
							if (clipObject !== null) {
								blendMode = clipObject.blendMode;
							} else {
								blendMode =
									_constants_js__WEBPACK_IMPORTED_MODULE_5__.NormalAnimationBlendMode;
							}
						}

						if (actionsForClip !== undefined) {
							const existingAction = actionsForClip.actionByRoot[rootUuid];

							if (
								existingAction !== undefined &&
								existingAction.blendMode === blendMode
							) {
								return existingAction;
							}

							// we know the clip, so we don't have to parse all
							// the bindings again but can just copy
							prototypeAction = actionsForClip.knownActions[0];

							// also, take the clip from the prototype action
							if (clipObject === null) clipObject = prototypeAction._clip;
						}

						// clip must be known when specified via string
						if (clipObject === null) return null;

						// allocate all resources required to run it
						const newAction =
							new _AnimationAction_js__WEBPACK_IMPORTED_MODULE_6__.AnimationAction(
								this,
								clipObject,
								optionalRoot,
								blendMode
							);

						this._bindAction(newAction, prototypeAction);

						// and make the action known to the memory manager
						this._addInactiveAction(newAction, clipUuid, rootUuid);

						return newAction;
					}

					// get an existing action
					existingAction(clip, optionalRoot) {
						const root = optionalRoot || this._root,
							rootUuid = root.uuid,
							clipObject =
								typeof clip === "string"
									? _AnimationClip_js__WEBPACK_IMPORTED_MODULE_4__.AnimationClip.findByName(
											root,
											clip
										)
									: clip,
							clipUuid = clipObject ? clipObject.uuid : clip,
							actionsForClip = this._actionsByClip[clipUuid];

						if (actionsForClip !== undefined) {
							return actionsForClip.actionByRoot[rootUuid] || null;
						}

						return null;
					}

					// deactivates all previously scheduled actions
					stopAllAction() {
						const actions = this._actions,
							nActions = this._nActiveActions;

						for (let i = nActions - 1; i >= 0; --i) {
							actions[i].stop();
						}

						return this;
					}

					// advance the time and update apply the animation
					update(deltaTime) {
						deltaTime *= this.timeScale;

						const actions = this._actions,
							nActions = this._nActiveActions,
							time = (this.time += deltaTime),
							timeDirection = Math.sign(deltaTime),
							accuIndex = (this._accuIndex ^= 1);

						// run active actions

						for (let i = 0; i !== nActions; ++i) {
							const action = actions[i];

							action._update(time, deltaTime, timeDirection, accuIndex);
						}

						// update scene graph

						const bindings = this._bindings,
							nBindings = this._nActiveBindings;

						for (let i = 0; i !== nBindings; ++i) {
							bindings[i].apply(accuIndex);
						}

						return this;
					}

					// Allows you to seek to a specific time in an animation.
					setTime(timeInSeconds) {
						this.time = 0; // Zero out time attribute for AnimationMixer object;
						for (let i = 0; i < this._actions.length; i++) {
							this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
						}

						return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
					}

					// return this mixer's root target object
					getRoot() {
						return this._root;
					}

					// free all resources specific to a particular clip
					uncacheClip(clip) {
						const actions = this._actions,
							clipUuid = clip.uuid,
							actionsByClip = this._actionsByClip,
							actionsForClip = actionsByClip[clipUuid];

						if (actionsForClip !== undefined) {
							// note: just calling _removeInactiveAction would mess up the
							// iteration state and also require updating the state we can
							// just throw away

							const actionsToRemove = actionsForClip.knownActions;

							for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
								const action = actionsToRemove[i];

								this._deactivateAction(action);

								const cacheIndex = action._cacheIndex,
									lastInactiveAction = actions[actions.length - 1];

								action._cacheIndex = null;
								action._byClipCacheIndex = null;

								lastInactiveAction._cacheIndex = cacheIndex;
								actions[cacheIndex] = lastInactiveAction;
								actions.pop();

								this._removeInactiveBindingsForAction(action);
							}

							delete actionsByClip[clipUuid];
						}
					}

					// free all resources specific to a particular root target object
					uncacheRoot(root) {
						const rootUuid = root.uuid,
							actionsByClip = this._actionsByClip;

						for (const clipUuid in actionsByClip) {
							const actionByRoot = actionsByClip[clipUuid].actionByRoot,
								action = actionByRoot[rootUuid];

							if (action !== undefined) {
								this._deactivateAction(action);
								this._removeInactiveAction(action);
							}
						}

						const bindingsByRoot = this._bindingsByRootAndName,
							bindingByName = bindingsByRoot[rootUuid];

						if (bindingByName !== undefined) {
							for (const trackName in bindingByName) {
								const binding = bindingByName[trackName];
								binding.restoreOriginalState();
								this._removeInactiveBinding(binding);
							}
						}
					}

					// remove a targeted clip from the cache
					uncacheAction(clip, optionalRoot) {
						const action = this.existingAction(clip, optionalRoot);

						if (action !== null) {
							this._deactivateAction(action);
							this._removeInactiveAction(action);
						}
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/AnimationUtils.js":
			/*!*************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/AnimationUtils.js ***!
  \*************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					convertArray: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.convertArray"] */ convertArray,
					flattenJSON: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.flattenJSON"] */ flattenJSON,
					getKeyframeOrder: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.getKeyframeOrder"] */ getKeyframeOrder,
					isTypedArray: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.isTypedArray"] */ isTypedArray,
					sortedArray: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.sortedArray"] */ sortedArray
				});

				// converts an array to a specific type
				function convertArray(array, type, forceClone) {
					if (
						!array || // let 'undefined' and 'null' pass
						(!forceClone && array.constructor === type)
					)
						return array;

					if (typeof type.BYTES_PER_ELEMENT === "number") {
						return new type(array); // create typed array
					}

					return Array.prototype.slice.call(array); // create Array
				}

				function isTypedArray(object) {
					return ArrayBuffer.isView(object) && !(object instanceof DataView);
				}

				// returns an array by which times and values can be sorted
				function getKeyframeOrder(times) {
					function compareTime(i, j) {
						return times[i] - times[j];
					}

					const n = times.length;
					const result = new Array(n);
					for (let i = 0; i !== n; ++i) result[i] = i;

					result.sort(compareTime);

					return result;
				}

				// uses the array previously returned by 'getKeyframeOrder' to sort data
				function sortedArray(values, stride, order) {
					const nValues = values.length;
					const result = new values.constructor(nValues);

					for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
						const srcOffset = order[i] * stride;

						for (let j = 0; j !== stride; ++j) {
							result[dstOffset++] = values[srcOffset + j];
						}
					}

					return result;
				}

				// function for parsing AOS keyframe formats
				function flattenJSON(jsonKeys, times, values, valuePropertyName) {
					let i = 1,
						key = jsonKeys[0];

					while (key !== undefined && key[valuePropertyName] === undefined) {
						key = jsonKeys[i++];
					}

					if (key === undefined) return; // no data

					let value = key[valuePropertyName];
					if (value === undefined) return; // no data

					if (Array.isArray(value)) {
						do {
							value = key[valuePropertyName];

							if (value !== undefined) {
								times.push(key.time);
								values.push.apply(values, value); // push all elements
							}

							key = jsonKeys[i++];
						} while (key !== undefined);
					} else if (value.toArray !== undefined) {
						// ...assume THREE.Math-ish

						do {
							value = key[valuePropertyName];

							if (value !== undefined) {
								times.push(key.time);
								value.toArray(values, values.length);
							}

							key = jsonKeys[i++];
						} while (key !== undefined);
					} else {
						// otherwise push as-is

						do {
							value = key[valuePropertyName];

							if (value !== undefined) {
								times.push(key.time);
								values.push(value);
							}

							key = jsonKeys[i++];
						} while (key !== undefined);
					}
				}

				function subclip(sourceClip, name, startFrame, endFrame, fps = 30) {
					const clip = sourceClip.clone();

					clip.name = name;

					const tracks = [];

					for (let i = 0; i < clip.tracks.length; ++i) {
						const track = clip.tracks[i];
						const valueSize = track.getValueSize();

						const times = [];
						const values = [];

						for (let j = 0; j < track.times.length; ++j) {
							const frame = track.times[j] * fps;

							if (frame < startFrame || frame >= endFrame) continue;

							times.push(track.times[j]);

							for (let k = 0; k < valueSize; ++k) {
								values.push(track.values[j * valueSize + k]);
							}
						}

						if (times.length === 0) continue;

						track.times = convertArray(times, track.times.constructor);
						track.values = convertArray(values, track.values.constructor);

						tracks.push(track);
					}

					clip.tracks = tracks;

					// find minimum .times value across all tracks in the trimmed clip

					let minStartTime = Infinity;

					for (let i = 0; i < clip.tracks.length; ++i) {
						if (minStartTime > clip.tracks[i].times[0]) {
							minStartTime = clip.tracks[i].times[0];
						}
					}

					// shift all tracks such that clip begins at t=0

					for (let i = 0; i < clip.tracks.length; ++i) {
						clip.tracks[i].shift(-1 * minStartTime);
					}

					clip.resetDuration();

					return clip;
				}

				function makeClipAdditive(
					targetClip,
					referenceFrame = 0,
					referenceClip = targetClip,
					fps = 30
				) {
					if (fps <= 0) fps = 30;

					const numTracks = referenceClip.tracks.length;
					const referenceTime = referenceFrame / fps;

					// Make each track's values relative to the values at the reference frame
					for (let i = 0; i < numTracks; ++i) {
						const referenceTrack = referenceClip.tracks[i];
						const referenceTrackType = referenceTrack.ValueTypeName;

						// Skip this track if it's non-numeric
						if (
							referenceTrackType === "bool" ||
							referenceTrackType === "string"
						)
							continue;

						// Find the track in the target clip whose name and type matches the reference track
						const targetTrack = targetClip.tracks.find(function (track) {
							return (
								track.name === referenceTrack.name &&
								track.ValueTypeName === referenceTrackType
							);
						});

						if (targetTrack === undefined) continue;

						let referenceOffset = 0;
						const referenceValueSize = referenceTrack.getValueSize();

						if (
							referenceTrack.createInterpolant
								.isInterpolantFactoryMethodGLTFCubicSpline
						) {
							referenceOffset = referenceValueSize / 3;
						}

						let targetOffset = 0;
						const targetValueSize = targetTrack.getValueSize();

						if (
							targetTrack.createInterpolant
								.isInterpolantFactoryMethodGLTFCubicSpline
						) {
							targetOffset = targetValueSize / 3;
						}

						const lastIndex = referenceTrack.times.length - 1;
						let referenceValue;

						// Find the value to subtract out of the track
						if (referenceTime <= referenceTrack.times[0]) {
							// Reference frame is earlier than the first keyframe, so just use the first keyframe
							const startIndex = referenceOffset;
							const endIndex = referenceValueSize - referenceOffset;
							referenceValue = referenceTrack.values.slice(
								startIndex,
								endIndex
							);
						} else if (referenceTime >= referenceTrack.times[lastIndex]) {
							// Reference frame is after the last keyframe, so just use the last keyframe
							const startIndex =
								lastIndex * referenceValueSize + referenceOffset;
							const endIndex =
								startIndex + referenceValueSize - referenceOffset;
							referenceValue = referenceTrack.values.slice(
								startIndex,
								endIndex
							);
						} else {
							// Interpolate to the reference value
							const interpolant = referenceTrack.createInterpolant();
							const startIndex = referenceOffset;
							const endIndex = referenceValueSize - referenceOffset;
							interpolant.evaluate(referenceTime);
							referenceValue = interpolant.resultBuffer.slice(
								startIndex,
								endIndex
							);
						}

						// Conjugate the quaternion
						if (referenceTrackType === "quaternion") {
							const referenceQuat = new Quaternion()
								.fromArray(referenceValue)
								.normalize()
								.conjugate();
							referenceQuat.toArray(referenceValue);
						}

						// Subtract the reference value from all of the track values

						const numTimes = targetTrack.times.length;
						for (let j = 0; j < numTimes; ++j) {
							const valueStart = j * targetValueSize + targetOffset;

							if (referenceTrackType === "quaternion") {
								// Multiply the conjugate for quaternion track types
								Quaternion.multiplyQuaternionsFlat(
									targetTrack.values,
									valueStart,
									referenceValue,
									0,
									targetTrack.values,
									valueStart
								);
							} else {
								const valueEnd = targetValueSize - targetOffset * 2;

								// Subtract each value for all other numeric track types
								for (let k = 0; k < valueEnd; ++k) {
									targetTrack.values[valueStart + k] -= referenceValue[k];
								}
							}
						}
					}

					targetClip.blendMode = AdditiveAnimationBlendMode;

					return targetClip;
				}

				const AnimationUtils = /* unused pure expression or super */ null && {
					convertArray: convertArray,
					isTypedArray: isTypedArray,
					getKeyframeOrder: getKeyframeOrder,
					sortedArray: sortedArray,
					flattenJSON: flattenJSON,
					subclip: subclip,
					makeClipAdditive: makeClipAdditive
				};
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/KeyframeTrack.js":
			/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/KeyframeTrack.js ***!
  \************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					KeyframeTrack: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.KeyframeTrack"] */ KeyframeTrack
				});
				/* ESM import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../constants.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js"
					);
				/* ESM import */ var _math_interpolants_CubicInterpolant_js__WEBPACK_IMPORTED_MODULE_3__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/interpolants/CubicInterpolant.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/interpolants/CubicInterpolant.js"
					);
				/* ESM import */ var _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/interpolants/LinearInterpolant.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/interpolants/LinearInterpolant.js"
					);
				/* ESM import */ var _math_interpolants_DiscreteInterpolant_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/interpolants/DiscreteInterpolant.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/interpolants/DiscreteInterpolant.js"
					);
				/* ESM import */ var _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./AnimationUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/AnimationUtils.js"
					);

				class KeyframeTrack {
					constructor(name, times, values, interpolation) {
						if (name === undefined)
							throw new Error("THREE.KeyframeTrack: track name is undefined");
						if (times === undefined || times.length === 0)
							throw new Error(
								"THREE.KeyframeTrack: no keyframes in track named " + name
							);

						this.name = name;

						this.times =
							_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__.convertArray(
								times,
								this.TimeBufferType
							);
						this.values =
							_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__.convertArray(
								values,
								this.ValueBufferType
							);

						this.setInterpolation(interpolation || this.DefaultInterpolation);
					}

					// Serialization (in static context, because of constructor invocation
					// and automatic invocation of .toJSON):

					static toJSON(track) {
						const trackType = track.constructor;

						let json;

						// derived classes can define a static toJSON method
						if (trackType.toJSON !== this.toJSON) {
							json = trackType.toJSON(track);
						} else {
							// by default, we assume the data can be serialized as-is
							json = {
								name: track.name,
								times:
									_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__.convertArray(
										track.times,
										Array
									),
								values:
									_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__.convertArray(
										track.values,
										Array
									)
							};

							const interpolation = track.getInterpolation();

							if (interpolation !== track.DefaultInterpolation) {
								json.interpolation = interpolation;
							}
						}

						json.type = track.ValueTypeName; // mandatory

						return json;
					}

					InterpolantFactoryMethodDiscrete(result) {
						return new _math_interpolants_DiscreteInterpolant_js__WEBPACK_IMPORTED_MODULE_1__.DiscreteInterpolant(
							this.times,
							this.values,
							this.getValueSize(),
							result
						);
					}

					InterpolantFactoryMethodLinear(result) {
						return new _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__.LinearInterpolant(
							this.times,
							this.values,
							this.getValueSize(),
							result
						);
					}

					InterpolantFactoryMethodSmooth(result) {
						return new _math_interpolants_CubicInterpolant_js__WEBPACK_IMPORTED_MODULE_3__.CubicInterpolant(
							this.times,
							this.values,
							this.getValueSize(),
							result
						);
					}

					setInterpolation(interpolation) {
						let factoryMethod;

						switch (interpolation) {
							case _constants_js__WEBPACK_IMPORTED_MODULE_4__.InterpolateDiscrete:
								factoryMethod = this.InterpolantFactoryMethodDiscrete;

								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_4__.InterpolateLinear:
								factoryMethod = this.InterpolantFactoryMethodLinear;

								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_4__.InterpolateSmooth:
								factoryMethod = this.InterpolantFactoryMethodSmooth;

								break;
						}

						if (factoryMethod === undefined) {
							const message =
								"unsupported interpolation for " +
								this.ValueTypeName +
								" keyframe track named " +
								this.name;

							if (this.createInterpolant === undefined) {
								// fall back to default, unless the default itself is messed up
								if (interpolation !== this.DefaultInterpolation) {
									this.setInterpolation(this.DefaultInterpolation);
								} else {
									throw new Error(message); // fatal, in this case
								}
							}

							console.warn("THREE.KeyframeTrack:", message);
							return this;
						}

						this.createInterpolant = factoryMethod;

						return this;
					}

					getInterpolation() {
						switch (this.createInterpolant) {
							case this.InterpolantFactoryMethodDiscrete:
								return _constants_js__WEBPACK_IMPORTED_MODULE_4__.InterpolateDiscrete;

							case this.InterpolantFactoryMethodLinear:
								return _constants_js__WEBPACK_IMPORTED_MODULE_4__.InterpolateLinear;

							case this.InterpolantFactoryMethodSmooth:
								return _constants_js__WEBPACK_IMPORTED_MODULE_4__.InterpolateSmooth;
						}
					}

					getValueSize() {
						return this.values.length / this.times.length;
					}

					// move all keyframes either forwards or backwards in time
					shift(timeOffset) {
						if (timeOffset !== 0.0) {
							const times = this.times;

							for (let i = 0, n = times.length; i !== n; ++i) {
								times[i] += timeOffset;
							}
						}

						return this;
					}

					// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
					scale(timeScale) {
						if (timeScale !== 1.0) {
							const times = this.times;

							for (let i = 0, n = times.length; i !== n; ++i) {
								times[i] *= timeScale;
							}
						}

						return this;
					}

					// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
					// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
					trim(startTime, endTime) {
						const times = this.times,
							nKeys = times.length;

						let from = 0,
							to = nKeys - 1;

						while (from !== nKeys && times[from] < startTime) {
							++from;
						}

						while (to !== -1 && times[to] > endTime) {
							--to;
						}

						++to; // inclusive -> exclusive bound

						if (from !== 0 || to !== nKeys) {
							// empty tracks are forbidden, so keep at least one keyframe
							if (from >= to) {
								to = Math.max(to, 1);
								from = to - 1;
							}

							const stride = this.getValueSize();
							this.times = times.slice(from, to);
							this.values = this.values.slice(from * stride, to * stride);
						}

						return this;
					}

					// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
					validate() {
						let valid = true;

						const valueSize = this.getValueSize();
						if (valueSize - Math.floor(valueSize) !== 0) {
							console.error(
								"THREE.KeyframeTrack: Invalid value size in track.",
								this
							);
							valid = false;
						}

						const times = this.times,
							values = this.values,
							nKeys = times.length;

						if (nKeys === 0) {
							console.error("THREE.KeyframeTrack: Track is empty.", this);
							valid = false;
						}

						let prevTime = null;

						for (let i = 0; i !== nKeys; i++) {
							const currTime = times[i];

							if (typeof currTime === "number" && isNaN(currTime)) {
								console.error(
									"THREE.KeyframeTrack: Time is not a valid number.",
									this,
									i,
									currTime
								);
								valid = false;
								break;
							}

							if (prevTime !== null && prevTime > currTime) {
								console.error(
									"THREE.KeyframeTrack: Out of order keys.",
									this,
									i,
									currTime,
									prevTime
								);
								valid = false;
								break;
							}

							prevTime = currTime;
						}

						if (values !== undefined) {
							if (
								_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__.isTypedArray(
									values
								)
							) {
								for (let i = 0, n = values.length; i !== n; ++i) {
									const value = values[i];

									if (isNaN(value)) {
										console.error(
											"THREE.KeyframeTrack: Value is not a valid number.",
											this,
											i,
											value
										);
										valid = false;
										break;
									}
								}
							}
						}

						return valid;
					}

					// removes equivalent sequential keys as common in morph target sequences
					// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
					optimize() {
						// times or values may be shared with other tracks, so overwriting is unsafe
						const times = this.times.slice(),
							values = this.values.slice(),
							stride = this.getValueSize(),
							smoothInterpolation =
								this.getInterpolation() ===
								_constants_js__WEBPACK_IMPORTED_MODULE_4__.InterpolateSmooth,
							lastIndex = times.length - 1;

						let writeIndex = 1;

						for (let i = 1; i < lastIndex; ++i) {
							let keep = false;

							const time = times[i];
							const timeNext = times[i + 1];

							// remove adjacent keyframes scheduled at the same time

							if (time !== timeNext && (i !== 1 || time !== times[0])) {
								if (!smoothInterpolation) {
									// remove unnecessary keyframes same as their neighbors

									const offset = i * stride,
										offsetP = offset - stride,
										offsetN = offset + stride;

									for (let j = 0; j !== stride; ++j) {
										const value = values[offset + j];

										if (
											value !== values[offsetP + j] ||
											value !== values[offsetN + j]
										) {
											keep = true;
											break;
										}
									}
								} else {
									keep = true;
								}
							}

							// in-place compaction

							if (keep) {
								if (i !== writeIndex) {
									times[writeIndex] = times[i];

									const readOffset = i * stride,
										writeOffset = writeIndex * stride;

									for (let j = 0; j !== stride; ++j) {
										values[writeOffset + j] = values[readOffset + j];
									}
								}

								++writeIndex;
							}
						}

						// flush last keyframe (compaction looks ahead)

						if (lastIndex > 0) {
							times[writeIndex] = times[lastIndex];

							for (
								let readOffset = lastIndex * stride,
									writeOffset = writeIndex * stride,
									j = 0;
								j !== stride;
								++j
							) {
								values[writeOffset + j] = values[readOffset + j];
							}

							++writeIndex;
						}

						if (writeIndex !== times.length) {
							this.times = times.slice(0, writeIndex);
							this.values = values.slice(0, writeIndex * stride);
						} else {
							this.times = times;
							this.values = values;
						}

						return this;
					}

					clone() {
						const times = this.times.slice();
						const values = this.values.slice();

						const TypedKeyframeTrack = this.constructor;
						const track = new TypedKeyframeTrack(this.name, times, values);

						// Interpolant argument to constructor is not saved, so copy the factory method directly.
						track.createInterpolant = this.createInterpolant;

						return track;
					}
				}

				KeyframeTrack.prototype.TimeBufferType = Float32Array;
				KeyframeTrack.prototype.ValueBufferType = Float32Array;
				KeyframeTrack.prototype.DefaultInterpolation =
					_constants_js__WEBPACK_IMPORTED_MODULE_4__.InterpolateLinear;
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/PropertyBinding.js":
			/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/PropertyBinding.js ***!
  \**************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					PropertyBinding: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.PropertyBinding"] */ PropertyBinding
				});
				// Characters [].:/ are reserved for track binding syntax.
				const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
				const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");

				// Attempts to allow node names from any language. ES5's `\w` regexp matches
				// only latin characters, and the unicode \p{L} is not yet supported. So
				// instead, we exclude reserved characters and match everything else.
				const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
				const _wordCharOrDot =
					"[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";

				// Parent directories, delimited by '/' or ':'. Currently unused, but must
				// be matched to parse the rest of the track name.
				const _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace(
					"WC",
					_wordChar
				);

				// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
				const _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace(
					"WCOD",
					_wordCharOrDot
				);

				// Object on target node, and accessor. May not contain reserved
				// characters. Accessor may contain any character except closing bracket.
				const _objectRe =
					/*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace(
						"WC",
						_wordChar
					);

				// Property and accessor. May not contain reserved characters. Accessor may
				// contain any non-bracket characters.
				const _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace(
					"WC",
					_wordChar
				);

				const _trackRe = new RegExp(
					"" + "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
				);

				const _supportedObjectNames = ["material", "materials", "bones", "map"];

				class Composite {
					constructor(targetGroup, path, optionalParsedPath) {
						const parsedPath =
							optionalParsedPath || PropertyBinding.parseTrackName(path);

						this._targetGroup = targetGroup;
						this._bindings = targetGroup.subscribe_(path, parsedPath);
					}

					getValue(array, offset) {
						this.bind(); // bind all binding

						const firstValidIndex = this._targetGroup.nCachedObjects_,
							binding = this._bindings[firstValidIndex];

						// and only call .getValue on the first
						if (binding !== undefined) binding.getValue(array, offset);
					}

					setValue(array, offset) {
						const bindings = this._bindings;

						for (
							let i = this._targetGroup.nCachedObjects_, n = bindings.length;
							i !== n;
							++i
						) {
							bindings[i].setValue(array, offset);
						}
					}

					bind() {
						const bindings = this._bindings;

						for (
							let i = this._targetGroup.nCachedObjects_, n = bindings.length;
							i !== n;
							++i
						) {
							bindings[i].bind();
						}
					}

					unbind() {
						const bindings = this._bindings;

						for (
							let i = this._targetGroup.nCachedObjects_, n = bindings.length;
							i !== n;
							++i
						) {
							bindings[i].unbind();
						}
					}
				}

				// Note: This class uses a State pattern on a per-method basis:
				// 'bind' sets 'this.getValue' / 'setValue' and shadows the
				// prototype version of these methods with one that represents
				// the bound state. When the property is not found, the methods
				// become no-ops.
				class PropertyBinding {
					constructor(rootNode, path, parsedPath) {
						this.path = path;
						this.parsedPath =
							parsedPath || PropertyBinding.parseTrackName(path);

						this.node = PropertyBinding.findNode(
							rootNode,
							this.parsedPath.nodeName
						);

						this.rootNode = rootNode;

						// initial state of these methods that calls 'bind'
						this.getValue = this._getValue_unbound;
						this.setValue = this._setValue_unbound;
					}

					static create(root, path, parsedPath) {
						if (!(root && root.isAnimationObjectGroup)) {
							return new PropertyBinding(root, path, parsedPath);
						} else {
							return new PropertyBinding.Composite(root, path, parsedPath);
						}
					}

					/**
					 * Replaces spaces with underscores and removes unsupported characters from
					 * node names, to ensure compatibility with parseTrackName().
					 *
					 * @param {string} name Node name to be sanitized.
					 * @return {string}
					 */
					static sanitizeNodeName(name) {
						return name.replace(/\s/g, "_").replace(_reservedRe, "");
					}

					static parseTrackName(trackName) {
						const matches = _trackRe.exec(trackName);

						if (matches === null) {
							throw new Error(
								"PropertyBinding: Cannot parse trackName: " + trackName
							);
						}

						const results = {
							// directoryName: matches[ 1 ], // (tschw) currently unused
							nodeName: matches[2],
							objectName: matches[3],
							objectIndex: matches[4],
							propertyName: matches[5], // required
							propertyIndex: matches[6]
						};

						const lastDot =
							results.nodeName && results.nodeName.lastIndexOf(".");

						if (lastDot !== undefined && lastDot !== -1) {
							const objectName = results.nodeName.substring(lastDot + 1);

							// Object names must be checked against an allowlist. Otherwise, there
							// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
							// 'bar' could be the objectName, or part of a nodeName (which can
							// include '.' characters).
							if (_supportedObjectNames.indexOf(objectName) !== -1) {
								results.nodeName = results.nodeName.substring(0, lastDot);
								results.objectName = objectName;
							}
						}

						if (
							results.propertyName === null ||
							results.propertyName.length === 0
						) {
							throw new Error(
								"PropertyBinding: can not parse propertyName from trackName: " +
									trackName
							);
						}

						return results;
					}

					static findNode(root, nodeName) {
						if (
							nodeName === undefined ||
							nodeName === "" ||
							nodeName === "." ||
							nodeName === -1 ||
							nodeName === root.name ||
							nodeName === root.uuid
						) {
							return root;
						}

						// search into skeleton bones.
						if (root.skeleton) {
							const bone = root.skeleton.getBoneByName(nodeName);

							if (bone !== undefined) {
								return bone;
							}
						}

						// search into node subtree.
						if (root.children) {
							const searchNodeSubtree = function (children) {
								for (let i = 0; i < children.length; i++) {
									const childNode = children[i];

									if (
										childNode.name === nodeName ||
										childNode.uuid === nodeName
									) {
										return childNode;
									}

									const result = searchNodeSubtree(childNode.children);

									if (result) return result;
								}

								return null;
							};

							const subTreeNode = searchNodeSubtree(root.children);

							if (subTreeNode) {
								return subTreeNode;
							}
						}

						return null;
					}

					// these are used to "bind" a nonexistent property
					_getValue_unavailable() {}
					_setValue_unavailable() {}

					// Getters

					_getValue_direct(buffer, offset) {
						buffer[offset] = this.targetObject[this.propertyName];
					}

					_getValue_array(buffer, offset) {
						const source = this.resolvedProperty;

						for (let i = 0, n = source.length; i !== n; ++i) {
							buffer[offset++] = source[i];
						}
					}

					_getValue_arrayElement(buffer, offset) {
						buffer[offset] = this.resolvedProperty[this.propertyIndex];
					}

					_getValue_toArray(buffer, offset) {
						this.resolvedProperty.toArray(buffer, offset);
					}

					// Direct

					_setValue_direct(buffer, offset) {
						this.targetObject[this.propertyName] = buffer[offset];
					}

					_setValue_direct_setNeedsUpdate(buffer, offset) {
						this.targetObject[this.propertyName] = buffer[offset];
						this.targetObject.needsUpdate = true;
					}

					_setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
						this.targetObject[this.propertyName] = buffer[offset];
						this.targetObject.matrixWorldNeedsUpdate = true;
					}

					// EntireArray

					_setValue_array(buffer, offset) {
						const dest = this.resolvedProperty;

						for (let i = 0, n = dest.length; i !== n; ++i) {
							dest[i] = buffer[offset++];
						}
					}

					_setValue_array_setNeedsUpdate(buffer, offset) {
						const dest = this.resolvedProperty;

						for (let i = 0, n = dest.length; i !== n; ++i) {
							dest[i] = buffer[offset++];
						}

						this.targetObject.needsUpdate = true;
					}

					_setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
						const dest = this.resolvedProperty;

						for (let i = 0, n = dest.length; i !== n; ++i) {
							dest[i] = buffer[offset++];
						}

						this.targetObject.matrixWorldNeedsUpdate = true;
					}

					// ArrayElement

					_setValue_arrayElement(buffer, offset) {
						this.resolvedProperty[this.propertyIndex] = buffer[offset];
					}

					_setValue_arrayElement_setNeedsUpdate(buffer, offset) {
						this.resolvedProperty[this.propertyIndex] = buffer[offset];
						this.targetObject.needsUpdate = true;
					}

					_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
						this.resolvedProperty[this.propertyIndex] = buffer[offset];
						this.targetObject.matrixWorldNeedsUpdate = true;
					}

					// HasToFromArray

					_setValue_fromArray(buffer, offset) {
						this.resolvedProperty.fromArray(buffer, offset);
					}

					_setValue_fromArray_setNeedsUpdate(buffer, offset) {
						this.resolvedProperty.fromArray(buffer, offset);
						this.targetObject.needsUpdate = true;
					}

					_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
						this.resolvedProperty.fromArray(buffer, offset);
						this.targetObject.matrixWorldNeedsUpdate = true;
					}

					_getValue_unbound(targetArray, offset) {
						this.bind();
						this.getValue(targetArray, offset);
					}

					_setValue_unbound(sourceArray, offset) {
						this.bind();
						this.setValue(sourceArray, offset);
					}

					// create getter / setter pair for a property in the scene graph
					bind() {
						let targetObject = this.node;
						const parsedPath = this.parsedPath;

						const objectName = parsedPath.objectName;
						const propertyName = parsedPath.propertyName;
						let propertyIndex = parsedPath.propertyIndex;

						if (!targetObject) {
							targetObject = PropertyBinding.findNode(
								this.rootNode,
								parsedPath.nodeName
							);

							this.node = targetObject;
						}

						// set fail state so we can just 'return' on error
						this.getValue = this._getValue_unavailable;
						this.setValue = this._setValue_unavailable;

						// ensure there is a value node
						if (!targetObject) {
							console.warn(
								"THREE.PropertyBinding: No target node found for track: " +
									this.path +
									"."
							);
							return;
						}

						if (objectName) {
							let objectIndex = parsedPath.objectIndex;

							// special cases were we need to reach deeper into the hierarchy to get the face materials....
							switch (objectName) {
								case "materials":
									if (!targetObject.material) {
										console.error(
											"THREE.PropertyBinding: Can not bind to material as node does not have a material.",
											this
										);
										return;
									}

									if (!targetObject.material.materials) {
										console.error(
											"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
											this
										);
										return;
									}

									targetObject = targetObject.material.materials;

									break;

								case "bones":
									if (!targetObject.skeleton) {
										console.error(
											"THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
											this
										);
										return;
									}

									// potential future optimization: skip this if propertyIndex is already an integer
									// and convert the integer string to a true integer.

									targetObject = targetObject.skeleton.bones;

									// support resolving morphTarget names into indices.
									for (let i = 0; i < targetObject.length; i++) {
										if (targetObject[i].name === objectIndex) {
											objectIndex = i;
											break;
										}
									}

									break;

								case "map":
									if ("map" in targetObject) {
										targetObject = targetObject.map;
										break;
									}

									if (!targetObject.material) {
										console.error(
											"THREE.PropertyBinding: Can not bind to material as node does not have a material.",
											this
										);
										return;
									}

									if (!targetObject.material.map) {
										console.error(
											"THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
											this
										);
										return;
									}

									targetObject = targetObject.material.map;
									break;

								default:
									if (targetObject[objectName] === undefined) {
										console.error(
											"THREE.PropertyBinding: Can not bind to objectName of node undefined.",
											this
										);
										return;
									}

									targetObject = targetObject[objectName];
							}

							if (objectIndex !== undefined) {
								if (targetObject[objectIndex] === undefined) {
									console.error(
										"THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
										this,
										targetObject
									);
									return;
								}

								targetObject = targetObject[objectIndex];
							}
						}

						// resolve property
						const nodeProperty = targetObject[propertyName];

						if (nodeProperty === undefined) {
							const nodeName = parsedPath.nodeName;

							console.error(
								"THREE.PropertyBinding: Trying to update property for track: " +
									nodeName +
									"." +
									propertyName +
									" but it wasn't found.",
								targetObject
							);
							return;
						}

						// determine versioning scheme
						let versioning = this.Versioning.None;

						this.targetObject = targetObject;

						if (targetObject.needsUpdate !== undefined) {
							// material

							versioning = this.Versioning.NeedsUpdate;
						} else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
							// node transform

							versioning = this.Versioning.MatrixWorldNeedsUpdate;
						}

						// determine how the property gets bound
						let bindingType = this.BindingType.Direct;

						if (propertyIndex !== undefined) {
							// access a sub element of the property array (only primitives are supported right now)

							if (propertyName === "morphTargetInfluences") {
								// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

								// support resolving morphTarget names into indices.
								if (!targetObject.geometry) {
									console.error(
										"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
										this
									);
									return;
								}

								if (!targetObject.geometry.morphAttributes) {
									console.error(
										"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
										this
									);
									return;
								}

								if (
									targetObject.morphTargetDictionary[propertyIndex] !==
									undefined
								) {
									propertyIndex =
										targetObject.morphTargetDictionary[propertyIndex];
								}
							}

							bindingType = this.BindingType.ArrayElement;

							this.resolvedProperty = nodeProperty;
							this.propertyIndex = propertyIndex;
						} else if (
							nodeProperty.fromArray !== undefined &&
							nodeProperty.toArray !== undefined
						) {
							// must use copy for Object3D.Euler/Quaternion

							bindingType = this.BindingType.HasFromToArray;

							this.resolvedProperty = nodeProperty;
						} else if (Array.isArray(nodeProperty)) {
							bindingType = this.BindingType.EntireArray;

							this.resolvedProperty = nodeProperty;
						} else {
							this.propertyName = propertyName;
						}

						// select getter / setter
						this.getValue = this.GetterByBindingType[bindingType];
						this.setValue =
							this.SetterByBindingTypeAndVersioning[bindingType][versioning];
					}

					unbind() {
						this.node = null;

						// back to the prototype version of getValue / setValue
						// note: avoiding to mutate the shape of 'this' via 'delete'
						this.getValue = this._getValue_unbound;
						this.setValue = this._setValue_unbound;
					}
				}

				PropertyBinding.Composite = Composite;

				PropertyBinding.prototype.BindingType = {
					Direct: 0,
					EntireArray: 1,
					ArrayElement: 2,
					HasFromToArray: 3
				};

				PropertyBinding.prototype.Versioning = {
					None: 0,
					NeedsUpdate: 1,
					MatrixWorldNeedsUpdate: 2
				};

				PropertyBinding.prototype.GetterByBindingType = [
					PropertyBinding.prototype._getValue_direct,
					PropertyBinding.prototype._getValue_array,
					PropertyBinding.prototype._getValue_arrayElement,
					PropertyBinding.prototype._getValue_toArray
				];

				PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
					[
						// Direct
						PropertyBinding.prototype._setValue_direct,
						PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
						PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
					],
					[
						// EntireArray

						PropertyBinding.prototype._setValue_array,
						PropertyBinding.prototype._setValue_array_setNeedsUpdate,
						PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
					],
					[
						// ArrayElement
						PropertyBinding.prototype._setValue_arrayElement,
						PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
						PropertyBinding.prototype
							._setValue_arrayElement_setMatrixWorldNeedsUpdate
					],
					[
						// HasToFromArray
						PropertyBinding.prototype._setValue_fromArray,
						PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
						PropertyBinding.prototype
							._setValue_fromArray_setMatrixWorldNeedsUpdate
					]
				];
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/PropertyMixer.js":
			/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/PropertyMixer.js ***!
  \************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					PropertyMixer: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.PropertyMixer"] */ PropertyMixer
				});
				/* ESM import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Quaternion.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Quaternion.js"
					);

				class PropertyMixer {
					constructor(binding, typeName, valueSize) {
						this.binding = binding;
						this.valueSize = valueSize;

						let mixFunction, mixFunctionAdditive, setIdentity;

						// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
						//
						// interpolators can use .buffer as their .result
						// the data then goes to 'incoming'
						//
						// 'accu0' and 'accu1' are used frame-interleaved for
						// the cumulative result and are compared to detect
						// changes
						//
						// 'orig' stores the original state of the property
						//
						// 'add' is used for additive cumulative results
						//
						// 'work' is optional and is only present for quaternion types. It is used
						// to store intermediate quaternion multiplication results

						switch (typeName) {
							case "quaternion":
								mixFunction = this._slerp;
								mixFunctionAdditive = this._slerpAdditive;
								setIdentity = this._setAdditiveIdentityQuaternion;

								this.buffer = new Float64Array(valueSize * 6);
								this._workIndex = 5;
								break;

							case "string":
							case "bool":
								mixFunction = this._select;

								// Use the regular mix function and for additive on these types,
								// additive is not relevant for non-numeric types
								mixFunctionAdditive = this._select;

								setIdentity = this._setAdditiveIdentityOther;

								this.buffer = new Array(valueSize * 5);
								break;

							default:
								mixFunction = this._lerp;
								mixFunctionAdditive = this._lerpAdditive;
								setIdentity = this._setAdditiveIdentityNumeric;

								this.buffer = new Float64Array(valueSize * 5);
						}

						this._mixBufferRegion = mixFunction;
						this._mixBufferRegionAdditive = mixFunctionAdditive;
						this._setIdentity = setIdentity;
						this._origIndex = 3;
						this._addIndex = 4;

						this.cumulativeWeight = 0;
						this.cumulativeWeightAdditive = 0;

						this.useCount = 0;
						this.referenceCount = 0;
					}

					// accumulate data in the 'incoming' region into 'accu<i>'
					accumulate(accuIndex, weight) {
						// note: happily accumulating nothing when weight = 0, the caller knows
						// the weight and shouldn't have made the call in the first place

						const buffer = this.buffer,
							stride = this.valueSize,
							offset = accuIndex * stride + stride;

						let currentWeight = this.cumulativeWeight;

						if (currentWeight === 0) {
							// accuN := incoming * weight

							for (let i = 0; i !== stride; ++i) {
								buffer[offset + i] = buffer[i];
							}

							currentWeight = weight;
						} else {
							// accuN := accuN + incoming * weight

							currentWeight += weight;
							const mix = weight / currentWeight;
							this._mixBufferRegion(buffer, offset, 0, mix, stride);
						}

						this.cumulativeWeight = currentWeight;
					}

					// accumulate data in the 'incoming' region into 'add'
					accumulateAdditive(weight) {
						const buffer = this.buffer,
							stride = this.valueSize,
							offset = stride * this._addIndex;

						if (this.cumulativeWeightAdditive === 0) {
							// add = identity

							this._setIdentity();
						}

						// add := add + incoming * weight

						this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
						this.cumulativeWeightAdditive += weight;
					}

					// apply the state of 'accu<i>' to the binding when accus differ
					apply(accuIndex) {
						const stride = this.valueSize,
							buffer = this.buffer,
							offset = accuIndex * stride + stride,
							weight = this.cumulativeWeight,
							weightAdditive = this.cumulativeWeightAdditive,
							binding = this.binding;

						this.cumulativeWeight = 0;
						this.cumulativeWeightAdditive = 0;

						if (weight < 1) {
							// accuN := accuN + original * ( 1 - cumulativeWeight )

							const originalValueOffset = stride * this._origIndex;

							this._mixBufferRegion(
								buffer,
								offset,
								originalValueOffset,
								1 - weight,
								stride
							);
						}

						if (weightAdditive > 0) {
							// accuN := accuN + additive accuN

							this._mixBufferRegionAdditive(
								buffer,
								offset,
								this._addIndex * stride,
								1,
								stride
							);
						}

						for (let i = stride, e = stride + stride; i !== e; ++i) {
							if (buffer[i] !== buffer[i + stride]) {
								// value has changed -> update scene graph

								binding.setValue(buffer, offset);
								break;
							}
						}
					}

					// remember the state of the bound property and copy it to both accus
					saveOriginalState() {
						const binding = this.binding;

						const buffer = this.buffer,
							stride = this.valueSize,
							originalValueOffset = stride * this._origIndex;

						binding.getValue(buffer, originalValueOffset);

						// accu[0..1] := orig -- initially detect changes against the original
						for (let i = stride, e = originalValueOffset; i !== e; ++i) {
							buffer[i] = buffer[originalValueOffset + (i % stride)];
						}

						// Add to identity for additive
						this._setIdentity();

						this.cumulativeWeight = 0;
						this.cumulativeWeightAdditive = 0;
					}

					// apply the state previously taken via 'saveOriginalState' to the binding
					restoreOriginalState() {
						const originalValueOffset = this.valueSize * 3;
						this.binding.setValue(this.buffer, originalValueOffset);
					}

					_setAdditiveIdentityNumeric() {
						const startIndex = this._addIndex * this.valueSize;
						const endIndex = startIndex + this.valueSize;

						for (let i = startIndex; i < endIndex; i++) {
							this.buffer[i] = 0;
						}
					}

					_setAdditiveIdentityQuaternion() {
						this._setAdditiveIdentityNumeric();
						this.buffer[this._addIndex * this.valueSize + 3] = 1;
					}

					_setAdditiveIdentityOther() {
						const startIndex = this._origIndex * this.valueSize;
						const targetIndex = this._addIndex * this.valueSize;

						for (let i = 0; i < this.valueSize; i++) {
							this.buffer[targetIndex + i] = this.buffer[startIndex + i];
						}
					}

					// mix functions

					_select(buffer, dstOffset, srcOffset, t, stride) {
						if (t >= 0.5) {
							for (let i = 0; i !== stride; ++i) {
								buffer[dstOffset + i] = buffer[srcOffset + i];
							}
						}
					}

					_slerp(buffer, dstOffset, srcOffset, t) {
						_math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.slerpFlat(
							buffer,
							dstOffset,
							buffer,
							dstOffset,
							buffer,
							srcOffset,
							t
						);
					}

					_slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
						const workOffset = this._workIndex * stride;

						// Store result in intermediate buffer offset
						_math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.multiplyQuaternionsFlat(
							buffer,
							workOffset,
							buffer,
							dstOffset,
							buffer,
							srcOffset
						);

						// Slerp to the intermediate result
						_math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.slerpFlat(
							buffer,
							dstOffset,
							buffer,
							dstOffset,
							buffer,
							workOffset,
							t
						);
					}

					_lerp(buffer, dstOffset, srcOffset, t, stride) {
						const s = 1 - t;

						for (let i = 0; i !== stride; ++i) {
							const j = dstOffset + i;

							buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
						}
					}

					_lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
						for (let i = 0; i !== stride; ++i) {
							const j = dstOffset + i;

							buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
						}
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/BooleanKeyframeTrack.js":
			/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/BooleanKeyframeTrack.js ***!
  \**************************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					BooleanKeyframeTrack: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.BooleanKeyframeTrack"] */ BooleanKeyframeTrack
				});
				/* ESM import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../../constants.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js"
					);
				/* ESM import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../KeyframeTrack.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/KeyframeTrack.js"
					);

				/**
				 * A Track of Boolean keyframe values.
				 */
				class BooleanKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.KeyframeTrack {
					// No interpolation parameter because only InterpolateDiscrete is valid.
					constructor(name, times, values) {
						super(name, times, values);
					}
				}

				BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
				BooleanKeyframeTrack.prototype.ValueBufferType = Array;
				BooleanKeyframeTrack.prototype.DefaultInterpolation =
					_constants_js__WEBPACK_IMPORTED_MODULE_1__.InterpolateDiscrete;
				BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear =
					undefined;
				BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth =
					undefined;

				// Note: Actually this track could have a optimized / compressed
				// representation of a single value and a custom interpolant that
				// computes "firstValue ^ isOdd( index )".
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/ColorKeyframeTrack.js":
			/*!************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/ColorKeyframeTrack.js ***!
  \************************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					ColorKeyframeTrack: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.ColorKeyframeTrack"] */ ColorKeyframeTrack
				});
				/* ESM import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../KeyframeTrack.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/KeyframeTrack.js"
					);

				/**
				 * A Track of keyframe values that represent color.
				 */
				class ColorKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.KeyframeTrack {}

				ColorKeyframeTrack.prototype.ValueTypeName = "color";
				// ValueBufferType is inherited
				// DefaultInterpolation is inherited

				// Note: Very basic implementation and nothing special yet.
				// However, this is the place for color space parameterization.
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/NumberKeyframeTrack.js":
			/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/NumberKeyframeTrack.js ***!
  \*************************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					NumberKeyframeTrack: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.NumberKeyframeTrack"] */ NumberKeyframeTrack
				});
				/* ESM import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../KeyframeTrack.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/KeyframeTrack.js"
					);

				/**
				 * A Track of numeric keyframe values.
				 */
				class NumberKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.KeyframeTrack {}

				NumberKeyframeTrack.prototype.ValueTypeName = "number";
				// ValueBufferType is inherited
				// DefaultInterpolation is inherited
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/QuaternionKeyframeTrack.js":
			/*!*****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/QuaternionKeyframeTrack.js ***!
  \*****************************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					QuaternionKeyframeTrack: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.QuaternionKeyframeTrack"] */ QuaternionKeyframeTrack
				});
				/* ESM import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../KeyframeTrack.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/KeyframeTrack.js"
					);
				/* ESM import */ var _math_interpolants_QuaternionLinearInterpolant_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../../math/interpolants/QuaternionLinearInterpolant.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/interpolants/QuaternionLinearInterpolant.js"
					);

				/**
				 * A Track of quaternion keyframe values.
				 */
				class QuaternionKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.KeyframeTrack {
					InterpolantFactoryMethodLinear(result) {
						return new _math_interpolants_QuaternionLinearInterpolant_js__WEBPACK_IMPORTED_MODULE_1__.QuaternionLinearInterpolant(
							this.times,
							this.values,
							this.getValueSize(),
							result
						);
					}
				}

				QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
				// ValueBufferType is inherited
				// DefaultInterpolation is inherited;
				QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth =
					undefined;
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/StringKeyframeTrack.js":
			/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/StringKeyframeTrack.js ***!
  \*************************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					StringKeyframeTrack: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.StringKeyframeTrack"] */ StringKeyframeTrack
				});
				/* ESM import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../../constants.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js"
					);
				/* ESM import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../KeyframeTrack.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/KeyframeTrack.js"
					);

				/**
				 * A Track that interpolates Strings
				 */
				class StringKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.KeyframeTrack {
					// No interpolation parameter because only InterpolateDiscrete is valid.
					constructor(name, times, values) {
						super(name, times, values);
					}
				}

				StringKeyframeTrack.prototype.ValueTypeName = "string";
				StringKeyframeTrack.prototype.ValueBufferType = Array;
				StringKeyframeTrack.prototype.DefaultInterpolation =
					_constants_js__WEBPACK_IMPORTED_MODULE_1__.InterpolateDiscrete;
				StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear =
					undefined;
				StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth =
					undefined;
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/VectorKeyframeTrack.js":
			/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/tracks/VectorKeyframeTrack.js ***!
  \*************************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					VectorKeyframeTrack: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.VectorKeyframeTrack"] */ VectorKeyframeTrack
				});
				/* ESM import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../KeyframeTrack.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/animation/KeyframeTrack.js"
					);

				/**
				 * A Track of vectored keyframe values.
				 */
				class VectorKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.KeyframeTrack {}

				VectorKeyframeTrack.prototype.ValueTypeName = "vector";
				// ValueBufferType is inherited
				// DefaultInterpolation is inherited
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Interpolant.js":
			/*!*****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Interpolant.js ***!
  \*****************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Interpolant: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.Interpolant"] */ Interpolant
				});
				/**
				 * Abstract base class of interpolants over parametric samples.
				 *
				 * The parameter domain is one dimensional, typically the time or a path
				 * along a curve defined by the data.
				 *
				 * The sample values can have any dimensionality and derived classes may
				 * apply special interpretations to the data.
				 *
				 * This class provides the interval seek in a Template Method, deferring
				 * the actual interpolation to derived classes.
				 *
				 * Time complexity is O(1) for linear access crossing at most two points
				 * and O(log N) for random access, where N is the number of positions.
				 *
				 * References:
				 *
				 * 		http://www.oodesign.com/template-method-pattern.html
				 *
				 */

				class Interpolant {
					constructor(
						parameterPositions,
						sampleValues,
						sampleSize,
						resultBuffer
					) {
						this.parameterPositions = parameterPositions;
						this._cachedIndex = 0;

						this.resultBuffer =
							resultBuffer !== undefined
								? resultBuffer
								: new sampleValues.constructor(sampleSize);
						this.sampleValues = sampleValues;
						this.valueSize = sampleSize;

						this.settings = null;
						this.DefaultSettings_ = {};
					}

					evaluate(t) {
						const pp = this.parameterPositions;
						let i1 = this._cachedIndex,
							t1 = pp[i1],
							t0 = pp[i1 - 1];

						validate_interval: {
							seek: {
								let right;

								linear_scan: {
									//- See http://jsperf.com/comparison-to-undefined/3
									//- slower code:
									//-
									//- 				if ( t >= t1 || t1 === undefined ) {
									forward_scan: if (!(t < t1)) {
										for (let giveUpAt = i1 + 2; ; ) {
											if (t1 === undefined) {
												if (t < t0) break forward_scan;

												// after end

												i1 = pp.length;
												this._cachedIndex = i1;
												return this.copySampleValue_(i1 - 1);
											}

											if (i1 === giveUpAt) break; // this loop

											t0 = t1;
											t1 = pp[++i1];

											if (t < t1) {
												// we have arrived at the sought interval
												break seek;
											}
										}

										// prepare binary search on the right side of the index
										right = pp.length;
										break linear_scan;
									}

									//- slower code:
									//-					if ( t < t0 || t0 === undefined ) {
									if (!(t >= t0)) {
										// looping?

										const t1global = pp[1];

										if (t < t1global) {
											i1 = 2; // + 1, using the scan for the details
											t0 = t1global;
										}

										// linear reverse scan

										for (let giveUpAt = i1 - 2; ; ) {
											if (t0 === undefined) {
												// before start

												this._cachedIndex = 0;
												return this.copySampleValue_(0);
											}

											if (i1 === giveUpAt) break; // this loop

											t1 = t0;
											t0 = pp[--i1 - 1];

											if (t >= t0) {
												// we have arrived at the sought interval
												break seek;
											}
										}

										// prepare binary search on the left side of the index
										right = i1;
										i1 = 0;
										break linear_scan;
									}

									// the interval is valid

									break validate_interval;
								} // linear scan

								// binary search

								while (i1 < right) {
									const mid = (i1 + right) >>> 1;

									if (t < pp[mid]) {
										right = mid;
									} else {
										i1 = mid + 1;
									}
								}

								t1 = pp[i1];
								t0 = pp[i1 - 1];

								// check boundary cases, again

								if (t0 === undefined) {
									this._cachedIndex = 0;
									return this.copySampleValue_(0);
								}

								if (t1 === undefined) {
									i1 = pp.length;
									this._cachedIndex = i1;
									return this.copySampleValue_(i1 - 1);
								}
							} // seek

							this._cachedIndex = i1;

							this.intervalChanged_(i1, t0, t1);
						} // validate_interval

						return this.interpolate_(i1, t0, t, t1);
					}

					getSettings_() {
						return this.settings || this.DefaultSettings_;
					}

					copySampleValue_(index) {
						// copies a sample value to the result buffer

						const result = this.resultBuffer,
							values = this.sampleValues,
							stride = this.valueSize,
							offset = index * stride;

						for (let i = 0; i !== stride; ++i) {
							result[i] = values[offset + i];
						}

						return result;
					}

					// Template methods for derived classes:

					interpolate_(/* i1, t0, t, t1 */) {
						throw new Error("call to abstract method");
						// implementations shall return this.resultBuffer
					}

					intervalChanged_(/* i1, t0, t1 */) {
						// empty
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/interpolants/CubicInterpolant.js":
			/*!***********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/interpolants/CubicInterpolant.js ***!
  \***********************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					CubicInterpolant: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.CubicInterpolant"] */ CubicInterpolant
				});
				/* ESM import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../../constants.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js"
					);
				/* ESM import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../Interpolant.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Interpolant.js"
					);

				/**
				 * Fast and simple cubic spline interpolant.
				 *
				 * It was derived from a Hermitian construction setting the first derivative
				 * at each sample position to the linear slope between neighboring positions
				 * over their parameter interval.
				 */

				class CubicInterpolant extends _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__.Interpolant {
					constructor(
						parameterPositions,
						sampleValues,
						sampleSize,
						resultBuffer
					) {
						super(parameterPositions, sampleValues, sampleSize, resultBuffer);

						this._weightPrev = -0;
						this._offsetPrev = -0;
						this._weightNext = -0;
						this._offsetNext = -0;

						this.DefaultSettings_ = {
							endingStart:
								_constants_js__WEBPACK_IMPORTED_MODULE_1__.ZeroCurvatureEnding,
							endingEnd:
								_constants_js__WEBPACK_IMPORTED_MODULE_1__.ZeroCurvatureEnding
						};
					}

					intervalChanged_(i1, t0, t1) {
						const pp = this.parameterPositions;
						let iPrev = i1 - 2,
							iNext = i1 + 1,
							tPrev = pp[iPrev],
							tNext = pp[iNext];

						if (tPrev === undefined) {
							switch (this.getSettings_().endingStart) {
								case _constants_js__WEBPACK_IMPORTED_MODULE_1__.ZeroSlopeEnding:
									// f'(t0) = 0
									iPrev = i1;
									tPrev = 2 * t0 - t1;

									break;

								case _constants_js__WEBPACK_IMPORTED_MODULE_1__.WrapAroundEnding:
									// use the other end of the curve
									iPrev = pp.length - 2;
									tPrev = t0 + pp[iPrev] - pp[iPrev + 1];

									break;

								default: // ZeroCurvatureEnding
									// f''(t0) = 0 a.k.a. Natural Spline
									iPrev = i1;
									tPrev = t1;
							}
						}

						if (tNext === undefined) {
							switch (this.getSettings_().endingEnd) {
								case _constants_js__WEBPACK_IMPORTED_MODULE_1__.ZeroSlopeEnding:
									// f'(tN) = 0
									iNext = i1;
									tNext = 2 * t1 - t0;

									break;

								case _constants_js__WEBPACK_IMPORTED_MODULE_1__.WrapAroundEnding:
									// use the other end of the curve
									iNext = 1;
									tNext = t1 + pp[1] - pp[0];

									break;

								default: // ZeroCurvatureEnding
									// f''(tN) = 0, a.k.a. Natural Spline
									iNext = i1 - 1;
									tNext = t0;
							}
						}

						const halfDt = (t1 - t0) * 0.5,
							stride = this.valueSize;

						this._weightPrev = halfDt / (t0 - tPrev);
						this._weightNext = halfDt / (tNext - t1);
						this._offsetPrev = iPrev * stride;
						this._offsetNext = iNext * stride;
					}

					interpolate_(i1, t0, t, t1) {
						const result = this.resultBuffer,
							values = this.sampleValues,
							stride = this.valueSize,
							o1 = i1 * stride,
							o0 = o1 - stride,
							oP = this._offsetPrev,
							oN = this._offsetNext,
							wP = this._weightPrev,
							wN = this._weightNext,
							p = (t - t0) / (t1 - t0),
							pp = p * p,
							ppp = pp * p;

						// evaluate polynomials

						const sP = -wP * ppp + 2 * wP * pp - wP * p;
						const s0 =
							(1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
						const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
						const sN = wN * ppp - wN * pp;

						// combine data linearly

						for (let i = 0; i !== stride; ++i) {
							result[i] =
								sP * values[oP + i] +
								s0 * values[o0 + i] +
								s1 * values[o1 + i] +
								sN * values[oN + i];
						}

						return result;
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/interpolants/DiscreteInterpolant.js":
			/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/interpolants/DiscreteInterpolant.js ***!
  \**************************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					DiscreteInterpolant: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.DiscreteInterpolant"] */ DiscreteInterpolant
				});
				/* ESM import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../Interpolant.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Interpolant.js"
					);

				/**
				 *
				 * Interpolant that evaluates to the sample value at the position preceding
				 * the parameter.
				 */

				class DiscreteInterpolant extends _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__.Interpolant {
					constructor(
						parameterPositions,
						sampleValues,
						sampleSize,
						resultBuffer
					) {
						super(parameterPositions, sampleValues, sampleSize, resultBuffer);
					}

					interpolate_(i1 /*, t0, t, t1 */) {
						return this.copySampleValue_(i1 - 1);
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/interpolants/LinearInterpolant.js":
			/*!************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/interpolants/LinearInterpolant.js ***!
  \************************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					LinearInterpolant: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.LinearInterpolant"] */ LinearInterpolant
				});
				/* ESM import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../Interpolant.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Interpolant.js"
					);

				class LinearInterpolant extends _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__.Interpolant {
					constructor(
						parameterPositions,
						sampleValues,
						sampleSize,
						resultBuffer
					) {
						super(parameterPositions, sampleValues, sampleSize, resultBuffer);
					}

					interpolate_(i1, t0, t, t1) {
						const result = this.resultBuffer,
							values = this.sampleValues,
							stride = this.valueSize,
							offset1 = i1 * stride,
							offset0 = offset1 - stride,
							weight1 = (t - t0) / (t1 - t0),
							weight0 = 1 - weight1;

						for (let i = 0; i !== stride; ++i) {
							result[i] =
								values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
						}

						return result;
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/interpolants/QuaternionLinearInterpolant.js":
			/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/interpolants/QuaternionLinearInterpolant.js ***!
  \**********************************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					QuaternionLinearInterpolant: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/animation/AnimationMixer.js.QuaternionLinearInterpolant"] */ QuaternionLinearInterpolant
				});
				/* ESM import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../Interpolant.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Interpolant.js"
					);
				/* ESM import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../Quaternion.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Quaternion.js"
					);

				/**
				 * Spherical linear unit quaternion interpolant.
				 */

				class QuaternionLinearInterpolant extends _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__.Interpolant {
					constructor(
						parameterPositions,
						sampleValues,
						sampleSize,
						resultBuffer
					) {
						super(parameterPositions, sampleValues, sampleSize, resultBuffer);
					}

					interpolate_(i1, t0, t, t1) {
						const result = this.resultBuffer,
							values = this.sampleValues,
							stride = this.valueSize,
							alpha = (t - t0) / (t1 - t0);

						let offset = i1 * stride;

						for (let end = offset + stride; offset !== end; offset += 4) {
							_Quaternion_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion.slerpFlat(
								result,
								0,
								values,
								offset - stride,
								values,
								offset,
								alpha
							);
						}

						return result;
					}
				}
			}
	}
]);
