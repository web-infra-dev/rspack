"use strict";
(self["webpackChunkrspack_basic_example"] =
	self["webpackChunkrspack_basic_example"] || []).push([
	[
		"vendors-node_modules_pnpm_three_0_169_0_node_modules_three_src_objects_LineSegments_js"
	],
	{
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/BufferAttribute.js":
			/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/BufferAttribute.js ***!
  \*********************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					BufferAttribute: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.BufferAttribute"] */ BufferAttribute,
					Float32BufferAttribute: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Float32BufferAttribute"] */ Float32BufferAttribute,
					Uint16BufferAttribute: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Uint16BufferAttribute"] */ Uint16BufferAttribute,
					Uint32BufferAttribute: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Uint32BufferAttribute"] */ Uint32BufferAttribute
				});
				/* ESM import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Vector3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector3.js"
					);
				/* ESM import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Vector2.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector2.js"
					);
				/* ESM import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/MathUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/MathUtils.js"
					);
				/* ESM import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../constants.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js"
					);
				/* ESM import */ var _extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../extras/DataUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/extras/DataUtils.js"
					);

				const _vector =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _vector2 =
					/*@__PURE__*/ new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__.Vector2();

				class BufferAttribute {
					constructor(array, itemSize, normalized = false) {
						if (Array.isArray(array)) {
							throw new TypeError(
								"THREE.BufferAttribute: array should be a Typed Array."
							);
						}

						this.isBufferAttribute = true;

						this.name = "";

						this.array = array;
						this.itemSize = itemSize;
						this.count = array !== undefined ? array.length / itemSize : 0;
						this.normalized = normalized;

						this.usage =
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.StaticDrawUsage;
						this.updateRanges = [];
						this.gpuType = _constants_js__WEBPACK_IMPORTED_MODULE_2__.FloatType;

						this.version = 0;
					}

					onUploadCallback() {}

					set needsUpdate(value) {
						if (value === true) this.version++;
					}

					setUsage(value) {
						this.usage = value;

						return this;
					}

					addUpdateRange(start, count) {
						this.updateRanges.push({ start, count });
					}

					clearUpdateRanges() {
						this.updateRanges.length = 0;
					}

					copy(source) {
						this.name = source.name;
						this.array = new source.array.constructor(source.array);
						this.itemSize = source.itemSize;
						this.count = source.count;
						this.normalized = source.normalized;

						this.usage = source.usage;
						this.gpuType = source.gpuType;

						return this;
					}

					copyAt(index1, attribute, index2) {
						index1 *= this.itemSize;
						index2 *= attribute.itemSize;

						for (let i = 0, l = this.itemSize; i < l; i++) {
							this.array[index1 + i] = attribute.array[index2 + i];
						}

						return this;
					}

					copyArray(array) {
						this.array.set(array);

						return this;
					}

					applyMatrix3(m) {
						if (this.itemSize === 2) {
							for (let i = 0, l = this.count; i < l; i++) {
								_vector2.fromBufferAttribute(this, i);
								_vector2.applyMatrix3(m);

								this.setXY(i, _vector2.x, _vector2.y);
							}
						} else if (this.itemSize === 3) {
							for (let i = 0, l = this.count; i < l; i++) {
								_vector.fromBufferAttribute(this, i);
								_vector.applyMatrix3(m);

								this.setXYZ(i, _vector.x, _vector.y, _vector.z);
							}
						}

						return this;
					}

					applyMatrix4(m) {
						for (let i = 0, l = this.count; i < l; i++) {
							_vector.fromBufferAttribute(this, i);

							_vector.applyMatrix4(m);

							this.setXYZ(i, _vector.x, _vector.y, _vector.z);
						}

						return this;
					}

					applyNormalMatrix(m) {
						for (let i = 0, l = this.count; i < l; i++) {
							_vector.fromBufferAttribute(this, i);

							_vector.applyNormalMatrix(m);

							this.setXYZ(i, _vector.x, _vector.y, _vector.z);
						}

						return this;
					}

					transformDirection(m) {
						for (let i = 0, l = this.count; i < l; i++) {
							_vector.fromBufferAttribute(this, i);

							_vector.transformDirection(m);

							this.setXYZ(i, _vector.x, _vector.y, _vector.z);
						}

						return this;
					}

					set(value, offset = 0) {
						// Matching BufferAttribute constructor, do not normalize the array.
						this.array.set(value, offset);

						return this;
					}

					getComponent(index, component) {
						let value = this.array[index * this.itemSize + component];

						if (this.normalized)
							value = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.denormalize)(
								value,
								this.array
							);

						return value;
					}

					setComponent(index, component, value) {
						if (this.normalized)
							value = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								value,
								this.array
							);

						this.array[index * this.itemSize + component] = value;

						return this;
					}

					getX(index) {
						let x = this.array[index * this.itemSize];

						if (this.normalized)
							x = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.denormalize)(
								x,
								this.array
							);

						return x;
					}

					setX(index, x) {
						if (this.normalized)
							x = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								x,
								this.array
							);

						this.array[index * this.itemSize] = x;

						return this;
					}

					getY(index) {
						let y = this.array[index * this.itemSize + 1];

						if (this.normalized)
							y = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.denormalize)(
								y,
								this.array
							);

						return y;
					}

					setY(index, y) {
						if (this.normalized)
							y = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								y,
								this.array
							);

						this.array[index * this.itemSize + 1] = y;

						return this;
					}

					getZ(index) {
						let z = this.array[index * this.itemSize + 2];

						if (this.normalized)
							z = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.denormalize)(
								z,
								this.array
							);

						return z;
					}

					setZ(index, z) {
						if (this.normalized)
							z = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								z,
								this.array
							);

						this.array[index * this.itemSize + 2] = z;

						return this;
					}

					getW(index) {
						let w = this.array[index * this.itemSize + 3];

						if (this.normalized)
							w = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.denormalize)(
								w,
								this.array
							);

						return w;
					}

					setW(index, w) {
						if (this.normalized)
							w = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								w,
								this.array
							);

						this.array[index * this.itemSize + 3] = w;

						return this;
					}

					setXY(index, x, y) {
						index *= this.itemSize;

						if (this.normalized) {
							x = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								x,
								this.array
							);
							y = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								y,
								this.array
							);
						}

						this.array[index + 0] = x;
						this.array[index + 1] = y;

						return this;
					}

					setXYZ(index, x, y, z) {
						index *= this.itemSize;

						if (this.normalized) {
							x = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								x,
								this.array
							);
							y = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								y,
								this.array
							);
							z = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								z,
								this.array
							);
						}

						this.array[index + 0] = x;
						this.array[index + 1] = y;
						this.array[index + 2] = z;

						return this;
					}

					setXYZW(index, x, y, z, w) {
						index *= this.itemSize;

						if (this.normalized) {
							x = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								x,
								this.array
							);
							y = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								y,
								this.array
							);
							z = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								z,
								this.array
							);
							w = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								w,
								this.array
							);
						}

						this.array[index + 0] = x;
						this.array[index + 1] = y;
						this.array[index + 2] = z;
						this.array[index + 3] = w;

						return this;
					}

					onUpload(callback) {
						this.onUploadCallback = callback;

						return this;
					}

					clone() {
						return new this.constructor(this.array, this.itemSize).copy(this);
					}

					toJSON() {
						const data = {
							itemSize: this.itemSize,
							type: this.array.constructor.name,
							array: Array.from(this.array),
							normalized: this.normalized
						};

						if (this.name !== "") data.name = this.name;
						if (
							this.usage !==
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.StaticDrawUsage
						)
							data.usage = this.usage;

						return data;
					}
				}

				//

				class Int8BufferAttribute extends BufferAttribute {
					constructor(array, itemSize, normalized) {
						super(new Int8Array(array), itemSize, normalized);
					}
				}

				class Uint8BufferAttribute extends BufferAttribute {
					constructor(array, itemSize, normalized) {
						super(new Uint8Array(array), itemSize, normalized);
					}
				}

				class Uint8ClampedBufferAttribute extends BufferAttribute {
					constructor(array, itemSize, normalized) {
						super(new Uint8ClampedArray(array), itemSize, normalized);
					}
				}

				class Int16BufferAttribute extends BufferAttribute {
					constructor(array, itemSize, normalized) {
						super(new Int16Array(array), itemSize, normalized);
					}
				}

				class Uint16BufferAttribute extends BufferAttribute {
					constructor(array, itemSize, normalized) {
						super(new Uint16Array(array), itemSize, normalized);
					}
				}

				class Int32BufferAttribute extends BufferAttribute {
					constructor(array, itemSize, normalized) {
						super(new Int32Array(array), itemSize, normalized);
					}
				}

				class Uint32BufferAttribute extends BufferAttribute {
					constructor(array, itemSize, normalized) {
						super(new Uint32Array(array), itemSize, normalized);
					}
				}

				class Float16BufferAttribute extends BufferAttribute {
					constructor(array, itemSize, normalized) {
						super(new Uint16Array(array), itemSize, normalized);

						this.isFloat16BufferAttribute = true;
					}

					getX(index) {
						let x = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.fromHalfFloat)(
							this.array[index * this.itemSize]
						);

						if (this.normalized)
							x = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.denormalize)(
								x,
								this.array
							);

						return x;
					}

					setX(index, x) {
						if (this.normalized)
							x = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								x,
								this.array
							);

						this.array[index * this.itemSize] = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.toHalfFloat)(x);

						return this;
					}

					getY(index) {
						let y = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.fromHalfFloat)(
							this.array[index * this.itemSize + 1]
						);

						if (this.normalized)
							y = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.denormalize)(
								y,
								this.array
							);

						return y;
					}

					setY(index, y) {
						if (this.normalized)
							y = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								y,
								this.array
							);

						this.array[index * this.itemSize + 1] = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.toHalfFloat)(y);

						return this;
					}

					getZ(index) {
						let z = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.fromHalfFloat)(
							this.array[index * this.itemSize + 2]
						);

						if (this.normalized)
							z = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.denormalize)(
								z,
								this.array
							);

						return z;
					}

					setZ(index, z) {
						if (this.normalized)
							z = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								z,
								this.array
							);

						this.array[index * this.itemSize + 2] = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.toHalfFloat)(z);

						return this;
					}

					getW(index) {
						let w = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.fromHalfFloat)(
							this.array[index * this.itemSize + 3]
						);

						if (this.normalized)
							w = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.denormalize)(
								w,
								this.array
							);

						return w;
					}

					setW(index, w) {
						if (this.normalized)
							w = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								w,
								this.array
							);

						this.array[index * this.itemSize + 3] = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.toHalfFloat)(w);

						return this;
					}

					setXY(index, x, y) {
						index *= this.itemSize;

						if (this.normalized) {
							x = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								x,
								this.array
							);
							y = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								y,
								this.array
							);
						}

						this.array[index + 0] = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.toHalfFloat)(x);
						this.array[index + 1] = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.toHalfFloat)(y);

						return this;
					}

					setXYZ(index, x, y, z) {
						index *= this.itemSize;

						if (this.normalized) {
							x = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								x,
								this.array
							);
							y = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								y,
								this.array
							);
							z = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								z,
								this.array
							);
						}

						this.array[index + 0] = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.toHalfFloat)(x);
						this.array[index + 1] = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.toHalfFloat)(y);
						this.array[index + 2] = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.toHalfFloat)(z);

						return this;
					}

					setXYZW(index, x, y, z, w) {
						index *= this.itemSize;

						if (this.normalized) {
							x = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								x,
								this.array
							);
							y = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								y,
								this.array
							);
							z = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								z,
								this.array
							);
							w = (0,
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(
								w,
								this.array
							);
						}

						this.array[index + 0] = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.toHalfFloat)(x);
						this.array[index + 1] = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.toHalfFloat)(y);
						this.array[index + 2] = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.toHalfFloat)(z);
						this.array[index + 3] = (0,
						_extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_4__.toHalfFloat)(w);

						return this;
					}
				}

				class Float32BufferAttribute extends BufferAttribute {
					constructor(array, itemSize, normalized) {
						super(new Float32Array(array), itemSize, normalized);
					}
				}

				//
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/BufferGeometry.js":
			/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/BufferGeometry.js ***!
  \********************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					BufferGeometry: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.BufferGeometry"] */ BufferGeometry
				});
				/* ESM import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Vector3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector3.js"
					);
				/* ESM import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_10__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Vector2.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector2.js"
					);
				/* ESM import */ var _math_Box3_js__WEBPACK_IMPORTED_MODULE_3__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Box3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Box3.js"
					);
				/* ESM import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_4__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./EventDispatcher.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/EventDispatcher.js"
					);
				/* ESM import */ var _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./BufferAttribute.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/BufferAttribute.js"
					);
				/* ESM import */ var _math_Sphere_js__WEBPACK_IMPORTED_MODULE_9__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Sphere.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Sphere.js"
					);
				/* ESM import */ var _Object3D_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Object3D.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/Object3D.js"
					);
				/* ESM import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Matrix4.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Matrix4.js"
					);
				/* ESM import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_8__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Matrix3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Matrix3.js"
					);
				/* ESM import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_5__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/MathUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/MathUtils.js"
					);
				/* ESM import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../utils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/utils.js"
					);

				let _id = 0;

				const _m1 =
					/*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
				const _obj =
					/*@__PURE__*/ new _Object3D_js__WEBPACK_IMPORTED_MODULE_1__.Object3D();
				const _offset =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3();
				const _box =
					/*@__PURE__*/ new _math_Box3_js__WEBPACK_IMPORTED_MODULE_3__.Box3();
				const _boxMorphTargets =
					/*@__PURE__*/ new _math_Box3_js__WEBPACK_IMPORTED_MODULE_3__.Box3();
				const _vector =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3();

				class BufferGeometry extends _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_4__.EventDispatcher {
					constructor() {
						super();

						this.isBufferGeometry = true;

						Object.defineProperty(this, "id", { value: _id++ });

						this.uuid =
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_5__.generateUUID();

						this.name = "";
						this.type = "BufferGeometry";

						this.index = null;
						this.attributes = {};

						this.morphAttributes = {};
						this.morphTargetsRelative = false;

						this.groups = [];

						this.boundingBox = null;
						this.boundingSphere = null;

						this.drawRange = { start: 0, count: Infinity };

						this.userData = {};
					}

					getIndex() {
						return this.index;
					}

					setIndex(index) {
						if (Array.isArray(index)) {
							this.index = new (
								(0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.arrayNeedsUint32)(
									index
								)
									? _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__.Uint32BufferAttribute
									: _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__.Uint16BufferAttribute
							)(index, 1);
						} else {
							this.index = index;
						}

						return this;
					}

					getAttribute(name) {
						return this.attributes[name];
					}

					setAttribute(name, attribute) {
						this.attributes[name] = attribute;

						return this;
					}

					deleteAttribute(name) {
						delete this.attributes[name];

						return this;
					}

					hasAttribute(name) {
						return this.attributes[name] !== undefined;
					}

					addGroup(start, count, materialIndex = 0) {
						this.groups.push({
							start: start,
							count: count,
							materialIndex: materialIndex
						});
					}

					clearGroups() {
						this.groups = [];
					}

					setDrawRange(start, count) {
						this.drawRange.start = start;
						this.drawRange.count = count;
					}

					applyMatrix4(matrix) {
						const position = this.attributes.position;

						if (position !== undefined) {
							position.applyMatrix4(matrix);

							position.needsUpdate = true;
						}

						const normal = this.attributes.normal;

						if (normal !== undefined) {
							const normalMatrix =
								new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_8__.Matrix3().getNormalMatrix(
									matrix
								);

							normal.applyNormalMatrix(normalMatrix);

							normal.needsUpdate = true;
						}

						const tangent = this.attributes.tangent;

						if (tangent !== undefined) {
							tangent.transformDirection(matrix);

							tangent.needsUpdate = true;
						}

						if (this.boundingBox !== null) {
							this.computeBoundingBox();
						}

						if (this.boundingSphere !== null) {
							this.computeBoundingSphere();
						}

						return this;
					}

					applyQuaternion(q) {
						_m1.makeRotationFromQuaternion(q);

						this.applyMatrix4(_m1);

						return this;
					}

					rotateX(angle) {
						// rotate geometry around world x-axis

						_m1.makeRotationX(angle);

						this.applyMatrix4(_m1);

						return this;
					}

					rotateY(angle) {
						// rotate geometry around world y-axis

						_m1.makeRotationY(angle);

						this.applyMatrix4(_m1);

						return this;
					}

					rotateZ(angle) {
						// rotate geometry around world z-axis

						_m1.makeRotationZ(angle);

						this.applyMatrix4(_m1);

						return this;
					}

					translate(x, y, z) {
						// translate geometry

						_m1.makeTranslation(x, y, z);

						this.applyMatrix4(_m1);

						return this;
					}

					scale(x, y, z) {
						// scale geometry

						_m1.makeScale(x, y, z);

						this.applyMatrix4(_m1);

						return this;
					}

					lookAt(vector) {
						_obj.lookAt(vector);

						_obj.updateMatrix();

						this.applyMatrix4(_obj.matrix);

						return this;
					}

					center() {
						this.computeBoundingBox();

						this.boundingBox.getCenter(_offset).negate();

						this.translate(_offset.x, _offset.y, _offset.z);

						return this;
					}

					setFromPoints(points) {
						const position = [];

						for (let i = 0, l = points.length; i < l; i++) {
							const point = points[i];
							position.push(point.x, point.y, point.z || 0);
						}

						this.setAttribute(
							"position",
							new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__.Float32BufferAttribute(
								position,
								3
							)
						);

						return this;
					}

					computeBoundingBox() {
						if (this.boundingBox === null) {
							this.boundingBox =
								new _math_Box3_js__WEBPACK_IMPORTED_MODULE_3__.Box3();
						}

						const position = this.attributes.position;
						const morphAttributesPosition = this.morphAttributes.position;

						if (position && position.isGLBufferAttribute) {
							console.error(
								"THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
								this
							);

							this.boundingBox.set(
								new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(
									-Infinity,
									-Infinity,
									-Infinity
								),
								new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(
									+Infinity,
									+Infinity,
									+Infinity
								)
							);

							return;
						}

						if (position !== undefined) {
							this.boundingBox.setFromBufferAttribute(position);

							// process morph attributes if present

							if (morphAttributesPosition) {
								for (
									let i = 0, il = morphAttributesPosition.length;
									i < il;
									i++
								) {
									const morphAttribute = morphAttributesPosition[i];
									_box.setFromBufferAttribute(morphAttribute);

									if (this.morphTargetsRelative) {
										_vector.addVectors(this.boundingBox.min, _box.min);
										this.boundingBox.expandByPoint(_vector);

										_vector.addVectors(this.boundingBox.max, _box.max);
										this.boundingBox.expandByPoint(_vector);
									} else {
										this.boundingBox.expandByPoint(_box.min);
										this.boundingBox.expandByPoint(_box.max);
									}
								}
							}
						} else {
							this.boundingBox.makeEmpty();
						}

						if (
							isNaN(this.boundingBox.min.x) ||
							isNaN(this.boundingBox.min.y) ||
							isNaN(this.boundingBox.min.z)
						) {
							console.error(
								'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
								this
							);
						}
					}

					computeBoundingSphere() {
						if (this.boundingSphere === null) {
							this.boundingSphere =
								new _math_Sphere_js__WEBPACK_IMPORTED_MODULE_9__.Sphere();
						}

						const position = this.attributes.position;
						const morphAttributesPosition = this.morphAttributes.position;

						if (position && position.isGLBufferAttribute) {
							console.error(
								"THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
								this
							);

							this.boundingSphere.set(
								new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(),
								Infinity
							);

							return;
						}

						if (position) {
							// first, find the center of the bounding sphere

							const center = this.boundingSphere.center;

							_box.setFromBufferAttribute(position);

							// process morph attributes if present

							if (morphAttributesPosition) {
								for (
									let i = 0, il = morphAttributesPosition.length;
									i < il;
									i++
								) {
									const morphAttribute = morphAttributesPosition[i];
									_boxMorphTargets.setFromBufferAttribute(morphAttribute);

									if (this.morphTargetsRelative) {
										_vector.addVectors(_box.min, _boxMorphTargets.min);
										_box.expandByPoint(_vector);

										_vector.addVectors(_box.max, _boxMorphTargets.max);
										_box.expandByPoint(_vector);
									} else {
										_box.expandByPoint(_boxMorphTargets.min);
										_box.expandByPoint(_boxMorphTargets.max);
									}
								}
							}

							_box.getCenter(center);

							// second, try to find a boundingSphere with a radius smaller than the
							// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

							let maxRadiusSq = 0;

							for (let i = 0, il = position.count; i < il; i++) {
								_vector.fromBufferAttribute(position, i);

								maxRadiusSq = Math.max(
									maxRadiusSq,
									center.distanceToSquared(_vector)
								);
							}

							// process morph attributes if present

							if (morphAttributesPosition) {
								for (
									let i = 0, il = morphAttributesPosition.length;
									i < il;
									i++
								) {
									const morphAttribute = morphAttributesPosition[i];
									const morphTargetsRelative = this.morphTargetsRelative;

									for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
										_vector.fromBufferAttribute(morphAttribute, j);

										if (morphTargetsRelative) {
											_offset.fromBufferAttribute(position, j);
											_vector.add(_offset);
										}

										maxRadiusSq = Math.max(
											maxRadiusSq,
											center.distanceToSquared(_vector)
										);
									}
								}
							}

							this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

							if (isNaN(this.boundingSphere.radius)) {
								console.error(
									'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
									this
								);
							}
						}
					}

					computeTangents() {
						const index = this.index;
						const attributes = this.attributes;

						// based on http://www.terathon.com/code/tangent.html
						// (per vertex tangents)

						if (
							index === null ||
							attributes.position === undefined ||
							attributes.normal === undefined ||
							attributes.uv === undefined
						) {
							console.error(
								"THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
							);
							return;
						}

						const positionAttribute = attributes.position;
						const normalAttribute = attributes.normal;
						const uvAttribute = attributes.uv;

						if (this.hasAttribute("tangent") === false) {
							this.setAttribute(
								"tangent",
								new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__.BufferAttribute(
									new Float32Array(4 * positionAttribute.count),
									4
								)
							);
						}

						const tangentAttribute = this.getAttribute("tangent");

						const tan1 = [],
							tan2 = [];

						for (let i = 0; i < positionAttribute.count; i++) {
							tan1[i] =
								new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3();
							tan2[i] =
								new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3();
						}

						const vA =
								new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(),
							vB = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(),
							vC = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(),
							uvA =
								new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_10__.Vector2(),
							uvB =
								new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_10__.Vector2(),
							uvC =
								new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_10__.Vector2(),
							sdir =
								new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(),
							tdir =
								new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3();

						function handleTriangle(a, b, c) {
							vA.fromBufferAttribute(positionAttribute, a);
							vB.fromBufferAttribute(positionAttribute, b);
							vC.fromBufferAttribute(positionAttribute, c);

							uvA.fromBufferAttribute(uvAttribute, a);
							uvB.fromBufferAttribute(uvAttribute, b);
							uvC.fromBufferAttribute(uvAttribute, c);

							vB.sub(vA);
							vC.sub(vA);

							uvB.sub(uvA);
							uvC.sub(uvA);

							const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);

							// silently ignore degenerate uv triangles having coincident or colinear vertices

							if (!isFinite(r)) return;

							sdir
								.copy(vB)
								.multiplyScalar(uvC.y)
								.addScaledVector(vC, -uvB.y)
								.multiplyScalar(r);
							tdir
								.copy(vC)
								.multiplyScalar(uvB.x)
								.addScaledVector(vB, -uvC.x)
								.multiplyScalar(r);

							tan1[a].add(sdir);
							tan1[b].add(sdir);
							tan1[c].add(sdir);

							tan2[a].add(tdir);
							tan2[b].add(tdir);
							tan2[c].add(tdir);
						}

						let groups = this.groups;

						if (groups.length === 0) {
							groups = [
								{
									start: 0,
									count: index.count
								}
							];
						}

						for (let i = 0, il = groups.length; i < il; ++i) {
							const group = groups[i];

							const start = group.start;
							const count = group.count;

							for (let j = start, jl = start + count; j < jl; j += 3) {
								handleTriangle(
									index.getX(j + 0),
									index.getX(j + 1),
									index.getX(j + 2)
								);
							}
						}

						const tmp =
								new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(),
							tmp2 =
								new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3();
						const n =
								new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(),
							n2 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3();

						function handleVertex(v) {
							n.fromBufferAttribute(normalAttribute, v);
							n2.copy(n);

							const t = tan1[v];

							// Gram-Schmidt orthogonalize

							tmp.copy(t);
							tmp.sub(n.multiplyScalar(n.dot(t))).normalize();

							// Calculate handedness

							tmp2.crossVectors(n2, t);
							const test = tmp2.dot(tan2[v]);
							const w = test < 0.0 ? -1.0 : 1.0;

							tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);
						}

						for (let i = 0, il = groups.length; i < il; ++i) {
							const group = groups[i];

							const start = group.start;
							const count = group.count;

							for (let j = start, jl = start + count; j < jl; j += 3) {
								handleVertex(index.getX(j + 0));
								handleVertex(index.getX(j + 1));
								handleVertex(index.getX(j + 2));
							}
						}
					}

					computeVertexNormals() {
						const index = this.index;
						const positionAttribute = this.getAttribute("position");

						if (positionAttribute !== undefined) {
							let normalAttribute = this.getAttribute("normal");

							if (normalAttribute === undefined) {
								normalAttribute =
									new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__.BufferAttribute(
										new Float32Array(positionAttribute.count * 3),
										3
									);
								this.setAttribute("normal", normalAttribute);
							} else {
								// reset existing normals to zero

								for (let i = 0, il = normalAttribute.count; i < il; i++) {
									normalAttribute.setXYZ(i, 0, 0, 0);
								}
							}

							const pA =
									new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(),
								pB =
									new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(),
								pC =
									new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3();
							const nA =
									new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(),
								nB =
									new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(),
								nC =
									new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3();
							const cb =
									new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3(),
								ab =
									new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__.Vector3();

							// indexed elements

							if (index) {
								for (let i = 0, il = index.count; i < il; i += 3) {
									const vA = index.getX(i + 0);
									const vB = index.getX(i + 1);
									const vC = index.getX(i + 2);

									pA.fromBufferAttribute(positionAttribute, vA);
									pB.fromBufferAttribute(positionAttribute, vB);
									pC.fromBufferAttribute(positionAttribute, vC);

									cb.subVectors(pC, pB);
									ab.subVectors(pA, pB);
									cb.cross(ab);

									nA.fromBufferAttribute(normalAttribute, vA);
									nB.fromBufferAttribute(normalAttribute, vB);
									nC.fromBufferAttribute(normalAttribute, vC);

									nA.add(cb);
									nB.add(cb);
									nC.add(cb);

									normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
									normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
									normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
								}
							} else {
								// non-indexed elements (unconnected triangle soup)

								for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
									pA.fromBufferAttribute(positionAttribute, i + 0);
									pB.fromBufferAttribute(positionAttribute, i + 1);
									pC.fromBufferAttribute(positionAttribute, i + 2);

									cb.subVectors(pC, pB);
									ab.subVectors(pA, pB);
									cb.cross(ab);

									normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
									normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
									normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
								}
							}

							this.normalizeNormals();

							normalAttribute.needsUpdate = true;
						}
					}

					normalizeNormals() {
						const normals = this.attributes.normal;

						for (let i = 0, il = normals.count; i < il; i++) {
							_vector.fromBufferAttribute(normals, i);

							_vector.normalize();

							normals.setXYZ(i, _vector.x, _vector.y, _vector.z);
						}
					}

					toNonIndexed() {
						function convertBufferAttribute(attribute, indices) {
							const array = attribute.array;
							const itemSize = attribute.itemSize;
							const normalized = attribute.normalized;

							const array2 = new array.constructor(indices.length * itemSize);

							let index = 0,
								index2 = 0;

							for (let i = 0, l = indices.length; i < l; i++) {
								if (attribute.isInterleavedBufferAttribute) {
									index = indices[i] * attribute.data.stride + attribute.offset;
								} else {
									index = indices[i] * itemSize;
								}

								for (let j = 0; j < itemSize; j++) {
									array2[index2++] = array[index++];
								}
							}

							return new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__.BufferAttribute(
								array2,
								itemSize,
								normalized
							);
						}

						//

						if (this.index === null) {
							console.warn(
								"THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
							);
							return this;
						}

						const geometry2 = new BufferGeometry();

						const indices = this.index.array;
						const attributes = this.attributes;

						// attributes

						for (const name in attributes) {
							const attribute = attributes[name];

							const newAttribute = convertBufferAttribute(attribute, indices);

							geometry2.setAttribute(name, newAttribute);
						}

						// morph attributes

						const morphAttributes = this.morphAttributes;

						for (const name in morphAttributes) {
							const morphArray = [];
							const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

							for (let i = 0, il = morphAttribute.length; i < il; i++) {
								const attribute = morphAttribute[i];

								const newAttribute = convertBufferAttribute(attribute, indices);

								morphArray.push(newAttribute);
							}

							geometry2.morphAttributes[name] = morphArray;
						}

						geometry2.morphTargetsRelative = this.morphTargetsRelative;

						// groups

						const groups = this.groups;

						for (let i = 0, l = groups.length; i < l; i++) {
							const group = groups[i];
							geometry2.addGroup(group.start, group.count, group.materialIndex);
						}

						return geometry2;
					}

					toJSON() {
						const data = {
							metadata: {
								version: 4.6,
								type: "BufferGeometry",
								generator: "BufferGeometry.toJSON"
							}
						};

						// standard BufferGeometry serialization

						data.uuid = this.uuid;
						data.type = this.type;
						if (this.name !== "") data.name = this.name;
						if (Object.keys(this.userData).length > 0)
							data.userData = this.userData;

						if (this.parameters !== undefined) {
							const parameters = this.parameters;

							for (const key in parameters) {
								if (parameters[key] !== undefined) data[key] = parameters[key];
							}

							return data;
						}

						// for simplicity the code assumes attributes are not shared across geometries, see #15811

						data.data = { attributes: {} };

						const index = this.index;

						if (index !== null) {
							data.data.index = {
								type: index.array.constructor.name,
								array: Array.prototype.slice.call(index.array)
							};
						}

						const attributes = this.attributes;

						for (const key in attributes) {
							const attribute = attributes[key];

							data.data.attributes[key] = attribute.toJSON(data.data);
						}

						const morphAttributes = {};
						let hasMorphAttributes = false;

						for (const key in this.morphAttributes) {
							const attributeArray = this.morphAttributes[key];

							const array = [];

							for (let i = 0, il = attributeArray.length; i < il; i++) {
								const attribute = attributeArray[i];

								array.push(attribute.toJSON(data.data));
							}

							if (array.length > 0) {
								morphAttributes[key] = array;

								hasMorphAttributes = true;
							}
						}

						if (hasMorphAttributes) {
							data.data.morphAttributes = morphAttributes;
							data.data.morphTargetsRelative = this.morphTargetsRelative;
						}

						const groups = this.groups;

						if (groups.length > 0) {
							data.data.groups = JSON.parse(JSON.stringify(groups));
						}

						const boundingSphere = this.boundingSphere;

						if (boundingSphere !== null) {
							data.data.boundingSphere = {
								center: boundingSphere.center.toArray(),
								radius: boundingSphere.radius
							};
						}

						return data;
					}

					clone() {
						return new this.constructor().copy(this);
					}

					copy(source) {
						// reset

						this.index = null;
						this.attributes = {};
						this.morphAttributes = {};
						this.groups = [];
						this.boundingBox = null;
						this.boundingSphere = null;

						// used for storing cloned, shared data

						const data = {};

						// name

						this.name = source.name;

						// index

						const index = source.index;

						if (index !== null) {
							this.setIndex(index.clone(data));
						}

						// attributes

						const attributes = source.attributes;

						for (const name in attributes) {
							const attribute = attributes[name];
							this.setAttribute(name, attribute.clone(data));
						}

						// morph attributes

						const morphAttributes = source.morphAttributes;

						for (const name in morphAttributes) {
							const array = [];
							const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

							for (let i = 0, l = morphAttribute.length; i < l; i++) {
								array.push(morphAttribute[i].clone(data));
							}

							this.morphAttributes[name] = array;
						}

						this.morphTargetsRelative = source.morphTargetsRelative;

						// groups

						const groups = source.groups;

						for (let i = 0, l = groups.length; i < l; i++) {
							const group = groups[i];
							this.addGroup(group.start, group.count, group.materialIndex);
						}

						// bounding box

						const boundingBox = source.boundingBox;

						if (boundingBox !== null) {
							this.boundingBox = boundingBox.clone();
						}

						// bounding sphere

						const boundingSphere = source.boundingSphere;

						if (boundingSphere !== null) {
							this.boundingSphere = boundingSphere.clone();
						}

						// draw range

						this.drawRange.start = source.drawRange.start;
						this.drawRange.count = source.drawRange.count;

						// user data

						this.userData = source.userData;

						return this;
					}

					dispose() {
						this.dispatchEvent({ type: "dispose" });
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/Layers.js":
			/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/Layers.js ***!
  \************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Layers: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Layers"] */ Layers
				});
				class Layers {
					constructor() {
						this.mask = 1 | 0;
					}

					set(channel) {
						this.mask = ((1 << channel) | 0) >>> 0;
					}

					enable(channel) {
						this.mask |= (1 << channel) | 0;
					}

					enableAll() {
						this.mask = 0xffffffff | 0;
					}

					toggle(channel) {
						this.mask ^= (1 << channel) | 0;
					}

					disable(channel) {
						this.mask &= ~((1 << channel) | 0);
					}

					disableAll() {
						this.mask = 0;
					}

					test(layers) {
						return (this.mask & layers.mask) !== 0;
					}

					isEnabled(channel) {
						return (this.mask & ((1 << channel) | 0)) !== 0;
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/Object3D.js":
			/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/Object3D.js ***!
  \**************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Object3D: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Object3D"] */ Object3D
				});
				/* ESM import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Quaternion.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Quaternion.js"
					);
				/* ESM import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Vector3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector3.js"
					);
				/* ESM import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Matrix4.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Matrix4.js"
					);
				/* ESM import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./EventDispatcher.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/EventDispatcher.js"
					);
				/* ESM import */ var _math_Euler_js__WEBPACK_IMPORTED_MODULE_5__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Euler.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Euler.js"
					);
				/* ESM import */ var _Layers_js__WEBPACK_IMPORTED_MODULE_7__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Layers.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/Layers.js"
					);
				/* ESM import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Matrix3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Matrix3.js"
					);
				/* ESM import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_4__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/MathUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/MathUtils.js"
					);

				let _object3DId = 0;

				const _v1 =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _q1 =
					/*@__PURE__*/ new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
				const _m1 =
					/*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__.Matrix4();
				const _target =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();

				const _position =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _scale =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _quaternion =
					/*@__PURE__*/ new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion();

				const _xAxis =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(
						1,
						0,
						0
					);
				const _yAxis =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(
						0,
						1,
						0
					);
				const _zAxis =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(
						0,
						0,
						1
					);

				const _addedEvent = { type: "added" };
				const _removedEvent = { type: "removed" };

				const _childaddedEvent = { type: "childadded", child: null };
				const _childremovedEvent = { type: "childremoved", child: null };

				class Object3D extends _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__.EventDispatcher {
					constructor() {
						super();

						this.isObject3D = true;

						Object.defineProperty(this, "id", { value: _object3DId++ });

						this.uuid =
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_4__.generateUUID();

						this.name = "";
						this.type = "Object3D";

						this.parent = null;
						this.children = [];

						this.up = Object3D.DEFAULT_UP.clone();

						const position =
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
						const rotation =
							new _math_Euler_js__WEBPACK_IMPORTED_MODULE_5__.Euler();
						const quaternion =
							new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
						const scale =
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(
								1,
								1,
								1
							);

						function onRotationChange() {
							quaternion.setFromEuler(rotation, false);
						}

						function onQuaternionChange() {
							rotation.setFromQuaternion(quaternion, undefined, false);
						}

						rotation._onChange(onRotationChange);
						quaternion._onChange(onQuaternionChange);

						Object.defineProperties(this, {
							position: {
								configurable: true,
								enumerable: true,
								value: position
							},
							rotation: {
								configurable: true,
								enumerable: true,
								value: rotation
							},
							quaternion: {
								configurable: true,
								enumerable: true,
								value: quaternion
							},
							scale: {
								configurable: true,
								enumerable: true,
								value: scale
							},
							modelViewMatrix: {
								value:
									new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__.Matrix4()
							},
							normalMatrix: {
								value:
									new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__.Matrix3()
							}
						});

						this.matrix =
							new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__.Matrix4();
						this.matrixWorld =
							new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__.Matrix4();

						this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;

						this.matrixWorldAutoUpdate =
							Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer
						this.matrixWorldNeedsUpdate = false;

						this.layers = new _Layers_js__WEBPACK_IMPORTED_MODULE_7__.Layers();
						this.visible = true;

						this.castShadow = false;
						this.receiveShadow = false;

						this.frustumCulled = true;
						this.renderOrder = 0;

						this.animations = [];

						this.userData = {};
					}

					onBeforeShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}

					onAfterShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}

					onBeforeRender(/* renderer, scene, camera, geometry, material, group */) {}

					onAfterRender(/* renderer, scene, camera, geometry, material, group */) {}

					applyMatrix4(matrix) {
						if (this.matrixAutoUpdate) this.updateMatrix();

						this.matrix.premultiply(matrix);

						this.matrix.decompose(this.position, this.quaternion, this.scale);
					}

					applyQuaternion(q) {
						this.quaternion.premultiply(q);

						return this;
					}

					setRotationFromAxisAngle(axis, angle) {
						// assumes axis is normalized

						this.quaternion.setFromAxisAngle(axis, angle);
					}

					setRotationFromEuler(euler) {
						this.quaternion.setFromEuler(euler, true);
					}

					setRotationFromMatrix(m) {
						// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

						this.quaternion.setFromRotationMatrix(m);
					}

					setRotationFromQuaternion(q) {
						// assumes q is normalized

						this.quaternion.copy(q);
					}

					rotateOnAxis(axis, angle) {
						// rotate object on axis in object space
						// axis is assumed to be normalized

						_q1.setFromAxisAngle(axis, angle);

						this.quaternion.multiply(_q1);

						return this;
					}

					rotateOnWorldAxis(axis, angle) {
						// rotate object on axis in world space
						// axis is assumed to be normalized
						// method assumes no rotated parent

						_q1.setFromAxisAngle(axis, angle);

						this.quaternion.premultiply(_q1);

						return this;
					}

					rotateX(angle) {
						return this.rotateOnAxis(_xAxis, angle);
					}

					rotateY(angle) {
						return this.rotateOnAxis(_yAxis, angle);
					}

					rotateZ(angle) {
						return this.rotateOnAxis(_zAxis, angle);
					}

					translateOnAxis(axis, distance) {
						// translate object by distance along axis in object space
						// axis is assumed to be normalized

						_v1.copy(axis).applyQuaternion(this.quaternion);

						this.position.add(_v1.multiplyScalar(distance));

						return this;
					}

					translateX(distance) {
						return this.translateOnAxis(_xAxis, distance);
					}

					translateY(distance) {
						return this.translateOnAxis(_yAxis, distance);
					}

					translateZ(distance) {
						return this.translateOnAxis(_zAxis, distance);
					}

					localToWorld(vector) {
						this.updateWorldMatrix(true, false);

						return vector.applyMatrix4(this.matrixWorld);
					}

					worldToLocal(vector) {
						this.updateWorldMatrix(true, false);

						return vector.applyMatrix4(_m1.copy(this.matrixWorld).invert());
					}

					lookAt(x, y, z) {
						// This method does not support objects having non-uniformly-scaled parent(s)

						if (x.isVector3) {
							_target.copy(x);
						} else {
							_target.set(x, y, z);
						}

						const parent = this.parent;

						this.updateWorldMatrix(true, false);

						_position.setFromMatrixPosition(this.matrixWorld);

						if (this.isCamera || this.isLight) {
							_m1.lookAt(_position, _target, this.up);
						} else {
							_m1.lookAt(_target, _position, this.up);
						}

						this.quaternion.setFromRotationMatrix(_m1);

						if (parent) {
							_m1.extractRotation(parent.matrixWorld);
							_q1.setFromRotationMatrix(_m1);
							this.quaternion.premultiply(_q1.invert());
						}
					}

					add(object) {
						if (arguments.length > 1) {
							for (let i = 0; i < arguments.length; i++) {
								this.add(arguments[i]);
							}

							return this;
						}

						if (object === this) {
							console.error(
								"THREE.Object3D.add: object can't be added as a child of itself.",
								object
							);
							return this;
						}

						if (object && object.isObject3D) {
							object.removeFromParent();
							object.parent = this;
							this.children.push(object);

							object.dispatchEvent(_addedEvent);

							_childaddedEvent.child = object;
							this.dispatchEvent(_childaddedEvent);
							_childaddedEvent.child = null;
						} else {
							console.error(
								"THREE.Object3D.add: object not an instance of THREE.Object3D.",
								object
							);
						}

						return this;
					}

					remove(object) {
						if (arguments.length > 1) {
							for (let i = 0; i < arguments.length; i++) {
								this.remove(arguments[i]);
							}

							return this;
						}

						const index = this.children.indexOf(object);

						if (index !== -1) {
							object.parent = null;
							this.children.splice(index, 1);

							object.dispatchEvent(_removedEvent);

							_childremovedEvent.child = object;
							this.dispatchEvent(_childremovedEvent);
							_childremovedEvent.child = null;
						}

						return this;
					}

					removeFromParent() {
						const parent = this.parent;

						if (parent !== null) {
							parent.remove(this);
						}

						return this;
					}

					clear() {
						return this.remove(...this.children);
					}

					attach(object) {
						// adds object as a child of this, while maintaining the object's world transform

						// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

						this.updateWorldMatrix(true, false);

						_m1.copy(this.matrixWorld).invert();

						if (object.parent !== null) {
							object.parent.updateWorldMatrix(true, false);

							_m1.multiply(object.parent.matrixWorld);
						}

						object.applyMatrix4(_m1);

						object.removeFromParent();
						object.parent = this;
						this.children.push(object);

						object.updateWorldMatrix(false, true);

						object.dispatchEvent(_addedEvent);

						_childaddedEvent.child = object;
						this.dispatchEvent(_childaddedEvent);
						_childaddedEvent.child = null;

						return this;
					}

					getObjectById(id) {
						return this.getObjectByProperty("id", id);
					}

					getObjectByName(name) {
						return this.getObjectByProperty("name", name);
					}

					getObjectByProperty(name, value) {
						if (this[name] === value) return this;

						for (let i = 0, l = this.children.length; i < l; i++) {
							const child = this.children[i];
							const object = child.getObjectByProperty(name, value);

							if (object !== undefined) {
								return object;
							}
						}

						return undefined;
					}

					getObjectsByProperty(name, value, result = []) {
						if (this[name] === value) result.push(this);

						const children = this.children;

						for (let i = 0, l = children.length; i < l; i++) {
							children[i].getObjectsByProperty(name, value, result);
						}

						return result;
					}

					getWorldPosition(target) {
						this.updateWorldMatrix(true, false);

						return target.setFromMatrixPosition(this.matrixWorld);
					}

					getWorldQuaternion(target) {
						this.updateWorldMatrix(true, false);

						this.matrixWorld.decompose(_position, target, _scale);

						return target;
					}

					getWorldScale(target) {
						this.updateWorldMatrix(true, false);

						this.matrixWorld.decompose(_position, _quaternion, target);

						return target;
					}

					getWorldDirection(target) {
						this.updateWorldMatrix(true, false);

						const e = this.matrixWorld.elements;

						return target.set(e[8], e[9], e[10]).normalize();
					}

					raycast(/* raycaster, intersects */) {}

					traverse(callback) {
						callback(this);

						const children = this.children;

						for (let i = 0, l = children.length; i < l; i++) {
							children[i].traverse(callback);
						}
					}

					traverseVisible(callback) {
						if (this.visible === false) return;

						callback(this);

						const children = this.children;

						for (let i = 0, l = children.length; i < l; i++) {
							children[i].traverseVisible(callback);
						}
					}

					traverseAncestors(callback) {
						const parent = this.parent;

						if (parent !== null) {
							callback(parent);

							parent.traverseAncestors(callback);
						}
					}

					updateMatrix() {
						this.matrix.compose(this.position, this.quaternion, this.scale);

						this.matrixWorldNeedsUpdate = true;
					}

					updateMatrixWorld(force) {
						if (this.matrixAutoUpdate) this.updateMatrix();

						if (this.matrixWorldNeedsUpdate || force) {
							if (this.matrixWorldAutoUpdate === true) {
								if (this.parent === null) {
									this.matrixWorld.copy(this.matrix);
								} else {
									this.matrixWorld.multiplyMatrices(
										this.parent.matrixWorld,
										this.matrix
									);
								}
							}

							this.matrixWorldNeedsUpdate = false;

							force = true;
						}

						// make sure descendants are updated if required

						const children = this.children;

						for (let i = 0, l = children.length; i < l; i++) {
							const child = children[i];

							child.updateMatrixWorld(force);
						}
					}

					updateWorldMatrix(updateParents, updateChildren) {
						const parent = this.parent;

						if (updateParents === true && parent !== null) {
							parent.updateWorldMatrix(true, false);
						}

						if (this.matrixAutoUpdate) this.updateMatrix();

						if (this.matrixWorldAutoUpdate === true) {
							if (this.parent === null) {
								this.matrixWorld.copy(this.matrix);
							} else {
								this.matrixWorld.multiplyMatrices(
									this.parent.matrixWorld,
									this.matrix
								);
							}
						}

						// make sure descendants are updated

						if (updateChildren === true) {
							const children = this.children;

							for (let i = 0, l = children.length; i < l; i++) {
								const child = children[i];

								child.updateWorldMatrix(false, true);
							}
						}
					}

					toJSON(meta) {
						// meta is a string when called from JSON.stringify
						const isRootObject = meta === undefined || typeof meta === "string";

						const output = {};

						// meta is a hash used to collect geometries, materials.
						// not providing it implies that this is the root object
						// being serialized.
						if (isRootObject) {
							// initialize meta obj
							meta = {
								geometries: {},
								materials: {},
								textures: {},
								images: {},
								shapes: {},
								skeletons: {},
								animations: {},
								nodes: {}
							};

							output.metadata = {
								version: 4.6,
								type: "Object",
								generator: "Object3D.toJSON"
							};
						}

						// standard Object3D serialization

						const object = {};

						object.uuid = this.uuid;
						object.type = this.type;

						if (this.name !== "") object.name = this.name;
						if (this.castShadow === true) object.castShadow = true;
						if (this.receiveShadow === true) object.receiveShadow = true;
						if (this.visible === false) object.visible = false;
						if (this.frustumCulled === false) object.frustumCulled = false;
						if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
						if (Object.keys(this.userData).length > 0)
							object.userData = this.userData;

						object.layers = this.layers.mask;
						object.matrix = this.matrix.toArray();
						object.up = this.up.toArray();

						if (this.matrixAutoUpdate === false)
							object.matrixAutoUpdate = false;

						// object specific properties

						if (this.isInstancedMesh) {
							object.type = "InstancedMesh";
							object.count = this.count;
							object.instanceMatrix = this.instanceMatrix.toJSON();
							if (this.instanceColor !== null)
								object.instanceColor = this.instanceColor.toJSON();
						}

						if (this.isBatchedMesh) {
							object.type = "BatchedMesh";
							object.perObjectFrustumCulled = this.perObjectFrustumCulled;
							object.sortObjects = this.sortObjects;

							object.drawRanges = this._drawRanges;
							object.reservedRanges = this._reservedRanges;

							object.visibility = this._visibility;
							object.active = this._active;
							object.bounds = this._bounds.map(bound => ({
								boxInitialized: bound.boxInitialized,
								boxMin: bound.box.min.toArray(),
								boxMax: bound.box.max.toArray(),

								sphereInitialized: bound.sphereInitialized,
								sphereRadius: bound.sphere.radius,
								sphereCenter: bound.sphere.center.toArray()
							}));

							object.maxInstanceCount = this._maxInstanceCount;
							object.maxVertexCount = this._maxVertexCount;
							object.maxIndexCount = this._maxIndexCount;

							object.geometryInitialized = this._geometryInitialized;
							object.geometryCount = this._geometryCount;

							object.matricesTexture = this._matricesTexture.toJSON(meta);

							if (this._colorsTexture !== null)
								object.colorsTexture = this._colorsTexture.toJSON(meta);

							if (this.boundingSphere !== null) {
								object.boundingSphere = {
									center: object.boundingSphere.center.toArray(),
									radius: object.boundingSphere.radius
								};
							}

							if (this.boundingBox !== null) {
								object.boundingBox = {
									min: object.boundingBox.min.toArray(),
									max: object.boundingBox.max.toArray()
								};
							}
						}

						//

						function serialize(library, element) {
							if (library[element.uuid] === undefined) {
								library[element.uuid] = element.toJSON(meta);
							}

							return element.uuid;
						}

						if (this.isScene) {
							if (this.background) {
								if (this.background.isColor) {
									object.background = this.background.toJSON();
								} else if (this.background.isTexture) {
									object.background = this.background.toJSON(meta).uuid;
								}
							}

							if (
								this.environment &&
								this.environment.isTexture &&
								this.environment.isRenderTargetTexture !== true
							) {
								object.environment = this.environment.toJSON(meta).uuid;
							}
						} else if (this.isMesh || this.isLine || this.isPoints) {
							object.geometry = serialize(meta.geometries, this.geometry);

							const parameters = this.geometry.parameters;

							if (parameters !== undefined && parameters.shapes !== undefined) {
								const shapes = parameters.shapes;

								if (Array.isArray(shapes)) {
									for (let i = 0, l = shapes.length; i < l; i++) {
										const shape = shapes[i];

										serialize(meta.shapes, shape);
									}
								} else {
									serialize(meta.shapes, shapes);
								}
							}
						}

						if (this.isSkinnedMesh) {
							object.bindMode = this.bindMode;
							object.bindMatrix = this.bindMatrix.toArray();

							if (this.skeleton !== undefined) {
								serialize(meta.skeletons, this.skeleton);

								object.skeleton = this.skeleton.uuid;
							}
						}

						if (this.material !== undefined) {
							if (Array.isArray(this.material)) {
								const uuids = [];

								for (let i = 0, l = this.material.length; i < l; i++) {
									uuids.push(serialize(meta.materials, this.material[i]));
								}

								object.material = uuids;
							} else {
								object.material = serialize(meta.materials, this.material);
							}
						}

						//

						if (this.children.length > 0) {
							object.children = [];

							for (let i = 0; i < this.children.length; i++) {
								object.children.push(this.children[i].toJSON(meta).object);
							}
						}

						//

						if (this.animations.length > 0) {
							object.animations = [];

							for (let i = 0; i < this.animations.length; i++) {
								const animation = this.animations[i];

								object.animations.push(serialize(meta.animations, animation));
							}
						}

						if (isRootObject) {
							const geometries = extractFromCache(meta.geometries);
							const materials = extractFromCache(meta.materials);
							const textures = extractFromCache(meta.textures);
							const images = extractFromCache(meta.images);
							const shapes = extractFromCache(meta.shapes);
							const skeletons = extractFromCache(meta.skeletons);
							const animations = extractFromCache(meta.animations);
							const nodes = extractFromCache(meta.nodes);

							if (geometries.length > 0) output.geometries = geometries;
							if (materials.length > 0) output.materials = materials;
							if (textures.length > 0) output.textures = textures;
							if (images.length > 0) output.images = images;
							if (shapes.length > 0) output.shapes = shapes;
							if (skeletons.length > 0) output.skeletons = skeletons;
							if (animations.length > 0) output.animations = animations;
							if (nodes.length > 0) output.nodes = nodes;
						}

						output.object = object;

						return output;

						// extract data from the cache hash
						// remove metadata on each item
						// and return as array
						function extractFromCache(cache) {
							const values = [];
							for (const key in cache) {
								const data = cache[key];
								delete data.metadata;
								values.push(data);
							}

							return values;
						}
					}

					clone(recursive) {
						return new this.constructor().copy(this, recursive);
					}

					copy(source, recursive = true) {
						this.name = source.name;

						this.up.copy(source.up);

						this.position.copy(source.position);
						this.rotation.order = source.rotation.order;
						this.quaternion.copy(source.quaternion);
						this.scale.copy(source.scale);

						this.matrix.copy(source.matrix);
						this.matrixWorld.copy(source.matrixWorld);

						this.matrixAutoUpdate = source.matrixAutoUpdate;

						this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
						this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

						this.layers.mask = source.layers.mask;
						this.visible = source.visible;

						this.castShadow = source.castShadow;
						this.receiveShadow = source.receiveShadow;

						this.frustumCulled = source.frustumCulled;
						this.renderOrder = source.renderOrder;

						this.animations = source.animations.slice();

						this.userData = JSON.parse(JSON.stringify(source.userData));

						if (recursive === true) {
							for (let i = 0; i < source.children.length; i++) {
								const child = source.children[i];
								this.add(child.clone());
							}
						}

						return this;
					}
				}

				Object3D.DEFAULT_UP =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(
						0,
						1,
						0
					);
				Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
				Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/extras/DataUtils.js":
			/*!*****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/extras/DataUtils.js ***!
  \*****************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					fromHalfFloat: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.fromHalfFloat"] */ fromHalfFloat,
					toHalfFloat: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.toHalfFloat"] */ toHalfFloat
				});
				/* ESM import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/MathUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/MathUtils.js"
					);

				// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf

				const _tables = /*@__PURE__*/ _generateTables();

				function _generateTables() {
					// float32 to float16 helpers

					const buffer = new ArrayBuffer(4);
					const floatView = new Float32Array(buffer);
					const uint32View = new Uint32Array(buffer);

					const baseTable = new Uint32Array(512);
					const shiftTable = new Uint32Array(512);

					for (let i = 0; i < 256; ++i) {
						const e = i - 127;

						// very small number (0, -0)

						if (e < -27) {
							baseTable[i] = 0x0000;
							baseTable[i | 0x100] = 0x8000;
							shiftTable[i] = 24;
							shiftTable[i | 0x100] = 24;

							// small number (denorm)
						} else if (e < -14) {
							baseTable[i] = 0x0400 >> (-e - 14);
							baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;
							shiftTable[i] = -e - 1;
							shiftTable[i | 0x100] = -e - 1;

							// normal number
						} else if (e <= 15) {
							baseTable[i] = (e + 15) << 10;
							baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;
							shiftTable[i] = 13;
							shiftTable[i | 0x100] = 13;

							// large number (Infinity, -Infinity)
						} else if (e < 128) {
							baseTable[i] = 0x7c00;
							baseTable[i | 0x100] = 0xfc00;
							shiftTable[i] = 24;
							shiftTable[i | 0x100] = 24;

							// stay (NaN, Infinity, -Infinity)
						} else {
							baseTable[i] = 0x7c00;
							baseTable[i | 0x100] = 0xfc00;
							shiftTable[i] = 13;
							shiftTable[i | 0x100] = 13;
						}
					}

					// float16 to float32 helpers

					const mantissaTable = new Uint32Array(2048);
					const exponentTable = new Uint32Array(64);
					const offsetTable = new Uint32Array(64);

					for (let i = 1; i < 1024; ++i) {
						let m = i << 13; // zero pad mantissa bits
						let e = 0; // zero exponent

						// normalized
						while ((m & 0x00800000) === 0) {
							m <<= 1;
							e -= 0x00800000; // decrement exponent
						}

						m &= ~0x00800000; // clear leading 1 bit
						e += 0x38800000; // adjust bias

						mantissaTable[i] = m | e;
					}

					for (let i = 1024; i < 2048; ++i) {
						mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);
					}

					for (let i = 1; i < 31; ++i) {
						exponentTable[i] = i << 23;
					}

					exponentTable[31] = 0x47800000;
					exponentTable[32] = 0x80000000;

					for (let i = 33; i < 63; ++i) {
						exponentTable[i] = 0x80000000 + ((i - 32) << 23);
					}

					exponentTable[63] = 0xc7800000;

					for (let i = 1; i < 64; ++i) {
						if (i !== 32) {
							offsetTable[i] = 1024;
						}
					}

					return {
						floatView: floatView,
						uint32View: uint32View,
						baseTable: baseTable,
						shiftTable: shiftTable,
						mantissaTable: mantissaTable,
						exponentTable: exponentTable,
						offsetTable: offsetTable
					};
				}

				// float32 to float16

				function toHalfFloat(val) {
					if (Math.abs(val) > 65504)
						console.warn("THREE.DataUtils.toHalfFloat(): Value out of range.");

					val = (0, _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__.clamp)(
						val,
						-65504,
						65504
					);

					_tables.floatView[0] = val;
					const f = _tables.uint32View[0];
					const e = (f >> 23) & 0x1ff;
					return (
						_tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e])
					);
				}

				// float16 to float32

				function fromHalfFloat(val) {
					const m = val >> 10;
					_tables.uint32View[0] =
						_tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] +
						_tables.exponentTable[m];
					return _tables.floatView[0];
				}

				const DataUtils = /* unused pure expression or super */ null && {
					toHalfFloat: toHalfFloat,
					fromHalfFloat: fromHalfFloat
				};
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/materials/LineBasicMaterial.js":
			/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/materials/LineBasicMaterial.js ***!
  \****************************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					LineBasicMaterial: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.LineBasicMaterial"] */ LineBasicMaterial
				});
				/* ESM import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Material.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/materials/Material.js"
					);
				/* ESM import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Color.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Color.js"
					);

				class LineBasicMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__.Material {
					constructor(parameters) {
						super();

						this.isLineBasicMaterial = true;

						this.type = "LineBasicMaterial";

						this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_1__.Color(
							0xffffff
						);

						this.map = null;

						this.linewidth = 1;
						this.linecap = "round";
						this.linejoin = "round";

						this.fog = true;

						this.setValues(parameters);
					}

					copy(source) {
						super.copy(source);

						this.color.copy(source.color);

						this.map = source.map;

						this.linewidth = source.linewidth;
						this.linecap = source.linecap;
						this.linejoin = source.linejoin;

						this.fog = source.fog;

						return this;
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/materials/Material.js":
			/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/materials/Material.js ***!
  \*******************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Material: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Material"] */ Material
				});
				/* ESM import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_3__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Color.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Color.js"
					);
				/* ESM import */ var _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../core/EventDispatcher.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/EventDispatcher.js"
					);
				/* ESM import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../constants.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js"
					);
				/* ESM import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/MathUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/MathUtils.js"
					);

				let _materialId = 0;

				class Material extends _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {
					constructor() {
						super();

						this.isMaterial = true;

						Object.defineProperty(this, "id", { value: _materialId++ });

						this.uuid =
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__.generateUUID();

						this.name = "";
						this.type = "Material";

						this.blending =
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.NormalBlending;
						this.side = _constants_js__WEBPACK_IMPORTED_MODULE_2__.FrontSide;
						this.vertexColors = false;

						this.opacity = 1;
						this.transparent = false;
						this.alphaHash = false;

						this.blendSrc =
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.SrcAlphaFactor;
						this.blendDst =
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.OneMinusSrcAlphaFactor;
						this.blendEquation =
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.AddEquation;
						this.blendSrcAlpha = null;
						this.blendDstAlpha = null;
						this.blendEquationAlpha = null;
						this.blendColor =
							new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__.Color(0, 0, 0);
						this.blendAlpha = 0;

						this.depthFunc =
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.LessEqualDepth;
						this.depthTest = true;
						this.depthWrite = true;

						this.stencilWriteMask = 0xff;
						this.stencilFunc =
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.AlwaysStencilFunc;
						this.stencilRef = 0;
						this.stencilFuncMask = 0xff;
						this.stencilFail =
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.KeepStencilOp;
						this.stencilZFail =
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.KeepStencilOp;
						this.stencilZPass =
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.KeepStencilOp;
						this.stencilWrite = false;

						this.clippingPlanes = null;
						this.clipIntersection = false;
						this.clipShadows = false;

						this.shadowSide = null;

						this.colorWrite = true;

						this.precision = null; // override the renderer's default precision for this material

						this.polygonOffset = false;
						this.polygonOffsetFactor = 0;
						this.polygonOffsetUnits = 0;

						this.dithering = false;

						this.alphaToCoverage = false;
						this.premultipliedAlpha = false;
						this.forceSinglePass = false;

						this.visible = true;

						this.toneMapped = true;

						this.userData = {};

						this.version = 0;

						this._alphaTest = 0;
					}

					get alphaTest() {
						return this._alphaTest;
					}

					set alphaTest(value) {
						if (this._alphaTest > 0 !== value > 0) {
							this.version++;
						}

						this._alphaTest = value;
					}

					// onBeforeRender and onBeforeCompile only supported in WebGLRenderer

					onBeforeRender(/* renderer, scene, camera, geometry, object, group */) {}

					onBeforeCompile(/* shaderobject, renderer */) {}

					customProgramCacheKey() {
						return this.onBeforeCompile.toString();
					}

					setValues(values) {
						if (values === undefined) return;

						for (const key in values) {
							const newValue = values[key];

							if (newValue === undefined) {
								console.warn(
									`THREE.Material: parameter '${key}' has value of undefined.`
								);
								continue;
							}

							const currentValue = this[key];

							if (currentValue === undefined) {
								console.warn(
									`THREE.Material: '${key}' is not a property of THREE.${this.type}.`
								);
								continue;
							}

							if (currentValue && currentValue.isColor) {
								currentValue.set(newValue);
							} else if (
								currentValue &&
								currentValue.isVector3 &&
								newValue &&
								newValue.isVector3
							) {
								currentValue.copy(newValue);
							} else {
								this[key] = newValue;
							}
						}
					}

					toJSON(meta) {
						const isRootObject = meta === undefined || typeof meta === "string";

						if (isRootObject) {
							meta = {
								textures: {},
								images: {}
							};
						}

						const data = {
							metadata: {
								version: 4.6,
								type: "Material",
								generator: "Material.toJSON"
							}
						};

						// standard Material serialization
						data.uuid = this.uuid;
						data.type = this.type;

						if (this.name !== "") data.name = this.name;

						if (this.color && this.color.isColor)
							data.color = this.color.getHex();

						if (this.roughness !== undefined) data.roughness = this.roughness;
						if (this.metalness !== undefined) data.metalness = this.metalness;

						if (this.sheen !== undefined) data.sheen = this.sheen;
						if (this.sheenColor && this.sheenColor.isColor)
							data.sheenColor = this.sheenColor.getHex();
						if (this.sheenRoughness !== undefined)
							data.sheenRoughness = this.sheenRoughness;
						if (this.emissive && this.emissive.isColor)
							data.emissive = this.emissive.getHex();
						if (
							this.emissiveIntensity !== undefined &&
							this.emissiveIntensity !== 1
						)
							data.emissiveIntensity = this.emissiveIntensity;

						if (this.specular && this.specular.isColor)
							data.specular = this.specular.getHex();
						if (this.specularIntensity !== undefined)
							data.specularIntensity = this.specularIntensity;
						if (this.specularColor && this.specularColor.isColor)
							data.specularColor = this.specularColor.getHex();
						if (this.shininess !== undefined) data.shininess = this.shininess;
						if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
						if (this.clearcoatRoughness !== undefined)
							data.clearcoatRoughness = this.clearcoatRoughness;

						if (this.clearcoatMap && this.clearcoatMap.isTexture) {
							data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
						}

						if (
							this.clearcoatRoughnessMap &&
							this.clearcoatRoughnessMap.isTexture
						) {
							data.clearcoatRoughnessMap =
								this.clearcoatRoughnessMap.toJSON(meta).uuid;
						}

						if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
							data.clearcoatNormalMap =
								this.clearcoatNormalMap.toJSON(meta).uuid;
							data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
						}

						if (this.dispersion !== undefined)
							data.dispersion = this.dispersion;

						if (this.iridescence !== undefined)
							data.iridescence = this.iridescence;
						if (this.iridescenceIOR !== undefined)
							data.iridescenceIOR = this.iridescenceIOR;
						if (this.iridescenceThicknessRange !== undefined)
							data.iridescenceThicknessRange = this.iridescenceThicknessRange;

						if (this.iridescenceMap && this.iridescenceMap.isTexture) {
							data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
						}

						if (
							this.iridescenceThicknessMap &&
							this.iridescenceThicknessMap.isTexture
						) {
							data.iridescenceThicknessMap =
								this.iridescenceThicknessMap.toJSON(meta).uuid;
						}

						if (this.anisotropy !== undefined)
							data.anisotropy = this.anisotropy;
						if (this.anisotropyRotation !== undefined)
							data.anisotropyRotation = this.anisotropyRotation;

						if (this.anisotropyMap && this.anisotropyMap.isTexture) {
							data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
						}

						if (this.map && this.map.isTexture)
							data.map = this.map.toJSON(meta).uuid;
						if (this.matcap && this.matcap.isTexture)
							data.matcap = this.matcap.toJSON(meta).uuid;
						if (this.alphaMap && this.alphaMap.isTexture)
							data.alphaMap = this.alphaMap.toJSON(meta).uuid;

						if (this.lightMap && this.lightMap.isTexture) {
							data.lightMap = this.lightMap.toJSON(meta).uuid;
							data.lightMapIntensity = this.lightMapIntensity;
						}

						if (this.aoMap && this.aoMap.isTexture) {
							data.aoMap = this.aoMap.toJSON(meta).uuid;
							data.aoMapIntensity = this.aoMapIntensity;
						}

						if (this.bumpMap && this.bumpMap.isTexture) {
							data.bumpMap = this.bumpMap.toJSON(meta).uuid;
							data.bumpScale = this.bumpScale;
						}

						if (this.normalMap && this.normalMap.isTexture) {
							data.normalMap = this.normalMap.toJSON(meta).uuid;
							data.normalMapType = this.normalMapType;
							data.normalScale = this.normalScale.toArray();
						}

						if (this.displacementMap && this.displacementMap.isTexture) {
							data.displacementMap = this.displacementMap.toJSON(meta).uuid;
							data.displacementScale = this.displacementScale;
							data.displacementBias = this.displacementBias;
						}

						if (this.roughnessMap && this.roughnessMap.isTexture)
							data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
						if (this.metalnessMap && this.metalnessMap.isTexture)
							data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;

						if (this.emissiveMap && this.emissiveMap.isTexture)
							data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
						if (this.specularMap && this.specularMap.isTexture)
							data.specularMap = this.specularMap.toJSON(meta).uuid;
						if (
							this.specularIntensityMap &&
							this.specularIntensityMap.isTexture
						)
							data.specularIntensityMap =
								this.specularIntensityMap.toJSON(meta).uuid;
						if (this.specularColorMap && this.specularColorMap.isTexture)
							data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;

						if (this.envMap && this.envMap.isTexture) {
							data.envMap = this.envMap.toJSON(meta).uuid;

							if (this.combine !== undefined) data.combine = this.combine;
						}

						if (this.envMapRotation !== undefined)
							data.envMapRotation = this.envMapRotation.toArray();
						if (this.envMapIntensity !== undefined)
							data.envMapIntensity = this.envMapIntensity;
						if (this.reflectivity !== undefined)
							data.reflectivity = this.reflectivity;
						if (this.refractionRatio !== undefined)
							data.refractionRatio = this.refractionRatio;

						if (this.gradientMap && this.gradientMap.isTexture) {
							data.gradientMap = this.gradientMap.toJSON(meta).uuid;
						}

						if (this.transmission !== undefined)
							data.transmission = this.transmission;
						if (this.transmissionMap && this.transmissionMap.isTexture)
							data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
						if (this.thickness !== undefined) data.thickness = this.thickness;
						if (this.thicknessMap && this.thicknessMap.isTexture)
							data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
						if (
							this.attenuationDistance !== undefined &&
							this.attenuationDistance !== Infinity
						)
							data.attenuationDistance = this.attenuationDistance;
						if (this.attenuationColor !== undefined)
							data.attenuationColor = this.attenuationColor.getHex();

						if (this.size !== undefined) data.size = this.size;
						if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
						if (this.sizeAttenuation !== undefined)
							data.sizeAttenuation = this.sizeAttenuation;

						if (
							this.blending !==
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.NormalBlending
						)
							data.blending = this.blending;
						if (
							this.side !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.FrontSide
						)
							data.side = this.side;
						if (this.vertexColors === true) data.vertexColors = true;

						if (this.opacity < 1) data.opacity = this.opacity;
						if (this.transparent === true) data.transparent = true;

						if (
							this.blendSrc !==
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.SrcAlphaFactor
						)
							data.blendSrc = this.blendSrc;
						if (
							this.blendDst !==
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.OneMinusSrcAlphaFactor
						)
							data.blendDst = this.blendDst;
						if (
							this.blendEquation !==
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.AddEquation
						)
							data.blendEquation = this.blendEquation;
						if (this.blendSrcAlpha !== null)
							data.blendSrcAlpha = this.blendSrcAlpha;
						if (this.blendDstAlpha !== null)
							data.blendDstAlpha = this.blendDstAlpha;
						if (this.blendEquationAlpha !== null)
							data.blendEquationAlpha = this.blendEquationAlpha;
						if (this.blendColor && this.blendColor.isColor)
							data.blendColor = this.blendColor.getHex();
						if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;

						if (
							this.depthFunc !==
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.LessEqualDepth
						)
							data.depthFunc = this.depthFunc;
						if (this.depthTest === false) data.depthTest = this.depthTest;
						if (this.depthWrite === false) data.depthWrite = this.depthWrite;
						if (this.colorWrite === false) data.colorWrite = this.colorWrite;

						if (this.stencilWriteMask !== 0xff)
							data.stencilWriteMask = this.stencilWriteMask;
						if (
							this.stencilFunc !==
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.AlwaysStencilFunc
						)
							data.stencilFunc = this.stencilFunc;
						if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
						if (this.stencilFuncMask !== 0xff)
							data.stencilFuncMask = this.stencilFuncMask;
						if (
							this.stencilFail !==
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.KeepStencilOp
						)
							data.stencilFail = this.stencilFail;
						if (
							this.stencilZFail !==
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.KeepStencilOp
						)
							data.stencilZFail = this.stencilZFail;
						if (
							this.stencilZPass !==
							_constants_js__WEBPACK_IMPORTED_MODULE_2__.KeepStencilOp
						)
							data.stencilZPass = this.stencilZPass;
						if (this.stencilWrite === true)
							data.stencilWrite = this.stencilWrite;

						// rotation (SpriteMaterial)
						if (this.rotation !== undefined && this.rotation !== 0)
							data.rotation = this.rotation;

						if (this.polygonOffset === true) data.polygonOffset = true;
						if (this.polygonOffsetFactor !== 0)
							data.polygonOffsetFactor = this.polygonOffsetFactor;
						if (this.polygonOffsetUnits !== 0)
							data.polygonOffsetUnits = this.polygonOffsetUnits;

						if (this.linewidth !== undefined && this.linewidth !== 1)
							data.linewidth = this.linewidth;
						if (this.dashSize !== undefined) data.dashSize = this.dashSize;
						if (this.gapSize !== undefined) data.gapSize = this.gapSize;
						if (this.scale !== undefined) data.scale = this.scale;

						if (this.dithering === true) data.dithering = true;

						if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
						if (this.alphaHash === true) data.alphaHash = true;
						if (this.alphaToCoverage === true) data.alphaToCoverage = true;
						if (this.premultipliedAlpha === true)
							data.premultipliedAlpha = true;
						if (this.forceSinglePass === true) data.forceSinglePass = true;

						if (this.wireframe === true) data.wireframe = true;
						if (this.wireframeLinewidth > 1)
							data.wireframeLinewidth = this.wireframeLinewidth;
						if (this.wireframeLinecap !== "round")
							data.wireframeLinecap = this.wireframeLinecap;
						if (this.wireframeLinejoin !== "round")
							data.wireframeLinejoin = this.wireframeLinejoin;

						if (this.flatShading === true) data.flatShading = true;

						if (this.visible === false) data.visible = false;

						if (this.toneMapped === false) data.toneMapped = false;

						if (this.fog === false) data.fog = false;

						if (Object.keys(this.userData).length > 0)
							data.userData = this.userData;

						// TODO: Copied from Object3D.toJSON

						function extractFromCache(cache) {
							const values = [];

							for (const key in cache) {
								const data = cache[key];
								delete data.metadata;
								values.push(data);
							}

							return values;
						}

						if (isRootObject) {
							const textures = extractFromCache(meta.textures);
							const images = extractFromCache(meta.images);

							if (textures.length > 0) data.textures = textures;
							if (images.length > 0) data.images = images;
						}

						return data;
					}

					clone() {
						return new this.constructor().copy(this);
					}

					copy(source) {
						this.name = source.name;

						this.blending = source.blending;
						this.side = source.side;
						this.vertexColors = source.vertexColors;

						this.opacity = source.opacity;
						this.transparent = source.transparent;

						this.blendSrc = source.blendSrc;
						this.blendDst = source.blendDst;
						this.blendEquation = source.blendEquation;
						this.blendSrcAlpha = source.blendSrcAlpha;
						this.blendDstAlpha = source.blendDstAlpha;
						this.blendEquationAlpha = source.blendEquationAlpha;
						this.blendColor.copy(source.blendColor);
						this.blendAlpha = source.blendAlpha;

						this.depthFunc = source.depthFunc;
						this.depthTest = source.depthTest;
						this.depthWrite = source.depthWrite;

						this.stencilWriteMask = source.stencilWriteMask;
						this.stencilFunc = source.stencilFunc;
						this.stencilRef = source.stencilRef;
						this.stencilFuncMask = source.stencilFuncMask;
						this.stencilFail = source.stencilFail;
						this.stencilZFail = source.stencilZFail;
						this.stencilZPass = source.stencilZPass;
						this.stencilWrite = source.stencilWrite;

						const srcPlanes = source.clippingPlanes;
						let dstPlanes = null;

						if (srcPlanes !== null) {
							const n = srcPlanes.length;
							dstPlanes = new Array(n);

							for (let i = 0; i !== n; ++i) {
								dstPlanes[i] = srcPlanes[i].clone();
							}
						}

						this.clippingPlanes = dstPlanes;
						this.clipIntersection = source.clipIntersection;
						this.clipShadows = source.clipShadows;

						this.shadowSide = source.shadowSide;

						this.colorWrite = source.colorWrite;

						this.precision = source.precision;

						this.polygonOffset = source.polygonOffset;
						this.polygonOffsetFactor = source.polygonOffsetFactor;
						this.polygonOffsetUnits = source.polygonOffsetUnits;

						this.dithering = source.dithering;

						this.alphaTest = source.alphaTest;
						this.alphaHash = source.alphaHash;
						this.alphaToCoverage = source.alphaToCoverage;
						this.premultipliedAlpha = source.premultipliedAlpha;
						this.forceSinglePass = source.forceSinglePass;

						this.visible = source.visible;

						this.toneMapped = source.toneMapped;

						this.userData = JSON.parse(JSON.stringify(source.userData));

						return this;
					}

					dispose() {
						this.dispatchEvent({ type: "dispose" });
					}

					set needsUpdate(value) {
						if (value === true) this.version++;
					}

					onBuild(/* shaderobject, renderer */) {
						console.warn("Material: onBuild() has been removed."); // @deprecated, r166
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Box3.js":
			/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Box3.js ***!
  \**********************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Box3: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Box3"] */ Box3
				});
				/* ESM import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Vector3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector3.js"
					);

				class Box3 {
					constructor(
						min = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(
							+Infinity,
							+Infinity,
							+Infinity
						),
						max = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(
							-Infinity,
							-Infinity,
							-Infinity
						)
					) {
						this.isBox3 = true;

						this.min = min;
						this.max = max;
					}

					set(min, max) {
						this.min.copy(min);
						this.max.copy(max);

						return this;
					}

					setFromArray(array) {
						this.makeEmpty();

						for (let i = 0, il = array.length; i < il; i += 3) {
							this.expandByPoint(_vector.fromArray(array, i));
						}

						return this;
					}

					setFromBufferAttribute(attribute) {
						this.makeEmpty();

						for (let i = 0, il = attribute.count; i < il; i++) {
							this.expandByPoint(_vector.fromBufferAttribute(attribute, i));
						}

						return this;
					}

					setFromPoints(points) {
						this.makeEmpty();

						for (let i = 0, il = points.length; i < il; i++) {
							this.expandByPoint(points[i]);
						}

						return this;
					}

					setFromCenterAndSize(center, size) {
						const halfSize = _vector.copy(size).multiplyScalar(0.5);

						this.min.copy(center).sub(halfSize);
						this.max.copy(center).add(halfSize);

						return this;
					}

					setFromObject(object, precise = false) {
						this.makeEmpty();

						return this.expandByObject(object, precise);
					}

					clone() {
						return new this.constructor().copy(this);
					}

					copy(box) {
						this.min.copy(box.min);
						this.max.copy(box.max);

						return this;
					}

					makeEmpty() {
						this.min.x = this.min.y = this.min.z = +Infinity;
						this.max.x = this.max.y = this.max.z = -Infinity;

						return this;
					}

					isEmpty() {
						// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

						return (
							this.max.x < this.min.x ||
							this.max.y < this.min.y ||
							this.max.z < this.min.z
						);
					}

					getCenter(target) {
						return this.isEmpty()
							? target.set(0, 0, 0)
							: target.addVectors(this.min, this.max).multiplyScalar(0.5);
					}

					getSize(target) {
						return this.isEmpty()
							? target.set(0, 0, 0)
							: target.subVectors(this.max, this.min);
					}

					expandByPoint(point) {
						this.min.min(point);
						this.max.max(point);

						return this;
					}

					expandByVector(vector) {
						this.min.sub(vector);
						this.max.add(vector);

						return this;
					}

					expandByScalar(scalar) {
						this.min.addScalar(-scalar);
						this.max.addScalar(scalar);

						return this;
					}

					expandByObject(object, precise = false) {
						// Computes the world-axis-aligned bounding box of an object (including its children),
						// accounting for both the object's, and children's, world transforms

						object.updateWorldMatrix(false, false);

						const geometry = object.geometry;

						if (geometry !== undefined) {
							const positionAttribute = geometry.getAttribute("position");

							// precise AABB computation based on vertex data requires at least a position attribute.
							// instancing isn't supported so far and uses the normal (conservative) code path.

							if (
								precise === true &&
								positionAttribute !== undefined &&
								object.isInstancedMesh !== true
							) {
								for (let i = 0, l = positionAttribute.count; i < l; i++) {
									if (object.isMesh === true) {
										object.getVertexPosition(i, _vector);
									} else {
										_vector.fromBufferAttribute(positionAttribute, i);
									}

									_vector.applyMatrix4(object.matrixWorld);
									this.expandByPoint(_vector);
								}
							} else {
								if (object.boundingBox !== undefined) {
									// object-level bounding box

									if (object.boundingBox === null) {
										object.computeBoundingBox();
									}

									_box.copy(object.boundingBox);
								} else {
									// geometry-level bounding box

									if (geometry.boundingBox === null) {
										geometry.computeBoundingBox();
									}

									_box.copy(geometry.boundingBox);
								}

								_box.applyMatrix4(object.matrixWorld);

								this.union(_box);
							}
						}

						const children = object.children;

						for (let i = 0, l = children.length; i < l; i++) {
							this.expandByObject(children[i], precise);
						}

						return this;
					}

					containsPoint(point) {
						return (
							point.x >= this.min.x &&
							point.x <= this.max.x &&
							point.y >= this.min.y &&
							point.y <= this.max.y &&
							point.z >= this.min.z &&
							point.z <= this.max.z
						);
					}

					containsBox(box) {
						return (
							this.min.x <= box.min.x &&
							box.max.x <= this.max.x &&
							this.min.y <= box.min.y &&
							box.max.y <= this.max.y &&
							this.min.z <= box.min.z &&
							box.max.z <= this.max.z
						);
					}

					getParameter(point, target) {
						// This can potentially have a divide by zero if the box
						// has a size dimension of 0.

						return target.set(
							(point.x - this.min.x) / (this.max.x - this.min.x),
							(point.y - this.min.y) / (this.max.y - this.min.y),
							(point.z - this.min.z) / (this.max.z - this.min.z)
						);
					}

					intersectsBox(box) {
						// using 6 splitting planes to rule out intersections.
						return (
							box.max.x >= this.min.x &&
							box.min.x <= this.max.x &&
							box.max.y >= this.min.y &&
							box.min.y <= this.max.y &&
							box.max.z >= this.min.z &&
							box.min.z <= this.max.z
						);
					}

					intersectsSphere(sphere) {
						// Find the point on the AABB closest to the sphere center.
						this.clampPoint(sphere.center, _vector);

						// If that point is inside the sphere, the AABB and sphere intersect.
						return (
							_vector.distanceToSquared(sphere.center) <=
							sphere.radius * sphere.radius
						);
					}

					intersectsPlane(plane) {
						// We compute the minimum and maximum dot product values. If those values
						// are on the same side (back or front) of the plane, then there is no intersection.

						let min, max;

						if (plane.normal.x > 0) {
							min = plane.normal.x * this.min.x;
							max = plane.normal.x * this.max.x;
						} else {
							min = plane.normal.x * this.max.x;
							max = plane.normal.x * this.min.x;
						}

						if (plane.normal.y > 0) {
							min += plane.normal.y * this.min.y;
							max += plane.normal.y * this.max.y;
						} else {
							min += plane.normal.y * this.max.y;
							max += plane.normal.y * this.min.y;
						}

						if (plane.normal.z > 0) {
							min += plane.normal.z * this.min.z;
							max += plane.normal.z * this.max.z;
						} else {
							min += plane.normal.z * this.max.z;
							max += plane.normal.z * this.min.z;
						}

						return min <= -plane.constant && max >= -plane.constant;
					}

					intersectsTriangle(triangle) {
						if (this.isEmpty()) {
							return false;
						}

						// compute box center and extents
						this.getCenter(_center);
						_extents.subVectors(this.max, _center);

						// translate triangle to aabb origin
						_v0.subVectors(triangle.a, _center);
						_v1.subVectors(triangle.b, _center);
						_v2.subVectors(triangle.c, _center);

						// compute edge vectors for triangle
						_f0.subVectors(_v1, _v0);
						_f1.subVectors(_v2, _v1);
						_f2.subVectors(_v0, _v2);

						// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
						// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
						// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
						let axes = [
							0,
							-_f0.z,
							_f0.y,
							0,
							-_f1.z,
							_f1.y,
							0,
							-_f2.z,
							_f2.y,
							_f0.z,
							0,
							-_f0.x,
							_f1.z,
							0,
							-_f1.x,
							_f2.z,
							0,
							-_f2.x,
							-_f0.y,
							_f0.x,
							0,
							-_f1.y,
							_f1.x,
							0,
							-_f2.y,
							_f2.x,
							0
						];
						if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
							return false;
						}

						// test 3 face normals from the aabb
						axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
						if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
							return false;
						}

						// finally testing the face normal of the triangle
						// use already existing triangle edge vectors here
						_triangleNormal.crossVectors(_f0, _f1);
						axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];

						return satForAxes(axes, _v0, _v1, _v2, _extents);
					}

					clampPoint(point, target) {
						return target.copy(point).clamp(this.min, this.max);
					}

					distanceToPoint(point) {
						return this.clampPoint(point, _vector).distanceTo(point);
					}

					getBoundingSphere(target) {
						if (this.isEmpty()) {
							target.makeEmpty();
						} else {
							this.getCenter(target.center);

							target.radius = this.getSize(_vector).length() * 0.5;
						}

						return target;
					}

					intersect(box) {
						this.min.max(box.min);
						this.max.min(box.max);

						// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
						if (this.isEmpty()) this.makeEmpty();

						return this;
					}

					union(box) {
						this.min.min(box.min);
						this.max.max(box.max);

						return this;
					}

					applyMatrix4(matrix) {
						// transform of empty box is an empty box.
						if (this.isEmpty()) return this;

						// NOTE: I am using a binary pattern to specify all 2^3 combinations below
						_points[0]
							.set(this.min.x, this.min.y, this.min.z)
							.applyMatrix4(matrix); // 000
						_points[1]
							.set(this.min.x, this.min.y, this.max.z)
							.applyMatrix4(matrix); // 001
						_points[2]
							.set(this.min.x, this.max.y, this.min.z)
							.applyMatrix4(matrix); // 010
						_points[3]
							.set(this.min.x, this.max.y, this.max.z)
							.applyMatrix4(matrix); // 011
						_points[4]
							.set(this.max.x, this.min.y, this.min.z)
							.applyMatrix4(matrix); // 100
						_points[5]
							.set(this.max.x, this.min.y, this.max.z)
							.applyMatrix4(matrix); // 101
						_points[6]
							.set(this.max.x, this.max.y, this.min.z)
							.applyMatrix4(matrix); // 110
						_points[7]
							.set(this.max.x, this.max.y, this.max.z)
							.applyMatrix4(matrix); // 111

						this.setFromPoints(_points);

						return this;
					}

					translate(offset) {
						this.min.add(offset);
						this.max.add(offset);

						return this;
					}

					equals(box) {
						return box.min.equals(this.min) && box.max.equals(this.max);
					}
				}

				const _points = [
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3()
				];

				const _vector =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();

				const _box = /*@__PURE__*/ new Box3();

				// triangle centered vertices

				const _v0 =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _v1 =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _v2 =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();

				// triangle edge vectors

				const _f0 =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _f1 =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _f2 =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();

				const _center =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _extents =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _triangleNormal =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _testAxis =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();

				function satForAxes(axes, v0, v1, v2, extents) {
					for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
						_testAxis.fromArray(axes, i);
						// project the aabb onto the separating axis
						const r =
							extents.x * Math.abs(_testAxis.x) +
							extents.y * Math.abs(_testAxis.y) +
							extents.z * Math.abs(_testAxis.z);
						// project all 3 vertices of the triangle onto the separating axis
						const p0 = v0.dot(_testAxis);
						const p1 = v1.dot(_testAxis);
						const p2 = v2.dot(_testAxis);
						// actual test, basically see if either of the most extreme of the triangle points intersects r
						if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
							// points of the projected triangle are outside the projected half-length of the aabb
							// the axis is separating and we can exit
							return false;
						}
					}

					return true;
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Color.js":
			/*!***********************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Color.js ***!
  \***********************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Color: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/GridHelper.js.Color"] */ Color
				});
				/* ESM import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./MathUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/MathUtils.js"
					);
				/* ESM import */ var _ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./ColorManagement.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/ColorManagement.js"
					);
				/* ESM import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../constants.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js"
					);

				const _colorKeywords = {
					aliceblue: 0xf0f8ff,
					antiquewhite: 0xfaebd7,
					aqua: 0x00ffff,
					aquamarine: 0x7fffd4,
					azure: 0xf0ffff,
					beige: 0xf5f5dc,
					bisque: 0xffe4c4,
					black: 0x000000,
					blanchedalmond: 0xffebcd,
					blue: 0x0000ff,
					blueviolet: 0x8a2be2,
					brown: 0xa52a2a,
					burlywood: 0xdeb887,
					cadetblue: 0x5f9ea0,
					chartreuse: 0x7fff00,
					chocolate: 0xd2691e,
					coral: 0xff7f50,
					cornflowerblue: 0x6495ed,
					cornsilk: 0xfff8dc,
					crimson: 0xdc143c,
					cyan: 0x00ffff,
					darkblue: 0x00008b,
					darkcyan: 0x008b8b,
					darkgoldenrod: 0xb8860b,
					darkgray: 0xa9a9a9,
					darkgreen: 0x006400,
					darkgrey: 0xa9a9a9,
					darkkhaki: 0xbdb76b,
					darkmagenta: 0x8b008b,
					darkolivegreen: 0x556b2f,
					darkorange: 0xff8c00,
					darkorchid: 0x9932cc,
					darkred: 0x8b0000,
					darksalmon: 0xe9967a,
					darkseagreen: 0x8fbc8f,
					darkslateblue: 0x483d8b,
					darkslategray: 0x2f4f4f,
					darkslategrey: 0x2f4f4f,
					darkturquoise: 0x00ced1,
					darkviolet: 0x9400d3,
					deeppink: 0xff1493,
					deepskyblue: 0x00bfff,
					dimgray: 0x696969,
					dimgrey: 0x696969,
					dodgerblue: 0x1e90ff,
					firebrick: 0xb22222,
					floralwhite: 0xfffaf0,
					forestgreen: 0x228b22,
					fuchsia: 0xff00ff,
					gainsboro: 0xdcdcdc,
					ghostwhite: 0xf8f8ff,
					gold: 0xffd700,
					goldenrod: 0xdaa520,
					gray: 0x808080,
					green: 0x008000,
					greenyellow: 0xadff2f,
					grey: 0x808080,
					honeydew: 0xf0fff0,
					hotpink: 0xff69b4,
					indianred: 0xcd5c5c,
					indigo: 0x4b0082,
					ivory: 0xfffff0,
					khaki: 0xf0e68c,
					lavender: 0xe6e6fa,
					lavenderblush: 0xfff0f5,
					lawngreen: 0x7cfc00,
					lemonchiffon: 0xfffacd,
					lightblue: 0xadd8e6,
					lightcoral: 0xf08080,
					lightcyan: 0xe0ffff,
					lightgoldenrodyellow: 0xfafad2,
					lightgray: 0xd3d3d3,
					lightgreen: 0x90ee90,
					lightgrey: 0xd3d3d3,
					lightpink: 0xffb6c1,
					lightsalmon: 0xffa07a,
					lightseagreen: 0x20b2aa,
					lightskyblue: 0x87cefa,
					lightslategray: 0x778899,
					lightslategrey: 0x778899,
					lightsteelblue: 0xb0c4de,
					lightyellow: 0xffffe0,
					lime: 0x00ff00,
					limegreen: 0x32cd32,
					linen: 0xfaf0e6,
					magenta: 0xff00ff,
					maroon: 0x800000,
					mediumaquamarine: 0x66cdaa,
					mediumblue: 0x0000cd,
					mediumorchid: 0xba55d3,
					mediumpurple: 0x9370db,
					mediumseagreen: 0x3cb371,
					mediumslateblue: 0x7b68ee,
					mediumspringgreen: 0x00fa9a,
					mediumturquoise: 0x48d1cc,
					mediumvioletred: 0xc71585,
					midnightblue: 0x191970,
					mintcream: 0xf5fffa,
					mistyrose: 0xffe4e1,
					moccasin: 0xffe4b5,
					navajowhite: 0xffdead,
					navy: 0x000080,
					oldlace: 0xfdf5e6,
					olive: 0x808000,
					olivedrab: 0x6b8e23,
					orange: 0xffa500,
					orangered: 0xff4500,
					orchid: 0xda70d6,
					palegoldenrod: 0xeee8aa,
					palegreen: 0x98fb98,
					paleturquoise: 0xafeeee,
					palevioletred: 0xdb7093,
					papayawhip: 0xffefd5,
					peachpuff: 0xffdab9,
					peru: 0xcd853f,
					pink: 0xffc0cb,
					plum: 0xdda0dd,
					powderblue: 0xb0e0e6,
					purple: 0x800080,
					rebeccapurple: 0x663399,
					red: 0xff0000,
					rosybrown: 0xbc8f8f,
					royalblue: 0x4169e1,
					saddlebrown: 0x8b4513,
					salmon: 0xfa8072,
					sandybrown: 0xf4a460,
					seagreen: 0x2e8b57,
					seashell: 0xfff5ee,
					sienna: 0xa0522d,
					silver: 0xc0c0c0,
					skyblue: 0x87ceeb,
					slateblue: 0x6a5acd,
					slategray: 0x708090,
					slategrey: 0x708090,
					snow: 0xfffafa,
					springgreen: 0x00ff7f,
					steelblue: 0x4682b4,
					tan: 0xd2b48c,
					teal: 0x008080,
					thistle: 0xd8bfd8,
					tomato: 0xff6347,
					turquoise: 0x40e0d0,
					violet: 0xee82ee,
					wheat: 0xf5deb3,
					white: 0xffffff,
					whitesmoke: 0xf5f5f5,
					yellow: 0xffff00,
					yellowgreen: 0x9acd32
				};

				const _hslA = { h: 0, s: 0, l: 0 };
				const _hslB = { h: 0, s: 0, l: 0 };

				function hue2rgb(p, q, t) {
					if (t < 0) t += 1;
					if (t > 1) t -= 1;
					if (t < 1 / 6) return p + (q - p) * 6 * t;
					if (t < 1 / 2) return q;
					if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
					return p;
				}

				class Color {
					constructor(r, g, b) {
						this.isColor = true;

						this.r = 1;
						this.g = 1;
						this.b = 1;

						return this.set(r, g, b);
					}

					set(r, g, b) {
						if (g === undefined && b === undefined) {
							// r is THREE.Color, hex or string

							const value = r;

							if (value && value.isColor) {
								this.copy(value);
							} else if (typeof value === "number") {
								this.setHex(value);
							} else if (typeof value === "string") {
								this.setStyle(value);
							}
						} else {
							this.setRGB(r, g, b);
						}

						return this;
					}

					setScalar(scalar) {
						this.r = scalar;
						this.g = scalar;
						this.b = scalar;

						return this;
					}

					setHex(
						hex,
						colorSpace = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace
					) {
						hex = Math.floor(hex);

						this.r = ((hex >> 16) & 255) / 255;
						this.g = ((hex >> 8) & 255) / 255;
						this.b = (hex & 255) / 255;

						_ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__.ColorManagement.toWorkingColorSpace(
							this,
							colorSpace
						);

						return this;
					}

					setRGB(
						r,
						g,
						b,
						colorSpace = _ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__
							.ColorManagement.workingColorSpace
					) {
						this.r = r;
						this.g = g;
						this.b = b;

						_ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__.ColorManagement.toWorkingColorSpace(
							this,
							colorSpace
						);

						return this;
					}

					setHSL(
						h,
						s,
						l,
						colorSpace = _ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__
							.ColorManagement.workingColorSpace
					) {
						// h,s,l ranges are in 0.0 - 1.0
						h = (0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.euclideanModulo)(
							h,
							1
						);
						s = (0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(s, 0, 1);
						l = (0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(l, 0, 1);

						if (s === 0) {
							this.r = this.g = this.b = l;
						} else {
							const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
							const q = 2 * l - p;

							this.r = hue2rgb(q, p, h + 1 / 3);
							this.g = hue2rgb(q, p, h);
							this.b = hue2rgb(q, p, h - 1 / 3);
						}

						_ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__.ColorManagement.toWorkingColorSpace(
							this,
							colorSpace
						);

						return this;
					}

					setStyle(
						style,
						colorSpace = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace
					) {
						function handleAlpha(string) {
							if (string === undefined) return;

							if (parseFloat(string) < 1) {
								console.warn(
									"THREE.Color: Alpha component of " +
										style +
										" will be ignored."
								);
							}
						}

						let m;

						if ((m = /^(\w+)\(([^\)]*)\)/.exec(style))) {
							// rgb / hsl

							let color;
							const name = m[1];
							const components = m[2];

							switch (name) {
								case "rgb":
								case "rgba":
									if (
										(color =
											/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
												components
											))
									) {
										// rgb(255,0,0) rgba(255,0,0,0.5)

										handleAlpha(color[4]);

										return this.setRGB(
											Math.min(255, parseInt(color[1], 10)) / 255,
											Math.min(255, parseInt(color[2], 10)) / 255,
											Math.min(255, parseInt(color[3], 10)) / 255,
											colorSpace
										);
									}

									if (
										(color =
											/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
												components
											))
									) {
										// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

										handleAlpha(color[4]);

										return this.setRGB(
											Math.min(100, parseInt(color[1], 10)) / 100,
											Math.min(100, parseInt(color[2], 10)) / 100,
											Math.min(100, parseInt(color[3], 10)) / 100,
											colorSpace
										);
									}

									break;

								case "hsl":
								case "hsla":
									if (
										(color =
											/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
												components
											))
									) {
										// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

										handleAlpha(color[4]);

										return this.setHSL(
											parseFloat(color[1]) / 360,
											parseFloat(color[2]) / 100,
											parseFloat(color[3]) / 100,
											colorSpace
										);
									}

									break;

								default:
									console.warn("THREE.Color: Unknown color model " + style);
							}
						} else if ((m = /^\#([A-Fa-f\d]+)$/.exec(style))) {
							// hex color

							const hex = m[1];
							const size = hex.length;

							if (size === 3) {
								// #ff0
								return this.setRGB(
									parseInt(hex.charAt(0), 16) / 15,
									parseInt(hex.charAt(1), 16) / 15,
									parseInt(hex.charAt(2), 16) / 15,
									colorSpace
								);
							} else if (size === 6) {
								// #ff0000
								return this.setHex(parseInt(hex, 16), colorSpace);
							} else {
								console.warn("THREE.Color: Invalid hex color " + style);
							}
						} else if (style && style.length > 0) {
							return this.setColorName(style, colorSpace);
						}

						return this;
					}

					setColorName(
						style,
						colorSpace = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace
					) {
						// color keywords
						const hex = _colorKeywords[style.toLowerCase()];

						if (hex !== undefined) {
							// red
							this.setHex(hex, colorSpace);
						} else {
							// unknown color
							console.warn("THREE.Color: Unknown color " + style);
						}

						return this;
					}

					clone() {
						return new this.constructor(this.r, this.g, this.b);
					}

					copy(color) {
						this.r = color.r;
						this.g = color.g;
						this.b = color.b;

						return this;
					}

					copySRGBToLinear(color) {
						this.r = (0,
						_ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__.SRGBToLinear)(
							color.r
						);
						this.g = (0,
						_ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__.SRGBToLinear)(
							color.g
						);
						this.b = (0,
						_ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__.SRGBToLinear)(
							color.b
						);

						return this;
					}

					copyLinearToSRGB(color) {
						this.r = (0,
						_ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__.LinearToSRGB)(
							color.r
						);
						this.g = (0,
						_ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__.LinearToSRGB)(
							color.g
						);
						this.b = (0,
						_ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__.LinearToSRGB)(
							color.b
						);

						return this;
					}

					convertSRGBToLinear() {
						this.copySRGBToLinear(this);

						return this;
					}

					convertLinearToSRGB() {
						this.copyLinearToSRGB(this);

						return this;
					}

					getHex(
						colorSpace = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace
					) {
						_ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__.ColorManagement.fromWorkingColorSpace(
							_color.copy(this),
							colorSpace
						);

						return (
							Math.round(
								(0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(
									_color.r * 255,
									0,
									255
								)
							) *
								65536 +
							Math.round(
								(0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(
									_color.g * 255,
									0,
									255
								)
							) *
								256 +
							Math.round(
								(0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(
									_color.b * 255,
									0,
									255
								)
							)
						);
					}

					getHexString(
						colorSpace = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace
					) {
						return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
					}

					getHSL(
						target,
						colorSpace = _ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__
							.ColorManagement.workingColorSpace
					) {
						// h,s,l ranges are in 0.0 - 1.0

						_ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__.ColorManagement.fromWorkingColorSpace(
							_color.copy(this),
							colorSpace
						);

						const r = _color.r,
							g = _color.g,
							b = _color.b;

						const max = Math.max(r, g, b);
						const min = Math.min(r, g, b);

						let hue, saturation;
						const lightness = (min + max) / 2.0;

						if (min === max) {
							hue = 0;
							saturation = 0;
						} else {
							const delta = max - min;

							saturation =
								lightness <= 0.5
									? delta / (max + min)
									: delta / (2 - max - min);

							switch (max) {
								case r:
									hue = (g - b) / delta + (g < b ? 6 : 0);
									break;
								case g:
									hue = (b - r) / delta + 2;
									break;
								case b:
									hue = (r - g) / delta + 4;
									break;
							}

							hue /= 6;
						}

						target.h = hue;
						target.s = saturation;
						target.l = lightness;

						return target;
					}

					getRGB(
						target,
						colorSpace = _ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__
							.ColorManagement.workingColorSpace
					) {
						_ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__.ColorManagement.fromWorkingColorSpace(
							_color.copy(this),
							colorSpace
						);

						target.r = _color.r;
						target.g = _color.g;
						target.b = _color.b;

						return target;
					}

					getStyle(
						colorSpace = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace
					) {
						_ColorManagement_js__WEBPACK_IMPORTED_MODULE_1__.ColorManagement.fromWorkingColorSpace(
							_color.copy(this),
							colorSpace
						);

						const r = _color.r,
							g = _color.g,
							b = _color.b;

						if (
							colorSpace !==
							_constants_js__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace
						) {
							// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
							return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;
						}

						return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
					}

					offsetHSL(h, s, l) {
						this.getHSL(_hslA);

						return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
					}

					add(color) {
						this.r += color.r;
						this.g += color.g;
						this.b += color.b;

						return this;
					}

					addColors(color1, color2) {
						this.r = color1.r + color2.r;
						this.g = color1.g + color2.g;
						this.b = color1.b + color2.b;

						return this;
					}

					addScalar(s) {
						this.r += s;
						this.g += s;
						this.b += s;

						return this;
					}

					sub(color) {
						this.r = Math.max(0, this.r - color.r);
						this.g = Math.max(0, this.g - color.g);
						this.b = Math.max(0, this.b - color.b);

						return this;
					}

					multiply(color) {
						this.r *= color.r;
						this.g *= color.g;
						this.b *= color.b;

						return this;
					}

					multiplyScalar(s) {
						this.r *= s;
						this.g *= s;
						this.b *= s;

						return this;
					}

					lerp(color, alpha) {
						this.r += (color.r - this.r) * alpha;
						this.g += (color.g - this.g) * alpha;
						this.b += (color.b - this.b) * alpha;

						return this;
					}

					lerpColors(color1, color2, alpha) {
						this.r = color1.r + (color2.r - color1.r) * alpha;
						this.g = color1.g + (color2.g - color1.g) * alpha;
						this.b = color1.b + (color2.b - color1.b) * alpha;

						return this;
					}

					lerpHSL(color, alpha) {
						this.getHSL(_hslA);
						color.getHSL(_hslB);

						const h = (0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.lerp)(
							_hslA.h,
							_hslB.h,
							alpha
						);
						const s = (0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.lerp)(
							_hslA.s,
							_hslB.s,
							alpha
						);
						const l = (0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.lerp)(
							_hslA.l,
							_hslB.l,
							alpha
						);

						this.setHSL(h, s, l);

						return this;
					}

					setFromVector3(v) {
						this.r = v.x;
						this.g = v.y;
						this.b = v.z;

						return this;
					}

					applyMatrix3(m) {
						const r = this.r,
							g = this.g,
							b = this.b;
						const e = m.elements;

						this.r = e[0] * r + e[3] * g + e[6] * b;
						this.g = e[1] * r + e[4] * g + e[7] * b;
						this.b = e[2] * r + e[5] * g + e[8] * b;

						return this;
					}

					equals(c) {
						return c.r === this.r && c.g === this.g && c.b === this.b;
					}

					fromArray(array, offset = 0) {
						this.r = array[offset];
						this.g = array[offset + 1];
						this.b = array[offset + 2];

						return this;
					}

					toArray(array = [], offset = 0) {
						array[offset] = this.r;
						array[offset + 1] = this.g;
						array[offset + 2] = this.b;

						return array;
					}

					fromBufferAttribute(attribute, index) {
						this.r = attribute.getX(index);
						this.g = attribute.getY(index);
						this.b = attribute.getZ(index);

						return this;
					}

					toJSON() {
						return this.getHex();
					}

					*[Symbol.iterator]() {
						yield this.r;
						yield this.g;
						yield this.b;
					}
				}

				const _color = /*@__PURE__*/ new Color();

				Color.NAMES = _colorKeywords;
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/ColorManagement.js":
			/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/ColorManagement.js ***!
  \*********************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					ColorManagement: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/GridHelper.js.ColorManagement"] */ ColorManagement,
					LinearToSRGB: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/GridHelper.js.LinearToSRGB"] */ LinearToSRGB,
					SRGBToLinear: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/GridHelper.js.SRGBToLinear"] */ SRGBToLinear
				});
				/* ESM import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../constants.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js"
					);
				/* ESM import */ var _Matrix3_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Matrix3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Matrix3.js"
					);

				/**
				 * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping
				 * or clipping. Based on W3C specifications for sRGB and Display P3,
				 * and ICC specifications for the D50 connection space. Values in/out
				 * are _linear_ sRGB and _linear_ Display P3.
				 *
				 * Note that both sRGB and Display P3 use the sRGB transfer functions.
				 *
				 * Reference:
				 * - http://www.russellcottrell.com/photo/matrixCalculator.htm
				 */

				const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 =
					/*@__PURE__*/ new _Matrix3_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3().set(
						0.8224621,
						0.177538,
						0.0,
						0.0331941,
						0.9668058,
						0.0,
						0.0170827,
						0.0723974,
						0.9105199
					);

				const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB =
					/*@__PURE__*/ new _Matrix3_js__WEBPACK_IMPORTED_MODULE_0__.Matrix3().set(
						1.2249401,
						-0.2249404,
						0.0,
						-0.0420569,
						1.0420571,
						0.0,
						-0.0196376,
						-0.0786361,
						1.0982735
					);

				/**
				 * Defines supported color spaces by transfer function and primaries,
				 * and provides conversions to/from the Linear-sRGB reference space.
				 */
				const COLOR_SPACES = {
					[_constants_js__WEBPACK_IMPORTED_MODULE_1__.LinearSRGBColorSpace]: {
						transfer: _constants_js__WEBPACK_IMPORTED_MODULE_1__.LinearTransfer,
						primaries:
							_constants_js__WEBPACK_IMPORTED_MODULE_1__.Rec709Primaries,
						luminanceCoefficients: [0.2126, 0.7152, 0.0722],
						toReference: color => color,
						fromReference: color => color
					},
					[_constants_js__WEBPACK_IMPORTED_MODULE_1__.SRGBColorSpace]: {
						transfer: _constants_js__WEBPACK_IMPORTED_MODULE_1__.SRGBTransfer,
						primaries:
							_constants_js__WEBPACK_IMPORTED_MODULE_1__.Rec709Primaries,
						luminanceCoefficients: [0.2126, 0.7152, 0.0722],
						toReference: color => color.convertSRGBToLinear(),
						fromReference: color => color.convertLinearToSRGB()
					},
					[_constants_js__WEBPACK_IMPORTED_MODULE_1__.LinearDisplayP3ColorSpace]:
						{
							transfer:
								_constants_js__WEBPACK_IMPORTED_MODULE_1__.LinearTransfer,
							primaries: _constants_js__WEBPACK_IMPORTED_MODULE_1__.P3Primaries,
							luminanceCoefficients: [0.2289, 0.6917, 0.0793],
							toReference: color =>
								color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
							fromReference: color =>
								color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)
						},
					[_constants_js__WEBPACK_IMPORTED_MODULE_1__.DisplayP3ColorSpace]: {
						transfer: _constants_js__WEBPACK_IMPORTED_MODULE_1__.SRGBTransfer,
						primaries: _constants_js__WEBPACK_IMPORTED_MODULE_1__.P3Primaries,
						luminanceCoefficients: [0.2289, 0.6917, 0.0793],
						toReference: color =>
							color
								.convertSRGBToLinear()
								.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
						fromReference: color =>
							color
								.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)
								.convertLinearToSRGB()
					}
				};

				const SUPPORTED_WORKING_COLOR_SPACES = new Set([
					_constants_js__WEBPACK_IMPORTED_MODULE_1__.LinearSRGBColorSpace,
					_constants_js__WEBPACK_IMPORTED_MODULE_1__.LinearDisplayP3ColorSpace
				]);

				const ColorManagement = {
					enabled: true,

					_workingColorSpace:
						_constants_js__WEBPACK_IMPORTED_MODULE_1__.LinearSRGBColorSpace,

					get workingColorSpace() {
						return this._workingColorSpace;
					},

					set workingColorSpace(colorSpace) {
						if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
							throw new Error(
								`Unsupported working color space, "${colorSpace}".`
							);
						}

						this._workingColorSpace = colorSpace;
					},

					convert: function (color, sourceColorSpace, targetColorSpace) {
						if (
							this.enabled === false ||
							sourceColorSpace === targetColorSpace ||
							!sourceColorSpace ||
							!targetColorSpace
						) {
							return color;
						}

						const sourceToReference =
							COLOR_SPACES[sourceColorSpace].toReference;
						const targetFromReference =
							COLOR_SPACES[targetColorSpace].fromReference;

						return targetFromReference(sourceToReference(color));
					},

					fromWorkingColorSpace: function (color, targetColorSpace) {
						return this.convert(
							color,
							this._workingColorSpace,
							targetColorSpace
						);
					},

					toWorkingColorSpace: function (color, sourceColorSpace) {
						return this.convert(
							color,
							sourceColorSpace,
							this._workingColorSpace
						);
					},

					getPrimaries: function (colorSpace) {
						return COLOR_SPACES[colorSpace].primaries;
					},

					getTransfer: function (colorSpace) {
						if (
							colorSpace ===
							_constants_js__WEBPACK_IMPORTED_MODULE_1__.NoColorSpace
						)
							return _constants_js__WEBPACK_IMPORTED_MODULE_1__.LinearTransfer;

						return COLOR_SPACES[colorSpace].transfer;
					},

					getLuminanceCoefficients: function (
						target,
						colorSpace = this._workingColorSpace
					) {
						return target.fromArray(
							COLOR_SPACES[colorSpace].luminanceCoefficients
						);
					}
				};

				function SRGBToLinear(c) {
					return c < 0.04045
						? c * 0.0773993808
						: Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
				}

				function LinearToSRGB(c) {
					return c < 0.0031308
						? c * 12.92
						: 1.055 * Math.pow(c, 0.41666) - 0.055;
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Euler.js":
			/*!***********************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Euler.js ***!
  \***********************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Euler: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Euler"] */ Euler
				});
				/* ESM import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Quaternion.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Quaternion.js"
					);
				/* ESM import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Matrix4.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Matrix4.js"
					);
				/* ESM import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./MathUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/MathUtils.js"
					);

				const _matrix =
					/*@__PURE__*/ new _Matrix4_js__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
				const _quaternion =
					/*@__PURE__*/ new _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion();

				class Euler {
					constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
						this.isEuler = true;

						this._x = x;
						this._y = y;
						this._z = z;
						this._order = order;
					}

					get x() {
						return this._x;
					}

					set x(value) {
						this._x = value;
						this._onChangeCallback();
					}

					get y() {
						return this._y;
					}

					set y(value) {
						this._y = value;
						this._onChangeCallback();
					}

					get z() {
						return this._z;
					}

					set z(value) {
						this._z = value;
						this._onChangeCallback();
					}

					get order() {
						return this._order;
					}

					set order(value) {
						this._order = value;
						this._onChangeCallback();
					}

					set(x, y, z, order = this._order) {
						this._x = x;
						this._y = y;
						this._z = z;
						this._order = order;

						this._onChangeCallback();

						return this;
					}

					clone() {
						return new this.constructor(this._x, this._y, this._z, this._order);
					}

					copy(euler) {
						this._x = euler._x;
						this._y = euler._y;
						this._z = euler._z;
						this._order = euler._order;

						this._onChangeCallback();

						return this;
					}

					setFromRotationMatrix(m, order = this._order, update = true) {
						// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

						const te = m.elements;
						const m11 = te[0],
							m12 = te[4],
							m13 = te[8];
						const m21 = te[1],
							m22 = te[5],
							m23 = te[9];
						const m31 = te[2],
							m32 = te[6],
							m33 = te[10];

						switch (order) {
							case "XYZ":
								this._y = Math.asin(
									(0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(
										m13,
										-1,
										1
									)
								);

								if (Math.abs(m13) < 0.9999999) {
									this._x = Math.atan2(-m23, m33);
									this._z = Math.atan2(-m12, m11);
								} else {
									this._x = Math.atan2(m32, m22);
									this._z = 0;
								}

								break;

							case "YXZ":
								this._x = Math.asin(
									-(0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(
										m23,
										-1,
										1
									)
								);

								if (Math.abs(m23) < 0.9999999) {
									this._y = Math.atan2(m13, m33);
									this._z = Math.atan2(m21, m22);
								} else {
									this._y = Math.atan2(-m31, m11);
									this._z = 0;
								}

								break;

							case "ZXY":
								this._x = Math.asin(
									(0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(
										m32,
										-1,
										1
									)
								);

								if (Math.abs(m32) < 0.9999999) {
									this._y = Math.atan2(-m31, m33);
									this._z = Math.atan2(-m12, m22);
								} else {
									this._y = 0;
									this._z = Math.atan2(m21, m11);
								}

								break;

							case "ZYX":
								this._y = Math.asin(
									-(0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(
										m31,
										-1,
										1
									)
								);

								if (Math.abs(m31) < 0.9999999) {
									this._x = Math.atan2(m32, m33);
									this._z = Math.atan2(m21, m11);
								} else {
									this._x = 0;
									this._z = Math.atan2(-m12, m22);
								}

								break;

							case "YZX":
								this._z = Math.asin(
									(0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(
										m21,
										-1,
										1
									)
								);

								if (Math.abs(m21) < 0.9999999) {
									this._x = Math.atan2(-m23, m22);
									this._y = Math.atan2(-m31, m11);
								} else {
									this._x = 0;
									this._y = Math.atan2(m13, m33);
								}

								break;

							case "XZY":
								this._z = Math.asin(
									-(0, _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(
										m12,
										-1,
										1
									)
								);

								if (Math.abs(m12) < 0.9999999) {
									this._x = Math.atan2(m32, m22);
									this._y = Math.atan2(m13, m11);
								} else {
									this._x = Math.atan2(-m23, m33);
									this._y = 0;
								}

								break;

							default:
								console.warn(
									"THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
										order
								);
						}

						this._order = order;

						if (update === true) this._onChangeCallback();

						return this;
					}

					setFromQuaternion(q, order, update) {
						_matrix.makeRotationFromQuaternion(q);

						return this.setFromRotationMatrix(_matrix, order, update);
					}

					setFromVector3(v, order = this._order) {
						return this.set(v.x, v.y, v.z, order);
					}

					reorder(newOrder) {
						// WARNING: this discards revolution information -bhouston

						_quaternion.setFromEuler(this);

						return this.setFromQuaternion(_quaternion, newOrder);
					}

					equals(euler) {
						return (
							euler._x === this._x &&
							euler._y === this._y &&
							euler._z === this._z &&
							euler._order === this._order
						);
					}

					fromArray(array) {
						this._x = array[0];
						this._y = array[1];
						this._z = array[2];
						if (array[3] !== undefined) this._order = array[3];

						this._onChangeCallback();

						return this;
					}

					toArray(array = [], offset = 0) {
						array[offset] = this._x;
						array[offset + 1] = this._y;
						array[offset + 2] = this._z;
						array[offset + 3] = this._order;

						return array;
					}

					_onChange(callback) {
						this._onChangeCallback = callback;

						return this;
					}

					_onChangeCallback() {}

					*[Symbol.iterator]() {
						yield this._x;
						yield this._y;
						yield this._z;
						yield this._order;
					}
				}

				Euler.DEFAULT_ORDER = "XYZ";
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Matrix3.js":
			/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Matrix3.js ***!
  \*************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Matrix3: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Matrix3"] */ Matrix3
				});
				class Matrix3 {
					constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
						Matrix3.prototype.isMatrix3 = true;

						this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

						if (n11 !== undefined) {
							this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
						}
					}

					set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
						const te = this.elements;

						te[0] = n11;
						te[1] = n21;
						te[2] = n31;
						te[3] = n12;
						te[4] = n22;
						te[5] = n32;
						te[6] = n13;
						te[7] = n23;
						te[8] = n33;

						return this;
					}

					identity() {
						this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);

						return this;
					}

					copy(m) {
						const te = this.elements;
						const me = m.elements;

						te[0] = me[0];
						te[1] = me[1];
						te[2] = me[2];
						te[3] = me[3];
						te[4] = me[4];
						te[5] = me[5];
						te[6] = me[6];
						te[7] = me[7];
						te[8] = me[8];

						return this;
					}

					extractBasis(xAxis, yAxis, zAxis) {
						xAxis.setFromMatrix3Column(this, 0);
						yAxis.setFromMatrix3Column(this, 1);
						zAxis.setFromMatrix3Column(this, 2);

						return this;
					}

					setFromMatrix4(m) {
						const me = m.elements;

						this.set(
							me[0],
							me[4],
							me[8],
							me[1],
							me[5],
							me[9],
							me[2],
							me[6],
							me[10]
						);

						return this;
					}

					multiply(m) {
						return this.multiplyMatrices(this, m);
					}

					premultiply(m) {
						return this.multiplyMatrices(m, this);
					}

					multiplyMatrices(a, b) {
						const ae = a.elements;
						const be = b.elements;
						const te = this.elements;

						const a11 = ae[0],
							a12 = ae[3],
							a13 = ae[6];
						const a21 = ae[1],
							a22 = ae[4],
							a23 = ae[7];
						const a31 = ae[2],
							a32 = ae[5],
							a33 = ae[8];

						const b11 = be[0],
							b12 = be[3],
							b13 = be[6];
						const b21 = be[1],
							b22 = be[4],
							b23 = be[7];
						const b31 = be[2],
							b32 = be[5],
							b33 = be[8];

						te[0] = a11 * b11 + a12 * b21 + a13 * b31;
						te[3] = a11 * b12 + a12 * b22 + a13 * b32;
						te[6] = a11 * b13 + a12 * b23 + a13 * b33;

						te[1] = a21 * b11 + a22 * b21 + a23 * b31;
						te[4] = a21 * b12 + a22 * b22 + a23 * b32;
						te[7] = a21 * b13 + a22 * b23 + a23 * b33;

						te[2] = a31 * b11 + a32 * b21 + a33 * b31;
						te[5] = a31 * b12 + a32 * b22 + a33 * b32;
						te[8] = a31 * b13 + a32 * b23 + a33 * b33;

						return this;
					}

					multiplyScalar(s) {
						const te = this.elements;

						te[0] *= s;
						te[3] *= s;
						te[6] *= s;
						te[1] *= s;
						te[4] *= s;
						te[7] *= s;
						te[2] *= s;
						te[5] *= s;
						te[8] *= s;

						return this;
					}

					determinant() {
						const te = this.elements;

						const a = te[0],
							b = te[1],
							c = te[2],
							d = te[3],
							e = te[4],
							f = te[5],
							g = te[6],
							h = te[7],
							i = te[8];

						return (
							a * e * i -
							a * f * h -
							b * d * i +
							b * f * g +
							c * d * h -
							c * e * g
						);
					}

					invert() {
						const te = this.elements,
							n11 = te[0],
							n21 = te[1],
							n31 = te[2],
							n12 = te[3],
							n22 = te[4],
							n32 = te[5],
							n13 = te[6],
							n23 = te[7],
							n33 = te[8],
							t11 = n33 * n22 - n32 * n23,
							t12 = n32 * n13 - n33 * n12,
							t13 = n23 * n12 - n22 * n13,
							det = n11 * t11 + n21 * t12 + n31 * t13;

						if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);

						const detInv = 1 / det;

						te[0] = t11 * detInv;
						te[1] = (n31 * n23 - n33 * n21) * detInv;
						te[2] = (n32 * n21 - n31 * n22) * detInv;

						te[3] = t12 * detInv;
						te[4] = (n33 * n11 - n31 * n13) * detInv;
						te[5] = (n31 * n12 - n32 * n11) * detInv;

						te[6] = t13 * detInv;
						te[7] = (n21 * n13 - n23 * n11) * detInv;
						te[8] = (n22 * n11 - n21 * n12) * detInv;

						return this;
					}

					transpose() {
						let tmp;
						const m = this.elements;

						tmp = m[1];
						m[1] = m[3];
						m[3] = tmp;
						tmp = m[2];
						m[2] = m[6];
						m[6] = tmp;
						tmp = m[5];
						m[5] = m[7];
						m[7] = tmp;

						return this;
					}

					getNormalMatrix(matrix4) {
						return this.setFromMatrix4(matrix4).invert().transpose();
					}

					transposeIntoArray(r) {
						const m = this.elements;

						r[0] = m[0];
						r[1] = m[3];
						r[2] = m[6];
						r[3] = m[1];
						r[4] = m[4];
						r[5] = m[7];
						r[6] = m[2];
						r[7] = m[5];
						r[8] = m[8];

						return this;
					}

					setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
						const c = Math.cos(rotation);
						const s = Math.sin(rotation);

						this.set(
							sx * c,
							sx * s,
							-sx * (c * cx + s * cy) + cx + tx,
							-sy * s,
							sy * c,
							-sy * (-s * cx + c * cy) + cy + ty,
							0,
							0,
							1
						);

						return this;
					}

					//

					scale(sx, sy) {
						this.premultiply(_m3.makeScale(sx, sy));

						return this;
					}

					rotate(theta) {
						this.premultiply(_m3.makeRotation(-theta));

						return this;
					}

					translate(tx, ty) {
						this.premultiply(_m3.makeTranslation(tx, ty));

						return this;
					}

					// for 2D Transforms

					makeTranslation(x, y) {
						if (x.isVector2) {
							this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
						} else {
							this.set(1, 0, x, 0, 1, y, 0, 0, 1);
						}

						return this;
					}

					makeRotation(theta) {
						// counterclockwise

						const c = Math.cos(theta);
						const s = Math.sin(theta);

						this.set(c, -s, 0, s, c, 0, 0, 0, 1);

						return this;
					}

					makeScale(x, y) {
						this.set(x, 0, 0, 0, y, 0, 0, 0, 1);

						return this;
					}

					//

					equals(matrix) {
						const te = this.elements;
						const me = matrix.elements;

						for (let i = 0; i < 9; i++) {
							if (te[i] !== me[i]) return false;
						}

						return true;
					}

					fromArray(array, offset = 0) {
						for (let i = 0; i < 9; i++) {
							this.elements[i] = array[i + offset];
						}

						return this;
					}

					toArray(array = [], offset = 0) {
						const te = this.elements;

						array[offset] = te[0];
						array[offset + 1] = te[1];
						array[offset + 2] = te[2];

						array[offset + 3] = te[3];
						array[offset + 4] = te[4];
						array[offset + 5] = te[5];

						array[offset + 6] = te[6];
						array[offset + 7] = te[7];
						array[offset + 8] = te[8];

						return array;
					}

					clone() {
						return new this.constructor().fromArray(this.elements);
					}
				}

				const _m3 = /*@__PURE__*/ new Matrix3();
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Matrix4.js":
			/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Matrix4.js ***!
  \*************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Matrix4: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Matrix4"] */ Matrix4
				});
				/* ESM import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../constants.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/constants.js"
					);
				/* ESM import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Vector3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector3.js"
					);

				class Matrix4 {
					constructor(
						n11,
						n12,
						n13,
						n14,
						n21,
						n22,
						n23,
						n24,
						n31,
						n32,
						n33,
						n34,
						n41,
						n42,
						n43,
						n44
					) {
						Matrix4.prototype.isMatrix4 = true;

						this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

						if (n11 !== undefined) {
							this.set(
								n11,
								n12,
								n13,
								n14,
								n21,
								n22,
								n23,
								n24,
								n31,
								n32,
								n33,
								n34,
								n41,
								n42,
								n43,
								n44
							);
						}
					}

					set(
						n11,
						n12,
						n13,
						n14,
						n21,
						n22,
						n23,
						n24,
						n31,
						n32,
						n33,
						n34,
						n41,
						n42,
						n43,
						n44
					) {
						const te = this.elements;

						te[0] = n11;
						te[4] = n12;
						te[8] = n13;
						te[12] = n14;
						te[1] = n21;
						te[5] = n22;
						te[9] = n23;
						te[13] = n24;
						te[2] = n31;
						te[6] = n32;
						te[10] = n33;
						te[14] = n34;
						te[3] = n41;
						te[7] = n42;
						te[11] = n43;
						te[15] = n44;

						return this;
					}

					identity() {
						this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

						return this;
					}

					clone() {
						return new Matrix4().fromArray(this.elements);
					}

					copy(m) {
						const te = this.elements;
						const me = m.elements;

						te[0] = me[0];
						te[1] = me[1];
						te[2] = me[2];
						te[3] = me[3];
						te[4] = me[4];
						te[5] = me[5];
						te[6] = me[6];
						te[7] = me[7];
						te[8] = me[8];
						te[9] = me[9];
						te[10] = me[10];
						te[11] = me[11];
						te[12] = me[12];
						te[13] = me[13];
						te[14] = me[14];
						te[15] = me[15];

						return this;
					}

					copyPosition(m) {
						const te = this.elements,
							me = m.elements;

						te[12] = me[12];
						te[13] = me[13];
						te[14] = me[14];

						return this;
					}

					setFromMatrix3(m) {
						const me = m.elements;

						this.set(
							me[0],
							me[3],
							me[6],
							0,
							me[1],
							me[4],
							me[7],
							0,
							me[2],
							me[5],
							me[8],
							0,
							0,
							0,
							0,
							1
						);

						return this;
					}

					extractBasis(xAxis, yAxis, zAxis) {
						xAxis.setFromMatrixColumn(this, 0);
						yAxis.setFromMatrixColumn(this, 1);
						zAxis.setFromMatrixColumn(this, 2);

						return this;
					}

					makeBasis(xAxis, yAxis, zAxis) {
						this.set(
							xAxis.x,
							yAxis.x,
							zAxis.x,
							0,
							xAxis.y,
							yAxis.y,
							zAxis.y,
							0,
							xAxis.z,
							yAxis.z,
							zAxis.z,
							0,
							0,
							0,
							0,
							1
						);

						return this;
					}

					extractRotation(m) {
						// this method does not support reflection matrices

						const te = this.elements;
						const me = m.elements;

						const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();
						const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();
						const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();

						te[0] = me[0] * scaleX;
						te[1] = me[1] * scaleX;
						te[2] = me[2] * scaleX;
						te[3] = 0;

						te[4] = me[4] * scaleY;
						te[5] = me[5] * scaleY;
						te[6] = me[6] * scaleY;
						te[7] = 0;

						te[8] = me[8] * scaleZ;
						te[9] = me[9] * scaleZ;
						te[10] = me[10] * scaleZ;
						te[11] = 0;

						te[12] = 0;
						te[13] = 0;
						te[14] = 0;
						te[15] = 1;

						return this;
					}

					makeRotationFromEuler(euler) {
						const te = this.elements;

						const x = euler.x,
							y = euler.y,
							z = euler.z;
						const a = Math.cos(x),
							b = Math.sin(x);
						const c = Math.cos(y),
							d = Math.sin(y);
						const e = Math.cos(z),
							f = Math.sin(z);

						if (euler.order === "XYZ") {
							const ae = a * e,
								af = a * f,
								be = b * e,
								bf = b * f;

							te[0] = c * e;
							te[4] = -c * f;
							te[8] = d;

							te[1] = af + be * d;
							te[5] = ae - bf * d;
							te[9] = -b * c;

							te[2] = bf - ae * d;
							te[6] = be + af * d;
							te[10] = a * c;
						} else if (euler.order === "YXZ") {
							const ce = c * e,
								cf = c * f,
								de = d * e,
								df = d * f;

							te[0] = ce + df * b;
							te[4] = de * b - cf;
							te[8] = a * d;

							te[1] = a * f;
							te[5] = a * e;
							te[9] = -b;

							te[2] = cf * b - de;
							te[6] = df + ce * b;
							te[10] = a * c;
						} else if (euler.order === "ZXY") {
							const ce = c * e,
								cf = c * f,
								de = d * e,
								df = d * f;

							te[0] = ce - df * b;
							te[4] = -a * f;
							te[8] = de + cf * b;

							te[1] = cf + de * b;
							te[5] = a * e;
							te[9] = df - ce * b;

							te[2] = -a * d;
							te[6] = b;
							te[10] = a * c;
						} else if (euler.order === "ZYX") {
							const ae = a * e,
								af = a * f,
								be = b * e,
								bf = b * f;

							te[0] = c * e;
							te[4] = be * d - af;
							te[8] = ae * d + bf;

							te[1] = c * f;
							te[5] = bf * d + ae;
							te[9] = af * d - be;

							te[2] = -d;
							te[6] = b * c;
							te[10] = a * c;
						} else if (euler.order === "YZX") {
							const ac = a * c,
								ad = a * d,
								bc = b * c,
								bd = b * d;

							te[0] = c * e;
							te[4] = bd - ac * f;
							te[8] = bc * f + ad;

							te[1] = f;
							te[5] = a * e;
							te[9] = -b * e;

							te[2] = -d * e;
							te[6] = ad * f + bc;
							te[10] = ac - bd * f;
						} else if (euler.order === "XZY") {
							const ac = a * c,
								ad = a * d,
								bc = b * c,
								bd = b * d;

							te[0] = c * e;
							te[4] = -f;
							te[8] = d * e;

							te[1] = ac * f + bd;
							te[5] = a * e;
							te[9] = ad * f - bc;

							te[2] = bc * f - ad;
							te[6] = b * e;
							te[10] = bd * f + ac;
						}

						// bottom row
						te[3] = 0;
						te[7] = 0;
						te[11] = 0;

						// last column
						te[12] = 0;
						te[13] = 0;
						te[14] = 0;
						te[15] = 1;

						return this;
					}

					makeRotationFromQuaternion(q) {
						return this.compose(_zero, q, _one);
					}

					lookAt(eye, target, up) {
						const te = this.elements;

						_z.subVectors(eye, target);

						if (_z.lengthSq() === 0) {
							// eye and target are in the same position

							_z.z = 1;
						}

						_z.normalize();
						_x.crossVectors(up, _z);

						if (_x.lengthSq() === 0) {
							// up and z are parallel

							if (Math.abs(up.z) === 1) {
								_z.x += 0.0001;
							} else {
								_z.z += 0.0001;
							}

							_z.normalize();
							_x.crossVectors(up, _z);
						}

						_x.normalize();
						_y.crossVectors(_z, _x);

						te[0] = _x.x;
						te[4] = _y.x;
						te[8] = _z.x;
						te[1] = _x.y;
						te[5] = _y.y;
						te[9] = _z.y;
						te[2] = _x.z;
						te[6] = _y.z;
						te[10] = _z.z;

						return this;
					}

					multiply(m) {
						return this.multiplyMatrices(this, m);
					}

					premultiply(m) {
						return this.multiplyMatrices(m, this);
					}

					multiplyMatrices(a, b) {
						const ae = a.elements;
						const be = b.elements;
						const te = this.elements;

						const a11 = ae[0],
							a12 = ae[4],
							a13 = ae[8],
							a14 = ae[12];
						const a21 = ae[1],
							a22 = ae[5],
							a23 = ae[9],
							a24 = ae[13];
						const a31 = ae[2],
							a32 = ae[6],
							a33 = ae[10],
							a34 = ae[14];
						const a41 = ae[3],
							a42 = ae[7],
							a43 = ae[11],
							a44 = ae[15];

						const b11 = be[0],
							b12 = be[4],
							b13 = be[8],
							b14 = be[12];
						const b21 = be[1],
							b22 = be[5],
							b23 = be[9],
							b24 = be[13];
						const b31 = be[2],
							b32 = be[6],
							b33 = be[10],
							b34 = be[14];
						const b41 = be[3],
							b42 = be[7],
							b43 = be[11],
							b44 = be[15];

						te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
						te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
						te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
						te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

						te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
						te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
						te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
						te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

						te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
						te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
						te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
						te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

						te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
						te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
						te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
						te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

						return this;
					}

					multiplyScalar(s) {
						const te = this.elements;

						te[0] *= s;
						te[4] *= s;
						te[8] *= s;
						te[12] *= s;
						te[1] *= s;
						te[5] *= s;
						te[9] *= s;
						te[13] *= s;
						te[2] *= s;
						te[6] *= s;
						te[10] *= s;
						te[14] *= s;
						te[3] *= s;
						te[7] *= s;
						te[11] *= s;
						te[15] *= s;

						return this;
					}

					determinant() {
						const te = this.elements;

						const n11 = te[0],
							n12 = te[4],
							n13 = te[8],
							n14 = te[12];
						const n21 = te[1],
							n22 = te[5],
							n23 = te[9],
							n24 = te[13];
						const n31 = te[2],
							n32 = te[6],
							n33 = te[10],
							n34 = te[14];
						const n41 = te[3],
							n42 = te[7],
							n43 = te[11],
							n44 = te[15];

						//TODO: make this more efficient
						//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

						return (
							n41 *
								(+n14 * n23 * n32 -
									n13 * n24 * n32 -
									n14 * n22 * n33 +
									n12 * n24 * n33 +
									n13 * n22 * n34 -
									n12 * n23 * n34) +
							n42 *
								(+n11 * n23 * n34 -
									n11 * n24 * n33 +
									n14 * n21 * n33 -
									n13 * n21 * n34 +
									n13 * n24 * n31 -
									n14 * n23 * n31) +
							n43 *
								(+n11 * n24 * n32 -
									n11 * n22 * n34 -
									n14 * n21 * n32 +
									n12 * n21 * n34 +
									n14 * n22 * n31 -
									n12 * n24 * n31) +
							n44 *
								(-n13 * n22 * n31 -
									n11 * n23 * n32 +
									n11 * n22 * n33 +
									n13 * n21 * n32 -
									n12 * n21 * n33 +
									n12 * n23 * n31)
						);
					}

					transpose() {
						const te = this.elements;
						let tmp;

						tmp = te[1];
						te[1] = te[4];
						te[4] = tmp;
						tmp = te[2];
						te[2] = te[8];
						te[8] = tmp;
						tmp = te[6];
						te[6] = te[9];
						te[9] = tmp;

						tmp = te[3];
						te[3] = te[12];
						te[12] = tmp;
						tmp = te[7];
						te[7] = te[13];
						te[13] = tmp;
						tmp = te[11];
						te[11] = te[14];
						te[14] = tmp;

						return this;
					}

					setPosition(x, y, z) {
						const te = this.elements;

						if (x.isVector3) {
							te[12] = x.x;
							te[13] = x.y;
							te[14] = x.z;
						} else {
							te[12] = x;
							te[13] = y;
							te[14] = z;
						}

						return this;
					}

					invert() {
						// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
						const te = this.elements,
							n11 = te[0],
							n21 = te[1],
							n31 = te[2],
							n41 = te[3],
							n12 = te[4],
							n22 = te[5],
							n32 = te[6],
							n42 = te[7],
							n13 = te[8],
							n23 = te[9],
							n33 = te[10],
							n43 = te[11],
							n14 = te[12],
							n24 = te[13],
							n34 = te[14],
							n44 = te[15],
							t11 =
								n23 * n34 * n42 -
								n24 * n33 * n42 +
								n24 * n32 * n43 -
								n22 * n34 * n43 -
								n23 * n32 * n44 +
								n22 * n33 * n44,
							t12 =
								n14 * n33 * n42 -
								n13 * n34 * n42 -
								n14 * n32 * n43 +
								n12 * n34 * n43 +
								n13 * n32 * n44 -
								n12 * n33 * n44,
							t13 =
								n13 * n24 * n42 -
								n14 * n23 * n42 +
								n14 * n22 * n43 -
								n12 * n24 * n43 -
								n13 * n22 * n44 +
								n12 * n23 * n44,
							t14 =
								n14 * n23 * n32 -
								n13 * n24 * n32 -
								n14 * n22 * n33 +
								n12 * n24 * n33 +
								n13 * n22 * n34 -
								n12 * n23 * n34;

						const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

						if (det === 0)
							return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

						const detInv = 1 / det;

						te[0] = t11 * detInv;
						te[1] =
							(n24 * n33 * n41 -
								n23 * n34 * n41 -
								n24 * n31 * n43 +
								n21 * n34 * n43 +
								n23 * n31 * n44 -
								n21 * n33 * n44) *
							detInv;
						te[2] =
							(n22 * n34 * n41 -
								n24 * n32 * n41 +
								n24 * n31 * n42 -
								n21 * n34 * n42 -
								n22 * n31 * n44 +
								n21 * n32 * n44) *
							detInv;
						te[3] =
							(n23 * n32 * n41 -
								n22 * n33 * n41 -
								n23 * n31 * n42 +
								n21 * n33 * n42 +
								n22 * n31 * n43 -
								n21 * n32 * n43) *
							detInv;

						te[4] = t12 * detInv;
						te[5] =
							(n13 * n34 * n41 -
								n14 * n33 * n41 +
								n14 * n31 * n43 -
								n11 * n34 * n43 -
								n13 * n31 * n44 +
								n11 * n33 * n44) *
							detInv;
						te[6] =
							(n14 * n32 * n41 -
								n12 * n34 * n41 -
								n14 * n31 * n42 +
								n11 * n34 * n42 +
								n12 * n31 * n44 -
								n11 * n32 * n44) *
							detInv;
						te[7] =
							(n12 * n33 * n41 -
								n13 * n32 * n41 +
								n13 * n31 * n42 -
								n11 * n33 * n42 -
								n12 * n31 * n43 +
								n11 * n32 * n43) *
							detInv;

						te[8] = t13 * detInv;
						te[9] =
							(n14 * n23 * n41 -
								n13 * n24 * n41 -
								n14 * n21 * n43 +
								n11 * n24 * n43 +
								n13 * n21 * n44 -
								n11 * n23 * n44) *
							detInv;
						te[10] =
							(n12 * n24 * n41 -
								n14 * n22 * n41 +
								n14 * n21 * n42 -
								n11 * n24 * n42 -
								n12 * n21 * n44 +
								n11 * n22 * n44) *
							detInv;
						te[11] =
							(n13 * n22 * n41 -
								n12 * n23 * n41 -
								n13 * n21 * n42 +
								n11 * n23 * n42 +
								n12 * n21 * n43 -
								n11 * n22 * n43) *
							detInv;

						te[12] = t14 * detInv;
						te[13] =
							(n13 * n24 * n31 -
								n14 * n23 * n31 +
								n14 * n21 * n33 -
								n11 * n24 * n33 -
								n13 * n21 * n34 +
								n11 * n23 * n34) *
							detInv;
						te[14] =
							(n14 * n22 * n31 -
								n12 * n24 * n31 -
								n14 * n21 * n32 +
								n11 * n24 * n32 +
								n12 * n21 * n34 -
								n11 * n22 * n34) *
							detInv;
						te[15] =
							(n12 * n23 * n31 -
								n13 * n22 * n31 +
								n13 * n21 * n32 -
								n11 * n23 * n32 -
								n12 * n21 * n33 +
								n11 * n22 * n33) *
							detInv;

						return this;
					}

					scale(v) {
						const te = this.elements;
						const x = v.x,
							y = v.y,
							z = v.z;

						te[0] *= x;
						te[4] *= y;
						te[8] *= z;
						te[1] *= x;
						te[5] *= y;
						te[9] *= z;
						te[2] *= x;
						te[6] *= y;
						te[10] *= z;
						te[3] *= x;
						te[7] *= y;
						te[11] *= z;

						return this;
					}

					getMaxScaleOnAxis() {
						const te = this.elements;

						const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
						const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
						const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

						return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
					}

					makeTranslation(x, y, z) {
						if (x.isVector3) {
							this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
						} else {
							this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
						}

						return this;
					}

					makeRotationX(theta) {
						const c = Math.cos(theta),
							s = Math.sin(theta);

						this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);

						return this;
					}

					makeRotationY(theta) {
						const c = Math.cos(theta),
							s = Math.sin(theta);

						this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);

						return this;
					}

					makeRotationZ(theta) {
						const c = Math.cos(theta),
							s = Math.sin(theta);

						this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

						return this;
					}

					makeRotationAxis(axis, angle) {
						// Based on http://www.gamedev.net/reference/articles/article1199.asp

						const c = Math.cos(angle);
						const s = Math.sin(angle);
						const t = 1 - c;
						const x = axis.x,
							y = axis.y,
							z = axis.z;
						const tx = t * x,
							ty = t * y;

						this.set(
							tx * x + c,
							tx * y - s * z,
							tx * z + s * y,
							0,
							tx * y + s * z,
							ty * y + c,
							ty * z - s * x,
							0,
							tx * z - s * y,
							ty * z + s * x,
							t * z * z + c,
							0,
							0,
							0,
							0,
							1
						);

						return this;
					}

					makeScale(x, y, z) {
						this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);

						return this;
					}

					makeShear(xy, xz, yx, yz, zx, zy) {
						this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);

						return this;
					}

					compose(position, quaternion, scale) {
						const te = this.elements;

						const x = quaternion._x,
							y = quaternion._y,
							z = quaternion._z,
							w = quaternion._w;
						const x2 = x + x,
							y2 = y + y,
							z2 = z + z;
						const xx = x * x2,
							xy = x * y2,
							xz = x * z2;
						const yy = y * y2,
							yz = y * z2,
							zz = z * z2;
						const wx = w * x2,
							wy = w * y2,
							wz = w * z2;

						const sx = scale.x,
							sy = scale.y,
							sz = scale.z;

						te[0] = (1 - (yy + zz)) * sx;
						te[1] = (xy + wz) * sx;
						te[2] = (xz - wy) * sx;
						te[3] = 0;

						te[4] = (xy - wz) * sy;
						te[5] = (1 - (xx + zz)) * sy;
						te[6] = (yz + wx) * sy;
						te[7] = 0;

						te[8] = (xz + wy) * sz;
						te[9] = (yz - wx) * sz;
						te[10] = (1 - (xx + yy)) * sz;
						te[11] = 0;

						te[12] = position.x;
						te[13] = position.y;
						te[14] = position.z;
						te[15] = 1;

						return this;
					}

					decompose(position, quaternion, scale) {
						const te = this.elements;

						let sx = _v1.set(te[0], te[1], te[2]).length();
						const sy = _v1.set(te[4], te[5], te[6]).length();
						const sz = _v1.set(te[8], te[9], te[10]).length();

						// if determine is negative, we need to invert one scale
						const det = this.determinant();
						if (det < 0) sx = -sx;

						position.x = te[12];
						position.y = te[13];
						position.z = te[14];

						// scale the rotation part
						_m1.copy(this);

						const invSX = 1 / sx;
						const invSY = 1 / sy;
						const invSZ = 1 / sz;

						_m1.elements[0] *= invSX;
						_m1.elements[1] *= invSX;
						_m1.elements[2] *= invSX;

						_m1.elements[4] *= invSY;
						_m1.elements[5] *= invSY;
						_m1.elements[6] *= invSY;

						_m1.elements[8] *= invSZ;
						_m1.elements[9] *= invSZ;
						_m1.elements[10] *= invSZ;

						quaternion.setFromRotationMatrix(_m1);

						scale.x = sx;
						scale.y = sy;
						scale.z = sz;

						return this;
					}

					makePerspective(
						left,
						right,
						top,
						bottom,
						near,
						far,
						coordinateSystem = _constants_js__WEBPACK_IMPORTED_MODULE_0__.WebGLCoordinateSystem
					) {
						const te = this.elements;
						const x = (2 * near) / (right - left);
						const y = (2 * near) / (top - bottom);

						const a = (right + left) / (right - left);
						const b = (top + bottom) / (top - bottom);

						let c, d;

						if (
							coordinateSystem ===
							_constants_js__WEBPACK_IMPORTED_MODULE_0__.WebGLCoordinateSystem
						) {
							c = -(far + near) / (far - near);
							d = (-2 * far * near) / (far - near);
						} else if (
							coordinateSystem ===
							_constants_js__WEBPACK_IMPORTED_MODULE_0__.WebGPUCoordinateSystem
						) {
							c = -far / (far - near);
							d = (-far * near) / (far - near);
						} else {
							throw new Error(
								"THREE.Matrix4.makePerspective(): Invalid coordinate system: " +
									coordinateSystem
							);
						}

						te[0] = x;
						te[4] = 0;
						te[8] = a;
						te[12] = 0;
						te[1] = 0;
						te[5] = y;
						te[9] = b;
						te[13] = 0;
						te[2] = 0;
						te[6] = 0;
						te[10] = c;
						te[14] = d;
						te[3] = 0;
						te[7] = 0;
						te[11] = -1;
						te[15] = 0;

						return this;
					}

					makeOrthographic(
						left,
						right,
						top,
						bottom,
						near,
						far,
						coordinateSystem = _constants_js__WEBPACK_IMPORTED_MODULE_0__.WebGLCoordinateSystem
					) {
						const te = this.elements;
						const w = 1.0 / (right - left);
						const h = 1.0 / (top - bottom);
						const p = 1.0 / (far - near);

						const x = (right + left) * w;
						const y = (top + bottom) * h;

						let z, zInv;

						if (
							coordinateSystem ===
							_constants_js__WEBPACK_IMPORTED_MODULE_0__.WebGLCoordinateSystem
						) {
							z = (far + near) * p;
							zInv = -2 * p;
						} else if (
							coordinateSystem ===
							_constants_js__WEBPACK_IMPORTED_MODULE_0__.WebGPUCoordinateSystem
						) {
							z = near * p;
							zInv = -1 * p;
						} else {
							throw new Error(
								"THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " +
									coordinateSystem
							);
						}

						te[0] = 2 * w;
						te[4] = 0;
						te[8] = 0;
						te[12] = -x;
						te[1] = 0;
						te[5] = 2 * h;
						te[9] = 0;
						te[13] = -y;
						te[2] = 0;
						te[6] = 0;
						te[10] = zInv;
						te[14] = -z;
						te[3] = 0;
						te[7] = 0;
						te[11] = 0;
						te[15] = 1;

						return this;
					}

					equals(matrix) {
						const te = this.elements;
						const me = matrix.elements;

						for (let i = 0; i < 16; i++) {
							if (te[i] !== me[i]) return false;
						}

						return true;
					}

					fromArray(array, offset = 0) {
						for (let i = 0; i < 16; i++) {
							this.elements[i] = array[i + offset];
						}

						return this;
					}

					toArray(array = [], offset = 0) {
						const te = this.elements;

						array[offset] = te[0];
						array[offset + 1] = te[1];
						array[offset + 2] = te[2];
						array[offset + 3] = te[3];

						array[offset + 4] = te[4];
						array[offset + 5] = te[5];
						array[offset + 6] = te[6];
						array[offset + 7] = te[7];

						array[offset + 8] = te[8];
						array[offset + 9] = te[9];
						array[offset + 10] = te[10];
						array[offset + 11] = te[11];

						array[offset + 12] = te[12];
						array[offset + 13] = te[13];
						array[offset + 14] = te[14];
						array[offset + 15] = te[15];

						return array;
					}
				}

				const _v1 =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__.Vector3();
				const _m1 = /*@__PURE__*/ new Matrix4();
				const _zero =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__.Vector3(
						0,
						0,
						0
					);
				const _one =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__.Vector3(
						1,
						1,
						1
					);
				const _x =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__.Vector3();
				const _y =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__.Vector3();
				const _z =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__.Vector3();
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Ray.js":
			/*!*********************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Ray.js ***!
  \*********************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Ray: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Ray"] */ Ray
				});
				/* ESM import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Vector3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector3.js"
					);

				const _vector =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _segCenter =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _segDir =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _diff =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();

				const _edge1 =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _edge2 =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _normal =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();

				class Ray {
					constructor(
						origin = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
						direction = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(
							0,
							0,
							-1
						)
					) {
						this.origin = origin;
						this.direction = direction;
					}

					set(origin, direction) {
						this.origin.copy(origin);
						this.direction.copy(direction);

						return this;
					}

					copy(ray) {
						this.origin.copy(ray.origin);
						this.direction.copy(ray.direction);

						return this;
					}

					at(t, target) {
						return target.copy(this.origin).addScaledVector(this.direction, t);
					}

					lookAt(v) {
						this.direction.copy(v).sub(this.origin).normalize();

						return this;
					}

					recast(t) {
						this.origin.copy(this.at(t, _vector));

						return this;
					}

					closestPointToPoint(point, target) {
						target.subVectors(point, this.origin);

						const directionDistance = target.dot(this.direction);

						if (directionDistance < 0) {
							return target.copy(this.origin);
						}

						return target
							.copy(this.origin)
							.addScaledVector(this.direction, directionDistance);
					}

					distanceToPoint(point) {
						return Math.sqrt(this.distanceSqToPoint(point));
					}

					distanceSqToPoint(point) {
						const directionDistance = _vector
							.subVectors(point, this.origin)
							.dot(this.direction);

						// point behind the ray

						if (directionDistance < 0) {
							return this.origin.distanceToSquared(point);
						}

						_vector
							.copy(this.origin)
							.addScaledVector(this.direction, directionDistance);

						return _vector.distanceToSquared(point);
					}

					distanceSqToSegment(
						v0,
						v1,
						optionalPointOnRay,
						optionalPointOnSegment
					) {
						// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
						// It returns the min distance between the ray and the segment
						// defined by v0 and v1
						// It can also set two optional targets :
						// - The closest point on the ray
						// - The closest point on the segment

						_segCenter.copy(v0).add(v1).multiplyScalar(0.5);
						_segDir.copy(v1).sub(v0).normalize();
						_diff.copy(this.origin).sub(_segCenter);

						const segExtent = v0.distanceTo(v1) * 0.5;
						const a01 = -this.direction.dot(_segDir);
						const b0 = _diff.dot(this.direction);
						const b1 = -_diff.dot(_segDir);
						const c = _diff.lengthSq();
						const det = Math.abs(1 - a01 * a01);
						let s0, s1, sqrDist, extDet;

						if (det > 0) {
							// The ray and segment are not parallel.

							s0 = a01 * b1 - b0;
							s1 = a01 * b0 - b1;
							extDet = segExtent * det;

							if (s0 >= 0) {
								if (s1 >= -extDet) {
									if (s1 <= extDet) {
										// region 0
										// Minimum at interior points of ray and segment.

										const invDet = 1 / det;
										s0 *= invDet;
										s1 *= invDet;
										sqrDist =
											s0 * (s0 + a01 * s1 + 2 * b0) +
											s1 * (a01 * s0 + s1 + 2 * b1) +
											c;
									} else {
										// region 1

										s1 = segExtent;
										s0 = Math.max(0, -(a01 * s1 + b0));
										sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
									}
								} else {
									// region 5

									s1 = -segExtent;
									s0 = Math.max(0, -(a01 * s1 + b0));
									sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
								}
							} else {
								if (s1 <= -extDet) {
									// region 4

									s0 = Math.max(0, -(-a01 * segExtent + b0));
									s1 =
										s0 > 0
											? -segExtent
											: Math.min(Math.max(-segExtent, -b1), segExtent);
									sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
								} else if (s1 <= extDet) {
									// region 3

									s0 = 0;
									s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
									sqrDist = s1 * (s1 + 2 * b1) + c;
								} else {
									// region 2

									s0 = Math.max(0, -(a01 * segExtent + b0));
									s1 =
										s0 > 0
											? segExtent
											: Math.min(Math.max(-segExtent, -b1), segExtent);
									sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
								}
							}
						} else {
							// Ray and segment are parallel.

							s1 = a01 > 0 ? -segExtent : segExtent;
							s0 = Math.max(0, -(a01 * s1 + b0));
							sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
						}

						if (optionalPointOnRay) {
							optionalPointOnRay
								.copy(this.origin)
								.addScaledVector(this.direction, s0);
						}

						if (optionalPointOnSegment) {
							optionalPointOnSegment
								.copy(_segCenter)
								.addScaledVector(_segDir, s1);
						}

						return sqrDist;
					}

					intersectSphere(sphere, target) {
						_vector.subVectors(sphere.center, this.origin);
						const tca = _vector.dot(this.direction);
						const d2 = _vector.dot(_vector) - tca * tca;
						const radius2 = sphere.radius * sphere.radius;

						if (d2 > radius2) return null;

						const thc = Math.sqrt(radius2 - d2);

						// t0 = first intersect point - entrance on front of sphere
						const t0 = tca - thc;

						// t1 = second intersect point - exit point on back of sphere
						const t1 = tca + thc;

						// test to see if t1 is behind the ray - if so, return null
						if (t1 < 0) return null;

						// test to see if t0 is behind the ray:
						// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
						// in order to always return an intersect point that is in front of the ray.
						if (t0 < 0) return this.at(t1, target);

						// else t0 is in front of the ray, so return the first collision point scaled by t0
						return this.at(t0, target);
					}

					intersectsSphere(sphere) {
						return (
							this.distanceSqToPoint(sphere.center) <=
							sphere.radius * sphere.radius
						);
					}

					distanceToPlane(plane) {
						const denominator = plane.normal.dot(this.direction);

						if (denominator === 0) {
							// line is coplanar, return origin
							if (plane.distanceToPoint(this.origin) === 0) {
								return 0;
							}

							// Null is preferable to undefined since undefined means.... it is undefined

							return null;
						}

						const t =
							-(this.origin.dot(plane.normal) + plane.constant) / denominator;

						// Return if the ray never intersects the plane

						return t >= 0 ? t : null;
					}

					intersectPlane(plane, target) {
						const t = this.distanceToPlane(plane);

						if (t === null) {
							return null;
						}

						return this.at(t, target);
					}

					intersectsPlane(plane) {
						// check if the ray lies on the plane first

						const distToPoint = plane.distanceToPoint(this.origin);

						if (distToPoint === 0) {
							return true;
						}

						const denominator = plane.normal.dot(this.direction);

						if (denominator * distToPoint < 0) {
							return true;
						}

						// ray origin is behind the plane (and is pointing behind it)

						return false;
					}

					intersectBox(box, target) {
						let tmin, tmax, tymin, tymax, tzmin, tzmax;

						const invdirx = 1 / this.direction.x,
							invdiry = 1 / this.direction.y,
							invdirz = 1 / this.direction.z;

						const origin = this.origin;

						if (invdirx >= 0) {
							tmin = (box.min.x - origin.x) * invdirx;
							tmax = (box.max.x - origin.x) * invdirx;
						} else {
							tmin = (box.max.x - origin.x) * invdirx;
							tmax = (box.min.x - origin.x) * invdirx;
						}

						if (invdiry >= 0) {
							tymin = (box.min.y - origin.y) * invdiry;
							tymax = (box.max.y - origin.y) * invdiry;
						} else {
							tymin = (box.max.y - origin.y) * invdiry;
							tymax = (box.min.y - origin.y) * invdiry;
						}

						if (tmin > tymax || tymin > tmax) return null;

						if (tymin > tmin || isNaN(tmin)) tmin = tymin;

						if (tymax < tmax || isNaN(tmax)) tmax = tymax;

						if (invdirz >= 0) {
							tzmin = (box.min.z - origin.z) * invdirz;
							tzmax = (box.max.z - origin.z) * invdirz;
						} else {
							tzmin = (box.max.z - origin.z) * invdirz;
							tzmax = (box.min.z - origin.z) * invdirz;
						}

						if (tmin > tzmax || tzmin > tmax) return null;

						if (tzmin > tmin || tmin !== tmin) tmin = tzmin;

						if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

						//return point closest to the ray (positive side)

						if (tmax < 0) return null;

						return this.at(tmin >= 0 ? tmin : tmax, target);
					}

					intersectsBox(box) {
						return this.intersectBox(box, _vector) !== null;
					}

					intersectTriangle(a, b, c, backfaceCulling, target) {
						// Compute the offset origin, edges, and normal.

						// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

						_edge1.subVectors(b, a);
						_edge2.subVectors(c, a);
						_normal.crossVectors(_edge1, _edge2);

						// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
						// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
						//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
						//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
						//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
						let DdN = this.direction.dot(_normal);
						let sign;

						if (DdN > 0) {
							if (backfaceCulling) return null;
							sign = 1;
						} else if (DdN < 0) {
							sign = -1;
							DdN = -DdN;
						} else {
							return null;
						}

						_diff.subVectors(this.origin, a);
						const DdQxE2 =
							sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));

						// b1 < 0, no intersection
						if (DdQxE2 < 0) {
							return null;
						}

						const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));

						// b2 < 0, no intersection
						if (DdE1xQ < 0) {
							return null;
						}

						// b1+b2 > 1, no intersection
						if (DdQxE2 + DdE1xQ > DdN) {
							return null;
						}

						// Line intersects triangle, check if ray does.
						const QdN = -sign * _diff.dot(_normal);

						// t < 0, no intersection
						if (QdN < 0) {
							return null;
						}

						// Ray intersects triangle.
						return this.at(QdN / DdN, target);
					}

					applyMatrix4(matrix4) {
						this.origin.applyMatrix4(matrix4);
						this.direction.transformDirection(matrix4);

						return this;
					}

					equals(ray) {
						return (
							ray.origin.equals(this.origin) &&
							ray.direction.equals(this.direction)
						);
					}

					clone() {
						return new this.constructor().copy(this);
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Sphere.js":
			/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Sphere.js ***!
  \************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Sphere: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Sphere"] */ Sphere
				});
				/* ESM import */ var _Box3_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Box3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Box3.js"
					);
				/* ESM import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Vector3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector3.js"
					);

				const _box =
					/*@__PURE__*/ new _Box3_js__WEBPACK_IMPORTED_MODULE_0__.Box3();
				const _v1 =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__.Vector3();
				const _v2 =
					/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__.Vector3();

				class Sphere {
					constructor(
						center = new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__.Vector3(),
						radius = -1
					) {
						this.isSphere = true;

						this.center = center;
						this.radius = radius;
					}

					set(center, radius) {
						this.center.copy(center);
						this.radius = radius;

						return this;
					}

					setFromPoints(points, optionalCenter) {
						const center = this.center;

						if (optionalCenter !== undefined) {
							center.copy(optionalCenter);
						} else {
							_box.setFromPoints(points).getCenter(center);
						}

						let maxRadiusSq = 0;

						for (let i = 0, il = points.length; i < il; i++) {
							maxRadiusSq = Math.max(
								maxRadiusSq,
								center.distanceToSquared(points[i])
							);
						}

						this.radius = Math.sqrt(maxRadiusSq);

						return this;
					}

					copy(sphere) {
						this.center.copy(sphere.center);
						this.radius = sphere.radius;

						return this;
					}

					isEmpty() {
						return this.radius < 0;
					}

					makeEmpty() {
						this.center.set(0, 0, 0);
						this.radius = -1;

						return this;
					}

					containsPoint(point) {
						return (
							point.distanceToSquared(this.center) <= this.radius * this.radius
						);
					}

					distanceToPoint(point) {
						return point.distanceTo(this.center) - this.radius;
					}

					intersectsSphere(sphere) {
						const radiusSum = this.radius + sphere.radius;

						return (
							sphere.center.distanceToSquared(this.center) <=
							radiusSum * radiusSum
						);
					}

					intersectsBox(box) {
						return box.intersectsSphere(this);
					}

					intersectsPlane(plane) {
						return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
					}

					clampPoint(point, target) {
						const deltaLengthSq = this.center.distanceToSquared(point);

						target.copy(point);

						if (deltaLengthSq > this.radius * this.radius) {
							target.sub(this.center).normalize();
							target.multiplyScalar(this.radius).add(this.center);
						}

						return target;
					}

					getBoundingBox(target) {
						if (this.isEmpty()) {
							// Empty sphere produces empty bounding box
							target.makeEmpty();
							return target;
						}

						target.set(this.center, this.center);
						target.expandByScalar(this.radius);

						return target;
					}

					applyMatrix4(matrix) {
						this.center.applyMatrix4(matrix);
						this.radius = this.radius * matrix.getMaxScaleOnAxis();

						return this;
					}

					translate(offset) {
						this.center.add(offset);

						return this;
					}

					expandByPoint(point) {
						if (this.isEmpty()) {
							this.center.copy(point);

							this.radius = 0;

							return this;
						}

						_v1.subVectors(point, this.center);

						const lengthSq = _v1.lengthSq();

						if (lengthSq > this.radius * this.radius) {
							// calculate the minimal sphere

							const length = Math.sqrt(lengthSq);

							const delta = (length - this.radius) * 0.5;

							this.center.addScaledVector(_v1, delta / length);

							this.radius += delta;
						}

						return this;
					}

					union(sphere) {
						if (sphere.isEmpty()) {
							return this;
						}

						if (this.isEmpty()) {
							this.copy(sphere);

							return this;
						}

						if (this.center.equals(sphere.center) === true) {
							this.radius = Math.max(this.radius, sphere.radius);
						} else {
							_v2
								.subVectors(sphere.center, this.center)
								.setLength(sphere.radius);

							this.expandByPoint(_v1.copy(sphere.center).add(_v2));

							this.expandByPoint(_v1.copy(sphere.center).sub(_v2));
						}

						return this;
					}

					equals(sphere) {
						return (
							sphere.center.equals(this.center) && sphere.radius === this.radius
						);
					}

					clone() {
						return new this.constructor().copy(this);
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector2.js":
			/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector2.js ***!
  \*************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Vector2: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Vector2"] */ Vector2
				});
				/* ESM import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./MathUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/MathUtils.js"
					);

				class Vector2 {
					constructor(x = 0, y = 0) {
						Vector2.prototype.isVector2 = true;

						this.x = x;
						this.y = y;
					}

					get width() {
						return this.x;
					}

					set width(value) {
						this.x = value;
					}

					get height() {
						return this.y;
					}

					set height(value) {
						this.y = value;
					}

					set(x, y) {
						this.x = x;
						this.y = y;

						return this;
					}

					setScalar(scalar) {
						this.x = scalar;
						this.y = scalar;

						return this;
					}

					setX(x) {
						this.x = x;

						return this;
					}

					setY(y) {
						this.y = y;

						return this;
					}

					setComponent(index, value) {
						switch (index) {
							case 0:
								this.x = value;
								break;
							case 1:
								this.y = value;
								break;
							default:
								throw new Error("index is out of range: " + index);
						}

						return this;
					}

					getComponent(index) {
						switch (index) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							default:
								throw new Error("index is out of range: " + index);
						}
					}

					clone() {
						return new this.constructor(this.x, this.y);
					}

					copy(v) {
						this.x = v.x;
						this.y = v.y;

						return this;
					}

					add(v) {
						this.x += v.x;
						this.y += v.y;

						return this;
					}

					addScalar(s) {
						this.x += s;
						this.y += s;

						return this;
					}

					addVectors(a, b) {
						this.x = a.x + b.x;
						this.y = a.y + b.y;

						return this;
					}

					addScaledVector(v, s) {
						this.x += v.x * s;
						this.y += v.y * s;

						return this;
					}

					sub(v) {
						this.x -= v.x;
						this.y -= v.y;

						return this;
					}

					subScalar(s) {
						this.x -= s;
						this.y -= s;

						return this;
					}

					subVectors(a, b) {
						this.x = a.x - b.x;
						this.y = a.y - b.y;

						return this;
					}

					multiply(v) {
						this.x *= v.x;
						this.y *= v.y;

						return this;
					}

					multiplyScalar(scalar) {
						this.x *= scalar;
						this.y *= scalar;

						return this;
					}

					divide(v) {
						this.x /= v.x;
						this.y /= v.y;

						return this;
					}

					divideScalar(scalar) {
						return this.multiplyScalar(1 / scalar);
					}

					applyMatrix3(m) {
						const x = this.x,
							y = this.y;
						const e = m.elements;

						this.x = e[0] * x + e[3] * y + e[6];
						this.y = e[1] * x + e[4] * y + e[7];

						return this;
					}

					min(v) {
						this.x = Math.min(this.x, v.x);
						this.y = Math.min(this.y, v.y);

						return this;
					}

					max(v) {
						this.x = Math.max(this.x, v.x);
						this.y = Math.max(this.y, v.y);

						return this;
					}

					clamp(min, max) {
						// assumes min < max, componentwise

						this.x = Math.max(min.x, Math.min(max.x, this.x));
						this.y = Math.max(min.y, Math.min(max.y, this.y));

						return this;
					}

					clampScalar(minVal, maxVal) {
						this.x = Math.max(minVal, Math.min(maxVal, this.x));
						this.y = Math.max(minVal, Math.min(maxVal, this.y));

						return this;
					}

					clampLength(min, max) {
						const length = this.length();

						return this.divideScalar(length || 1).multiplyScalar(
							Math.max(min, Math.min(max, length))
						);
					}

					floor() {
						this.x = Math.floor(this.x);
						this.y = Math.floor(this.y);

						return this;
					}

					ceil() {
						this.x = Math.ceil(this.x);
						this.y = Math.ceil(this.y);

						return this;
					}

					round() {
						this.x = Math.round(this.x);
						this.y = Math.round(this.y);

						return this;
					}

					roundToZero() {
						this.x = Math.trunc(this.x);
						this.y = Math.trunc(this.y);

						return this;
					}

					negate() {
						this.x = -this.x;
						this.y = -this.y;

						return this;
					}

					dot(v) {
						return this.x * v.x + this.y * v.y;
					}

					cross(v) {
						return this.x * v.y - this.y * v.x;
					}

					lengthSq() {
						return this.x * this.x + this.y * this.y;
					}

					length() {
						return Math.sqrt(this.x * this.x + this.y * this.y);
					}

					manhattanLength() {
						return Math.abs(this.x) + Math.abs(this.y);
					}

					normalize() {
						return this.divideScalar(this.length() || 1);
					}

					angle() {
						// computes the angle in radians with respect to the positive x-axis

						const angle = Math.atan2(-this.y, -this.x) + Math.PI;

						return angle;
					}

					angleTo(v) {
						const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());

						if (denominator === 0) return Math.PI / 2;

						const theta = this.dot(v) / denominator;

						// clamp, to handle numerical problems

						return Math.acos(
							_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__.clamp(theta, -1, 1)
						);
					}

					distanceTo(v) {
						return Math.sqrt(this.distanceToSquared(v));
					}

					distanceToSquared(v) {
						const dx = this.x - v.x,
							dy = this.y - v.y;
						return dx * dx + dy * dy;
					}

					manhattanDistanceTo(v) {
						return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
					}

					setLength(length) {
						return this.normalize().multiplyScalar(length);
					}

					lerp(v, alpha) {
						this.x += (v.x - this.x) * alpha;
						this.y += (v.y - this.y) * alpha;

						return this;
					}

					lerpVectors(v1, v2, alpha) {
						this.x = v1.x + (v2.x - v1.x) * alpha;
						this.y = v1.y + (v2.y - v1.y) * alpha;

						return this;
					}

					equals(v) {
						return v.x === this.x && v.y === this.y;
					}

					fromArray(array, offset = 0) {
						this.x = array[offset];
						this.y = array[offset + 1];

						return this;
					}

					toArray(array = [], offset = 0) {
						array[offset] = this.x;
						array[offset + 1] = this.y;

						return array;
					}

					fromBufferAttribute(attribute, index) {
						this.x = attribute.getX(index);
						this.y = attribute.getY(index);

						return this;
					}

					rotateAround(center, angle) {
						const c = Math.cos(angle),
							s = Math.sin(angle);

						const x = this.x - center.x;
						const y = this.y - center.y;

						this.x = x * c - y * s + center.x;
						this.y = x * s + y * c + center.y;

						return this;
					}

					random() {
						this.x = Math.random();
						this.y = Math.random();

						return this;
					}

					*[Symbol.iterator]() {
						yield this.x;
						yield this.y;
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector3.js":
			/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector3.js ***!
  \*************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Vector3: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Vector3"] */ Vector3
				});
				/* ESM import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./MathUtils.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/MathUtils.js"
					);
				/* ESM import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Quaternion.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Quaternion.js"
					);

				class Vector3 {
					constructor(x = 0, y = 0, z = 0) {
						Vector3.prototype.isVector3 = true;

						this.x = x;
						this.y = y;
						this.z = z;
					}

					set(x, y, z) {
						if (z === undefined) z = this.z; // sprite.scale.set(x,y)

						this.x = x;
						this.y = y;
						this.z = z;

						return this;
					}

					setScalar(scalar) {
						this.x = scalar;
						this.y = scalar;
						this.z = scalar;

						return this;
					}

					setX(x) {
						this.x = x;

						return this;
					}

					setY(y) {
						this.y = y;

						return this;
					}

					setZ(z) {
						this.z = z;

						return this;
					}

					setComponent(index, value) {
						switch (index) {
							case 0:
								this.x = value;
								break;
							case 1:
								this.y = value;
								break;
							case 2:
								this.z = value;
								break;
							default:
								throw new Error("index is out of range: " + index);
						}

						return this;
					}

					getComponent(index) {
						switch (index) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							case 2:
								return this.z;
							default:
								throw new Error("index is out of range: " + index);
						}
					}

					clone() {
						return new this.constructor(this.x, this.y, this.z);
					}

					copy(v) {
						this.x = v.x;
						this.y = v.y;
						this.z = v.z;

						return this;
					}

					add(v) {
						this.x += v.x;
						this.y += v.y;
						this.z += v.z;

						return this;
					}

					addScalar(s) {
						this.x += s;
						this.y += s;
						this.z += s;

						return this;
					}

					addVectors(a, b) {
						this.x = a.x + b.x;
						this.y = a.y + b.y;
						this.z = a.z + b.z;

						return this;
					}

					addScaledVector(v, s) {
						this.x += v.x * s;
						this.y += v.y * s;
						this.z += v.z * s;

						return this;
					}

					sub(v) {
						this.x -= v.x;
						this.y -= v.y;
						this.z -= v.z;

						return this;
					}

					subScalar(s) {
						this.x -= s;
						this.y -= s;
						this.z -= s;

						return this;
					}

					subVectors(a, b) {
						this.x = a.x - b.x;
						this.y = a.y - b.y;
						this.z = a.z - b.z;

						return this;
					}

					multiply(v) {
						this.x *= v.x;
						this.y *= v.y;
						this.z *= v.z;

						return this;
					}

					multiplyScalar(scalar) {
						this.x *= scalar;
						this.y *= scalar;
						this.z *= scalar;

						return this;
					}

					multiplyVectors(a, b) {
						this.x = a.x * b.x;
						this.y = a.y * b.y;
						this.z = a.z * b.z;

						return this;
					}

					applyEuler(euler) {
						return this.applyQuaternion(_quaternion.setFromEuler(euler));
					}

					applyAxisAngle(axis, angle) {
						return this.applyQuaternion(
							_quaternion.setFromAxisAngle(axis, angle)
						);
					}

					applyMatrix3(m) {
						const x = this.x,
							y = this.y,
							z = this.z;
						const e = m.elements;

						this.x = e[0] * x + e[3] * y + e[6] * z;
						this.y = e[1] * x + e[4] * y + e[7] * z;
						this.z = e[2] * x + e[5] * y + e[8] * z;

						return this;
					}

					applyNormalMatrix(m) {
						return this.applyMatrix3(m).normalize();
					}

					applyMatrix4(m) {
						const x = this.x,
							y = this.y,
							z = this.z;
						const e = m.elements;

						const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);

						this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
						this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
						this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;

						return this;
					}

					applyQuaternion(q) {
						// quaternion q is assumed to have unit length

						const vx = this.x,
							vy = this.y,
							vz = this.z;
						const qx = q.x,
							qy = q.y,
							qz = q.z,
							qw = q.w;

						// t = 2 * cross( q.xyz, v );
						const tx = 2 * (qy * vz - qz * vy);
						const ty = 2 * (qz * vx - qx * vz);
						const tz = 2 * (qx * vy - qy * vx);

						// v + q.w * t + cross( q.xyz, t );
						this.x = vx + qw * tx + qy * tz - qz * ty;
						this.y = vy + qw * ty + qz * tx - qx * tz;
						this.z = vz + qw * tz + qx * ty - qy * tx;

						return this;
					}

					project(camera) {
						return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(
							camera.projectionMatrix
						);
					}

					unproject(camera) {
						return this.applyMatrix4(
							camera.projectionMatrixInverse
						).applyMatrix4(camera.matrixWorld);
					}

					transformDirection(m) {
						// input: THREE.Matrix4 affine matrix
						// vector interpreted as a direction

						const x = this.x,
							y = this.y,
							z = this.z;
						const e = m.elements;

						this.x = e[0] * x + e[4] * y + e[8] * z;
						this.y = e[1] * x + e[5] * y + e[9] * z;
						this.z = e[2] * x + e[6] * y + e[10] * z;

						return this.normalize();
					}

					divide(v) {
						this.x /= v.x;
						this.y /= v.y;
						this.z /= v.z;

						return this;
					}

					divideScalar(scalar) {
						return this.multiplyScalar(1 / scalar);
					}

					min(v) {
						this.x = Math.min(this.x, v.x);
						this.y = Math.min(this.y, v.y);
						this.z = Math.min(this.z, v.z);

						return this;
					}

					max(v) {
						this.x = Math.max(this.x, v.x);
						this.y = Math.max(this.y, v.y);
						this.z = Math.max(this.z, v.z);

						return this;
					}

					clamp(min, max) {
						// assumes min < max, componentwise

						this.x = Math.max(min.x, Math.min(max.x, this.x));
						this.y = Math.max(min.y, Math.min(max.y, this.y));
						this.z = Math.max(min.z, Math.min(max.z, this.z));

						return this;
					}

					clampScalar(minVal, maxVal) {
						this.x = Math.max(minVal, Math.min(maxVal, this.x));
						this.y = Math.max(minVal, Math.min(maxVal, this.y));
						this.z = Math.max(minVal, Math.min(maxVal, this.z));

						return this;
					}

					clampLength(min, max) {
						const length = this.length();

						return this.divideScalar(length || 1).multiplyScalar(
							Math.max(min, Math.min(max, length))
						);
					}

					floor() {
						this.x = Math.floor(this.x);
						this.y = Math.floor(this.y);
						this.z = Math.floor(this.z);

						return this;
					}

					ceil() {
						this.x = Math.ceil(this.x);
						this.y = Math.ceil(this.y);
						this.z = Math.ceil(this.z);

						return this;
					}

					round() {
						this.x = Math.round(this.x);
						this.y = Math.round(this.y);
						this.z = Math.round(this.z);

						return this;
					}

					roundToZero() {
						this.x = Math.trunc(this.x);
						this.y = Math.trunc(this.y);
						this.z = Math.trunc(this.z);

						return this;
					}

					negate() {
						this.x = -this.x;
						this.y = -this.y;
						this.z = -this.z;

						return this;
					}

					dot(v) {
						return this.x * v.x + this.y * v.y + this.z * v.z;
					}

					// TODO lengthSquared?

					lengthSq() {
						return this.x * this.x + this.y * this.y + this.z * this.z;
					}

					length() {
						return Math.sqrt(
							this.x * this.x + this.y * this.y + this.z * this.z
						);
					}

					manhattanLength() {
						return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
					}

					normalize() {
						return this.divideScalar(this.length() || 1);
					}

					setLength(length) {
						return this.normalize().multiplyScalar(length);
					}

					lerp(v, alpha) {
						this.x += (v.x - this.x) * alpha;
						this.y += (v.y - this.y) * alpha;
						this.z += (v.z - this.z) * alpha;

						return this;
					}

					lerpVectors(v1, v2, alpha) {
						this.x = v1.x + (v2.x - v1.x) * alpha;
						this.y = v1.y + (v2.y - v1.y) * alpha;
						this.z = v1.z + (v2.z - v1.z) * alpha;

						return this;
					}

					cross(v) {
						return this.crossVectors(this, v);
					}

					crossVectors(a, b) {
						const ax = a.x,
							ay = a.y,
							az = a.z;
						const bx = b.x,
							by = b.y,
							bz = b.z;

						this.x = ay * bz - az * by;
						this.y = az * bx - ax * bz;
						this.z = ax * by - ay * bx;

						return this;
					}

					projectOnVector(v) {
						const denominator = v.lengthSq();

						if (denominator === 0) return this.set(0, 0, 0);

						const scalar = v.dot(this) / denominator;

						return this.copy(v).multiplyScalar(scalar);
					}

					projectOnPlane(planeNormal) {
						_vector.copy(this).projectOnVector(planeNormal);

						return this.sub(_vector);
					}

					reflect(normal) {
						// reflect incident vector off plane orthogonal to normal
						// normal is assumed to have unit length

						return this.sub(
							_vector.copy(normal).multiplyScalar(2 * this.dot(normal))
						);
					}

					angleTo(v) {
						const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());

						if (denominator === 0) return Math.PI / 2;

						const theta = this.dot(v) / denominator;

						// clamp, to handle numerical problems

						return Math.acos(
							_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__.clamp(theta, -1, 1)
						);
					}

					distanceTo(v) {
						return Math.sqrt(this.distanceToSquared(v));
					}

					distanceToSquared(v) {
						const dx = this.x - v.x,
							dy = this.y - v.y,
							dz = this.z - v.z;

						return dx * dx + dy * dy + dz * dz;
					}

					manhattanDistanceTo(v) {
						return (
							Math.abs(this.x - v.x) +
							Math.abs(this.y - v.y) +
							Math.abs(this.z - v.z)
						);
					}

					setFromSpherical(s) {
						return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
					}

					setFromSphericalCoords(radius, phi, theta) {
						const sinPhiRadius = Math.sin(phi) * radius;

						this.x = sinPhiRadius * Math.sin(theta);
						this.y = Math.cos(phi) * radius;
						this.z = sinPhiRadius * Math.cos(theta);

						return this;
					}

					setFromCylindrical(c) {
						return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
					}

					setFromCylindricalCoords(radius, theta, y) {
						this.x = radius * Math.sin(theta);
						this.y = y;
						this.z = radius * Math.cos(theta);

						return this;
					}

					setFromMatrixPosition(m) {
						const e = m.elements;

						this.x = e[12];
						this.y = e[13];
						this.z = e[14];

						return this;
					}

					setFromMatrixScale(m) {
						const sx = this.setFromMatrixColumn(m, 0).length();
						const sy = this.setFromMatrixColumn(m, 1).length();
						const sz = this.setFromMatrixColumn(m, 2).length();

						this.x = sx;
						this.y = sy;
						this.z = sz;

						return this;
					}

					setFromMatrixColumn(m, index) {
						return this.fromArray(m.elements, index * 4);
					}

					setFromMatrix3Column(m, index) {
						return this.fromArray(m.elements, index * 3);
					}

					setFromEuler(e) {
						this.x = e._x;
						this.y = e._y;
						this.z = e._z;

						return this;
					}

					setFromColor(c) {
						this.x = c.r;
						this.y = c.g;
						this.z = c.b;

						return this;
					}

					equals(v) {
						return v.x === this.x && v.y === this.y && v.z === this.z;
					}

					fromArray(array, offset = 0) {
						this.x = array[offset];
						this.y = array[offset + 1];
						this.z = array[offset + 2];

						return this;
					}

					toArray(array = [], offset = 0) {
						array[offset] = this.x;
						array[offset + 1] = this.y;
						array[offset + 2] = this.z;

						return array;
					}

					fromBufferAttribute(attribute, index) {
						this.x = attribute.getX(index);
						this.y = attribute.getY(index);
						this.z = attribute.getZ(index);

						return this;
					}

					random() {
						this.x = Math.random();
						this.y = Math.random();
						this.z = Math.random();

						return this;
					}

					randomDirection() {
						// https://mathworld.wolfram.com/SpherePointPicking.html

						const theta = Math.random() * Math.PI * 2;
						const u = Math.random() * 2 - 1;
						const c = Math.sqrt(1 - u * u);

						this.x = c * Math.cos(theta);
						this.y = u;
						this.z = c * Math.sin(theta);

						return this;
					}

					*[Symbol.iterator]() {
						yield this.x;
						yield this.y;
						yield this.z;
					}
				}

				const _vector = /*@__PURE__*/ new Vector3();
				const _quaternion =
					/*@__PURE__*/ new _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/objects/Line.js":
			/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/objects/Line.js ***!
  \*************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					Line: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.Line"] */ Line
				});
				/* ESM import */ var _math_Sphere_js__WEBPACK_IMPORTED_MODULE_3__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Sphere.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Sphere.js"
					);
				/* ESM import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_2__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Ray.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Ray.js"
					);
				/* ESM import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Matrix4.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Matrix4.js"
					);
				/* ESM import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_4__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../core/Object3D.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/Object3D.js"
					);
				/* ESM import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Vector3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector3.js"
					);
				/* ESM import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_6__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../materials/LineBasicMaterial.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/materials/LineBasicMaterial.js"
					);
				/* ESM import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../core/BufferGeometry.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/BufferGeometry.js"
					);
				/* ESM import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../core/BufferAttribute.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/BufferAttribute.js"
					);

				const _vStart =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _vEnd =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();

				const _inverseMatrix =
					/*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
				const _ray =
					/*@__PURE__*/ new _math_Ray_js__WEBPACK_IMPORTED_MODULE_2__.Ray();
				const _sphere =
					/*@__PURE__*/ new _math_Sphere_js__WEBPACK_IMPORTED_MODULE_3__.Sphere();

				const _intersectPointOnRay =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _intersectPointOnSegment =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();

				class Line extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_4__.Object3D {
					constructor(
						geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__.BufferGeometry(),
						material = new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_6__.LineBasicMaterial()
					) {
						super();

						this.isLine = true;

						this.type = "Line";

						this.geometry = geometry;
						this.material = material;

						this.updateMorphTargets();
					}

					copy(source, recursive) {
						super.copy(source, recursive);

						this.material = Array.isArray(source.material)
							? source.material.slice()
							: source.material;
						this.geometry = source.geometry;

						return this;
					}

					computeLineDistances() {
						const geometry = this.geometry;

						// we assume non-indexed geometry

						if (geometry.index === null) {
							const positionAttribute = geometry.attributes.position;
							const lineDistances = [0];

							for (let i = 1, l = positionAttribute.count; i < l; i++) {
								_vStart.fromBufferAttribute(positionAttribute, i - 1);
								_vEnd.fromBufferAttribute(positionAttribute, i);

								lineDistances[i] = lineDistances[i - 1];
								lineDistances[i] += _vStart.distanceTo(_vEnd);
							}

							geometry.setAttribute(
								"lineDistance",
								new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__.Float32BufferAttribute(
									lineDistances,
									1
								)
							);
						} else {
							console.warn(
								"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
							);
						}

						return this;
					}

					raycast(raycaster, intersects) {
						const geometry = this.geometry;
						const matrixWorld = this.matrixWorld;
						const threshold = raycaster.params.Line.threshold;
						const drawRange = geometry.drawRange;

						// Checking boundingSphere distance to ray

						if (geometry.boundingSphere === null)
							geometry.computeBoundingSphere();

						_sphere.copy(geometry.boundingSphere);
						_sphere.applyMatrix4(matrixWorld);
						_sphere.radius += threshold;

						if (raycaster.ray.intersectsSphere(_sphere) === false) return;

						//

						_inverseMatrix.copy(matrixWorld).invert();
						_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);

						const localThreshold =
							threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
						const localThresholdSq = localThreshold * localThreshold;

						const step = this.isLineSegments ? 2 : 1;

						const index = geometry.index;
						const attributes = geometry.attributes;
						const positionAttribute = attributes.position;

						if (index !== null) {
							const start = Math.max(0, drawRange.start);
							const end = Math.min(
								index.count,
								drawRange.start + drawRange.count
							);

							for (let i = start, l = end - 1; i < l; i += step) {
								const a = index.getX(i);
								const b = index.getX(i + 1);

								const intersect = checkIntersection(
									this,
									raycaster,
									_ray,
									localThresholdSq,
									a,
									b
								);

								if (intersect) {
									intersects.push(intersect);
								}
							}

							if (this.isLineLoop) {
								const a = index.getX(end - 1);
								const b = index.getX(start);

								const intersect = checkIntersection(
									this,
									raycaster,
									_ray,
									localThresholdSq,
									a,
									b
								);

								if (intersect) {
									intersects.push(intersect);
								}
							}
						} else {
							const start = Math.max(0, drawRange.start);
							const end = Math.min(
								positionAttribute.count,
								drawRange.start + drawRange.count
							);

							for (let i = start, l = end - 1; i < l; i += step) {
								const intersect = checkIntersection(
									this,
									raycaster,
									_ray,
									localThresholdSq,
									i,
									i + 1
								);

								if (intersect) {
									intersects.push(intersect);
								}
							}

							if (this.isLineLoop) {
								const intersect = checkIntersection(
									this,
									raycaster,
									_ray,
									localThresholdSq,
									end - 1,
									start
								);

								if (intersect) {
									intersects.push(intersect);
								}
							}
						}
					}

					updateMorphTargets() {
						const geometry = this.geometry;

						const morphAttributes = geometry.morphAttributes;
						const keys = Object.keys(morphAttributes);

						if (keys.length > 0) {
							const morphAttribute = morphAttributes[keys[0]];

							if (morphAttribute !== undefined) {
								this.morphTargetInfluences = [];
								this.morphTargetDictionary = {};

								for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
									const name = morphAttribute[m].name || String(m);

									this.morphTargetInfluences.push(0);
									this.morphTargetDictionary[name] = m;
								}
							}
						}
					}
				}

				function checkIntersection(object, raycaster, ray, thresholdSq, a, b) {
					const positionAttribute = object.geometry.attributes.position;

					_vStart.fromBufferAttribute(positionAttribute, a);
					_vEnd.fromBufferAttribute(positionAttribute, b);

					const distSq = ray.distanceSqToSegment(
						_vStart,
						_vEnd,
						_intersectPointOnRay,
						_intersectPointOnSegment
					);

					if (distSq > thresholdSq) return;

					_intersectPointOnRay.applyMatrix4(object.matrixWorld); // Move back to world space for distance calculation

					const distance =
						raycaster.ray.origin.distanceTo(_intersectPointOnRay);

					if (distance < raycaster.near || distance > raycaster.far) return;

					return {
						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: _intersectPointOnSegment
							.clone()
							.applyMatrix4(object.matrixWorld),
						index: a,
						face: null,
						faceIndex: null,
						barycoord: null,
						object: object
					};
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/objects/LineSegments.js":
			/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/objects/LineSegments.js ***!
  \*********************************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					LineSegments: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.LineSegments"] */ LineSegments
				});
				/* ESM import */ var _Line_js__WEBPACK_IMPORTED_MODULE_1__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ./Line.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/objects/Line.js"
					);
				/* ESM import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../math/Vector3.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/math/Vector3.js"
					);
				/* ESM import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__ =
					/* #__PURE__ */ __webpack_require__(
						/*! ../core/BufferAttribute.js */ "../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/core/BufferAttribute.js"
					);

				const _start =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
				const _end =
					/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();

				class LineSegments extends _Line_js__WEBPACK_IMPORTED_MODULE_1__.Line {
					constructor(geometry, material) {
						super(geometry, material);

						this.isLineSegments = true;

						this.type = "LineSegments";
					}

					computeLineDistances() {
						const geometry = this.geometry;

						// we assume non-indexed geometry

						if (geometry.index === null) {
							const positionAttribute = geometry.attributes.position;
							const lineDistances = [];

							for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
								_start.fromBufferAttribute(positionAttribute, i);
								_end.fromBufferAttribute(positionAttribute, i + 1);

								lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
								lineDistances[i + 1] =
									lineDistances[i] + _start.distanceTo(_end);
							}

							geometry.setAttribute(
								"lineDistance",
								new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(
									lineDistances,
									1
								)
							);
						} else {
							console.warn(
								"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
							);
						}

						return this;
					}
				}
			},
		"../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/utils.js":
			/*!******************************************************************************!*\
  !*** ../../node_modules/.pnpm/three@0.169.0/node_modules/three/src/utils.js ***!
  \******************************************************************************/
			function (
				__unused_webpack___webpack_module__,
				__webpack_exports__,
				__webpack_require__
			) {
				__webpack_require__.d(__webpack_exports__, {
					arrayNeedsUint32: (/* @common:endif */) =>
						/* @common:if [condition="treeShake.three/src/helpers/BoxHelper.js.arrayNeedsUint32"] */ arrayNeedsUint32
				});
				function arrayMin(array) {
					if (array.length === 0) return Infinity;

					let min = array[0];

					for (let i = 1, l = array.length; i < l; ++i) {
						if (array[i] < min) min = array[i];
					}

					return min;
				}

				function arrayMax(array) {
					if (array.length === 0) return -Infinity;

					let max = array[0];

					for (let i = 1, l = array.length; i < l; ++i) {
						if (array[i] > max) max = array[i];
					}

					return max;
				}

				function arrayNeedsUint32(array) {
					// assumes larger values usually on last

					for (let i = array.length - 1; i >= 0; --i) {
						if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
					}

					return false;
				}

				const TYPED_ARRAYS = /* unused pure expression or super */ null && {
					Int8Array: Int8Array,
					Uint8Array: Uint8Array,
					Uint8ClampedArray: Uint8ClampedArray,
					Int16Array: Int16Array,
					Uint16Array: Uint16Array,
					Int32Array: Int32Array,
					Uint32Array: Uint32Array,
					Float32Array: Float32Array,
					Float64Array: Float64Array
				};

				function getTypedArray(type, buffer) {
					return new TYPED_ARRAYS[type](buffer);
				}

				function createElementNS(name) {
					return document.createElementNS("http://www.w3.org/1999/xhtml", name);
				}

				function createCanvasElement() {
					const canvas = createElementNS("canvas");
					canvas.style.display = "block";
					return canvas;
				}

				const _cache = /* unused pure expression or super */ null && {};

				function warnOnce(message) {
					if (message in _cache) return;

					_cache[message] = true;

					console.warn(message);
				}

				function probeAsync(gl, sync, interval) {
					return new Promise(function (resolve, reject) {
						function probe() {
							switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {
								case gl.WAIT_FAILED:
									reject();
									break;

								case gl.TIMEOUT_EXPIRED:
									setTimeout(probe, interval);
									break;

								default:
									resolve();
							}
						}

						setTimeout(probe, interval);
					});
				}

				function toNormalizedProjectionMatrix(projectionMatrix) {
					const m = projectionMatrix.elements;

					// Convert [-1, 1] to [0, 1] projection matrix
					m[2] = 0.5 * m[2] + 0.5 * m[3];
					m[6] = 0.5 * m[6] + 0.5 * m[7];
					m[10] = 0.5 * m[10] + 0.5 * m[11];
					m[14] = 0.5 * m[14] + 0.5 * m[15];
				}

				function toReversedProjectionMatrix(projectionMatrix) {
					const m = projectionMatrix.elements;
					const isPerspectiveMatrix = m[11] === -1;

					// Reverse [0, 1] projection matrix
					if (isPerspectiveMatrix) {
						m[10] = -m[10] - 1;
						m[14] = -m[14];
					} else {
						m[10] = -m[10];
						m[14] = -m[14] + 1;
					}
				}
			}
	}
]);
