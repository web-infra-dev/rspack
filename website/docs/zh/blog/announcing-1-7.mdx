---
date: 2025-12-29 16:00:00
sidebar: false
---

_2025 年 12 月 29 日_

# Rspack 1.7 发布公告

![Rspack 1.7](https://assets.rspack.rs/rspack/rspack-banner-v1-7.png)

---

我们很高兴地宣布 Rspack 1.7 已正式发布！

值得关注的变更如下：

- 新特性
  - [SWC 插件兼容性提升](#swc-插件兼容性提升)
  - [Lazy Compilation 默认开启](#lazy-compilation-默认开启)
  - [支持 Import Bytes](#支持-import-bytes)
  - [实验特性稳定化](#实验特性稳定化)
- Rstack 进展
  - [Rsbuild](#rsbuild)
  - [Rspress](#rspress)
  - [Rslib](#rslib)
  - [Rstest](#rstest)
  - [Rsdoctor](#rsdoctor)

## 新特性

### SWC 插件兼容性提升

在过去的版本中，SWC Wasm 插件的升级成本一直较高。这是由于 SWC 的 AST 结构会随着版本演进发生变化，已有插件在 SWC 升级后可能无法继续工作，插件作者需要进行适配，插件使用者也需要同步升级依赖，这在一定程度上影响了项目的稳定性和升级体验。

为缓解这一问题，我们向 SWC 社区贡献并引入了一系列 [兼容性改进](https://swc.rs/docs/plugin/ecmascript/compatibility)，包括：

- 使用自描述式的 [cbor](https://www.rfc-editor.org/rfc/rfc8949.html) 序列化方案，取代原先对版本敏感的 [rkyv](https://rkyv.org/)，使 Wasm 插件能更好地适应 AST 结构的变更
- 为 AST 中的枚举类型引入 `Unknown` 变体，从而在遇到新字段或新节点时提升容错能力

在 Rspack 1.7 中，我们升级了使用的 SWC 版本并支持了上述方案。这使得在 AST 新增字段的情况下，现有插件在多数场景下仍可正常运行，而无需额外的适配工作。

目前，该方案已在大部分流行的 SWC Wasm 插件中完成接入。如果你是 SWC Wasm 插件作者，可参考 [官方指南](https://swc.rs/docs/plugin/ecmascript/compatibility#make-your-plugin-compatible)，接入该方案，以降低后续版本演进中的维护成本。

### Lazy Compilation 默认开启

Rspack 的 [LazyCompilation](/config/lazy-compilation) 特性在 1.5.0 发布时已经稳定。通过以下配置就能默认开启。

```js title="rspack.config.mjs"
export default {
  lazyCompilation: true,
};
```

在多入口应用和动态加载路由的SPA 大型应用中，Lazy Compilation 通过按需编译需要的模块，能显著的降低应用的冷启动时间和首次可交互时间。从 Rspack 1.7 开始，Lazy Compilation 功能将在 Web 应用的项目中默认开启，无需额外配置即可获得收益。这意味着，我们将获得**更快的 Dev server 的启动速度**和**更低的初始 CPU/内存占用**。

在绝大多数场景下，你只会感受到更快的启动速度。当首次访问某个尚未编译的模块时，Rspack 会即时完成编译并继续执行，对开发流程几乎无感。

如果你有特殊需求（例如调试完整产物、分析完整 Module Graph），也可以通过 `lazyCompilation: false` 来关闭该功能。

### 支持 Import Bytes

Rspack 现已原生支持 [TC39 import attributes](https://github.com/tc39/proposal-import-bytes) 提案的 bytes 类型导入资源文件，可直接将资源作为 `Uint8Array` 二进制数据导入，并通过 `TextDecoder` 解码。

```js
// 静态导入
import fileBytes from './file.bin' with { type: 'bytes' };
const decoder = new TextDecoder('utf-8');
const text = decoder.decode(fileBytes);

// 动态导入
const module = await import('./file.bin', { with: { type: 'bytes' } });
const decoder = new TextDecoder('utf-8');
const text = decoder.decode(module.default);
```

### 实验特性稳定化

在 Rspack v1.7 中，我们推进了实验特性的稳定化工作。以下实验配置项现已稳定。

#### 跨模块常量与枚举内联

我们将原有的 `experiments.inlineConst` 和 `experiments.inlineEnum` 合并为稳定的 `optimization.inlineExports` 配置。该特性支持跨模块内联基本类型常量及 TypeScript enum（通过 `builtin:swc-loader` 收集），从而实现更进一步的死代码消除（DCE）获得更小的产物体积。

迁移时，移除 experiments 下的相关字段即可。`optimization.inlineExports` 优化在生产模式下默认开启。

```js title="rspack.config.mjs"
export default {
  optimization: {
    // 生产模式默认开启，无需手动设置
    inlineExports: true,
  },
  experiments: {
    // 功能已稳定，旧配置已废弃，直接移除即可
    inlineConst: true,
    inlineEnum: true,
  },
};
```

#### 宽松的类型重导出检查

宽容重导出类型报错 `module.parser.javascript.typeReexportsPresence` 现已稳定，迁移时移除对应实验特性开关 `experiments.typeReexportsPresence` 即可。

```js title="rspack.config.mjs"
export default {
  experiments: {
    // 功能已稳定，无需实验特性开关，直接移除即可
    typeReexportsPresence: true,
  },
};
```

#### TypeScript 信息收集

配合上述枚举优化和宽松的类型重导出检查的稳定，`builtin:swc-loader` 也调整了其配置结构。原先嵌套在 `rspackExperiments` 中的 [collectTypeScriptInfo](/guide/features/builtin-swc-loader#collecttypescriptinfo) 选项现已稳定，提升为 loader 的顶层选项。

迁移时，将 `builtin:swc-loader` 的配置中 `rspackExperiments.collectTypeScriptInfo` 移动至 `options` 的顶层即可。

```js title="rspack.config.mjs"
export default {
  module: {
    rules: [
      {
        test: /\.ts$/,
        loader: 'builtin:swc-loader',
        options: {
          // 新位置：直接位于 options 下，移动到此处即可
          collectTypeScriptInfo: {
            exportedEnum: true,
            typeExports: true,
          },
          rspackExperiments: {
            // 旧位置，位于 rspackExperiments 中
            collectTypeScriptInfo: {
              exportedEnum: true,
              typeExports: true,
            },
          },
        },
      },
    ],
  },
};
```

## Rstack 进展

[Rstack](/guide/start/ecosystem#rstack) 是一个以 Rspack 为核心的 JavaScript 统一工具链，具有优秀的性能和一致的架构。

### Rsbuild

#### Error overlay 改进

Rsbuild 的 error overlay 现在支持显示**运行时错误**。当应用在运行过程中抛出异常时，错误会直接渲染到 overlay 上，帮助你更快发现并定位问题。

该功能默认关闭，可通过 [dev.client.overlay.runtime](https://rsbuild.rs/zh/config/dev/client#overlayruntime) 选项按需开启：

```js title=rsbuild.config.ts
export default {
  dev: {
    client: {
      overlay: {
        runtime: true,
      },
    },
  },
};
```

![Rsbuild 1.7 Error Overlay](https://assets.rspack.rs/rspack/assets/rspack-v1-7-rsbuild-error-overlay.png)

#### 产物体积对比

Rsbuild 现在支持产物体积对比，用来直观地观察构建结果是否发生了体积变化。

开启 [performance.printFileSize.diff](https://rsbuild.rs/zh/config/performance/print-file-size#diff) 选项后，Rsbuild 构建完成时会记录一份产物体积快照，后续构建会自动与上一次结果对比，并在日志中直接展示体积变化。你可以清楚地看到每个文件是变大还是变小，以及整体体积的增减情况，适合在日常开发和性能回归中快速发现体积变化。

```js title=rsbuild.config.ts
export default {
  performance: {
    printFileSize: {
      diff: true,
    },
  },
};
```

![Rsbuild 1.7 Print Size Diff](https://assets.rspack.rs/rspack/assets/rspack-v1-7-rsbuild-print-size-diff.png)

#### create-rsbuild 改进

`create-rsbuild` 现在包含了更多开箱即用的工具。

在创建 Rsbuild 项目时，你现在可以选择自动集成 [Rstest](https://rstest.rs/) 作为测试框架，或启用 [Storybook](https://storybook.rsbuild.rs/) 用于 UI 组件的开发与调试。相关依赖和基础配置都会在初始化阶段一次性完成，减少重复的手动配置成本。

```text
◆  Select additional tools (Use <space> to select, <enter> to continue)
│  ◼ Rstest - testing
│  ◻ Biome - linting & formatting
│  ◻ ESLint - linting
│  ◻ Prettier - formatting
│  ◻ Storybook - component development
└
```

### Rslib

#### ESM 产物稳定化

在之前的版本中，Rslib 通过实验性配置 [experiments.advancedEsm](/plugins/rspack/esm-library-plugin#esmlibraryplugin) 集成了 Rspack 的 [EsmLibraryPlugin](/plugins/rspack/esm-library-plugin#esmlibraryplugin)，旨在优化 ESM 产物质量。现在，我们很高兴地宣布该插件已完成稳定化工作。

自 Rslib v0.19.0 起，该插件在 bundle 模式下会被默认启用。开发者无需任何额外配置，即可直接获得高质量、对静态分析更友好且完整支持代码分割的 ESM 产物。

#### 全新的 JavaScript API

Rslib v0.19.0 版本引入了全新的 [JavaScript API](https://rslib.rs/api/start)，以便于开发者在 JavaScript 或 TypeScript 代码中直接使用 Rslib 的功能。使用方式如下：

1. **安装 Rslib：** 安装 `@rslib/core` 包：

```sh
npm add @rslib/core -D
```

2. **创建 Rslib 实例：** 调用 [createRslib](https://rslib.rs/api/javascript-api/core#createrslib) 方法来创建一个 Rslib 实例：

```js
import { createRslib } from '@rslib/core';

const rslib = await createRslib();
```

3. **调用 Rslib 实例方法：** 使用 [rslib.build](https://rslib.rs/api/javascript-api/instance#rslibbuild) 方法来构建生产环境输出：

```js
await rslib.build();
```

更多细节可以参阅 API 文档：

- [Rslib 核心方法](https://rslib.rs/api/javascript-api/core)
- [Rslib 实例](https://rslib.rs/api/javascript-api/instance)
- [Rslib 类型](https://rslib.rs/api/javascript-api/types)

### Rsdoctor

#### 全新的 Tree Map 视图

Rsdoctor 带来了全新的 Tree Map 视图，能帮助开发者**更直观地**分析 bundle 的构成，以及**资源（Assets）和模块（Modules）的占比**。同时支持搜索模块资源，点击模块资源可以放大到该模块区域。双击模块可以展开**模块依赖链**等信息

> Rsdoctor Tree Map：https://rsdoctor.rs/zh/guide/usage/bundle-size
>
> Rsdoctor V1.4.0: https://github.com/web-infra-dev/rsdoctor/releases/tag/v1.4.0

![Rsdoctor Tree Map](https://assets.rspack.rs/rspack/assets/rspack-v1-7-rsdoctor-treemap.gif)

### Rspress

#### SSG-MD：生成 llms.txt 的全新方式

在基于 React 动态渲染的前端框架中，往往存在静态信息难以提取的问题，Rspress 也遇到了相同的问题。Rspress 的核心优势之一是允许用户通过 [MDX 片段](https://v2.rspress.rs/zh/guide/use-mdx/components)、React 组件、Hooks 以及 TSX 路由等动态特性来增强文档表现力。但这些动态内容在转换为 Markdown 文本时会面临以下问题：

- 直接将 MDX 输入给 AI 会包含大量代码语法噪音，并丢失 React 组件内容
- 将 SSG 生成的 HTML 转为 Markdown 往往效果不佳，信息质量难以保证

为了从根本上解决这个问题，Rspress V2 引入了 [SSG-MD](https://v2.rspress.rs/zh/guide/basic/ssg-md) 特性。这是一个全新的功能，见名知意，与 [静态站点生成（SSG）](https://v2.rspress.rs/zh/guide/basic/ssg) 唯一的不同在于它将你的页面渲染为 Markdown 文件，而非 HTML 文件，并生成 [llms.txt](https://llmstxt.org/) 及 llms-full.txt 相关文件。相比与将 html 转化为 markdown 等传统方式，SSG-MD 在渲染期间拥有更好的信息源，比如 React 虚拟 DOM，因此拥有更好的静态信息质量和灵活性。

启用方式非常简单：

```js title="rspress.config.ts"
import { defineConfig } from '@rspress/core';

export default defineConfig({
  llms: true,
});
```

构建后将生成如下结构：

```
doc_build
├── llms.txt          # 摘要版，包含关键文档索引
├── llms-full.txt     # 完整版，包含所有文档内容
├── guide
│   └── start
│       └── introduction.md
└── ...
```

对于自定义组件，你可以通过环境变量来控制其在 SSG-MD 模式下的渲染行为：

```tsx
export function Tab({ label }: { label: string }) {
  if (process.env.__SSR_MD__) {
    // SSG-MD 模式下输出纯文本描述
    return <>{`**Tab: ${label}**`}</>;
  }
  // 正常渲染交互式组件
  return <div className="tab">{label}</div>;
}
```

这样既保证了文档的交互性体验，又确保 AI 能够理解组件的语义信息。

更多详情请参考：[SSG-MD 使用指南](https://v2.rspress.rs/zh/guide/basic/ssg-md)

### Rstest

#### 一键复用框架配置

Rstest 现已支持 [extends](https://rstest.rs/zh/config/test/extends) 配置能力，让你可以直接复用 Rslib、Rsbuild 等基于 Rspack 的框架构建配置，通过对应适配器将其自动转换为 Rstest 测试所需的格式，从而避免重复维护多套配置。

通过 `extends`，框架中已有的配置（如环境变量、路径别名等）可以无缝应用到测试环境中。同时，其他框架也可以通过实现对应的适配器，为 Rstest 提供开箱即用的测试配置支持。

目前，你可以通过官方适配器 [@rstest/adapter-rslib](https://www.npmjs.com/package/@rstest/adapter-rslib)，直接复用 Rslib 项目的构建配置，让 Rstest 在 Rslib 项目中真正做到“零额外配置即可运行”。对 Rsbuild、Rspack 等更多框架的适配也在持续推进中。

```js title=rstest.config.ts
import { defineConfig } from '@rstest/core';
import { withRslibConfig } from '@rstest/adapter-rslib';

export default defineConfig({
  extends: withRslibConfig({}),
  // 额外的 Rstest 特定配置
  coverage: {
    enabled: true,
    reporters: ['text', 'html'],
  },
});
```

#### 测试反馈更直观

Rstest 针对本地开发与调试场景进行了多项体验优化，让测试反馈更加直观、问题定位更加高效。

- **更早发现卡住的测试:** Rstest 现已支持在本地运行时**标记长时间未完成的测试用例**。当测试过程变慢时，你可以直接看到是哪个用例正在执行、可能已经卡住，而不再只能盯着终端等待整个测试超时结束。

- **更清晰的超时失败反馈:** 当测试因**超时**失败时，Rstest 现在会在错误信息中展示**已执行的断言数量**。这能帮助你快速判断测试是否已经部分执行，或是卡在了某个异步逻辑中，从而更快定位问题。

## 升级指南

### 升级 SWC 插件

如果你的项目中使用了 SWC Wasm 插件（如 `@swc/plugin-emotion` 等），请升级插件至兼容 `swc_core@53` 及以上版本，否则可能因版本不兼容导致构建失败或运行异常。

> 详情请查阅：[常见问题 - SWC 插件版本不匹配](/errors/swc-plugin-version)。

### 默认开启 Lazy Compilation

从 Rspack 1.7 开始，`lazyCompilation` 在 Web 应用项目中默认启用，无需额外配置即可享受更快的开发启动速度和更低的初始资源消耗。如需关闭，请在配置中显式设置：

```js title="rspack.config.mjs"
export default {
  lazyCompilation: false,
};
```

### 实验特性稳定化及配置调整

- 移除以下已废弃的实验配置：

```js title="rspack.config.mjs"
export default {
  experiments: {
    inlineConst: true,
    inlineEnum: true,
    typeReexportsPresence: true,
  },
};
```

- 使用稳定的配置替代：

```js title="rspack.config.mjs"
export default {
  optimization: {
    inlineExports: true, // 生产模式默认开启，无需手动设置
  },
};
```

- 调整 `builtin:swc-loader` 中 `collectTypeScriptInfo` 选项位置：

```js title="rspack.config.mjs"
// Before
export default {
  rspackExperiments: {
    collectTypeScriptInfo: {
      exportedEnum: true,
      typeExports: true,
    }
  }
}

// After
export default {
  options: {
    collectTypeScriptInfo: {
      exportedEnum: true,
      typeExports: true,
    }
  }
}
```
