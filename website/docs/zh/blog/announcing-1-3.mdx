---
date: 2025-3-28 16:00:00
sidebar: false
---

_2025 年 3 月 28 日_

# Rspack 1.3 发布公告

---

Rspack 1.3 已经正式发布！

值得关注的变更如下：

- 新功能
  - [Lazy compilation middleware](#lazy-compilation-middleware)：简化开发服务器对 lazy compilation 功能的接入
  - [支持 HTTP/HTTPS URL 导入模块](#支持-httphttps-url-导入模块)：为现代 Web 开发提供更灵活的模块导入方式
  - [CircularDependencyRspackPlugin](#circulardependencyrspackplugin)：检测模块间的循环依赖
  - [支持 AMD 模块](#支持-amd-模块)
  - [JavaScript API 支持模块子类型](#javascript-api-支持模块子类型)
- 性能优化
  - [并行的 code splitting 算法](#并行的-code-splitting-算法)
  - [产物体积优化](#产物体积优化)
  - [内存优化](#内存优化)
- 生态系统
  - [Rsdoctor 1.0](#rsdoctor-10)
  - [Lynx 开源](#lynx-开源)
  - [Rsbuild 1.3](#rsbuild-13)
- 升级指南
  - [升级 SWC 插件](#升级-swc-插件)

## 新功能

### Lazy compilation middleware

此前，lazy compilation 依赖开发服务器对 lazy compilation 模块的请求进行特殊处理，导致一些问题，例如无法与开发服务器共享代理配置和 CORS 配置。

现在会提供一个 Express 风格的中间件来处理 lazy compilation。若你是 `@rspack/cli` 的用户，无需任何改动。若你是使用自定义开发服务器，仅需注入中间件即可支持 lazy compilation。

```js
import { experiments, rspack } from '@rspack/core';
import config from './rspack.config.mjs';
import DevServer from 'webpack-dev-server';

const compiler = rspack(config);

const middleware = experiments.lazyCompilationMiddleware(
  compiler,
  config.experiments.lazyCompilation,
);

const server = new DevServer(compiler, {
  port: 3000,
  setupMiddlewares(other) {
    return [middleware, ...other];
  },
});

server.start();
```

### 支持 HTTP/HTTPS URL 导入模块

Rspack 现已支持直接引用远程 HTTP/HTTPS 模块，为现代 Web 开发提供更灵活的模块导入方式，该功能可通在配置文件通过以下配置开启，如下：

```js
module.exports = {
  experiments: {
    buildHttp: true, // 启用 HTTP/HTTPS 模块导入
  },
};
```

在启用该功能后，你可以在代码中通过 HTTP/HTTPS URL 导入模块：

```js
import pMap from 'https://cdn.skypack.dev/p-map';
```

我们支持以下 JavaScript CDN，因为它们提供了对 JavaScript 模块的 URL 访问：

- [Skypack](https://cdn.skypack.dev)
- [esm.sh](https://cdn.esm.sh)
- [jspm](https://jspm.dev)
- [unpkg](https://unpkg.com)

完整配置参数参阅[文档](https://rspack.dev/zh/config/experiments#experimentsbuildhttp)。

### CircularDependencyRspackPlugin

我们为 Rspack 增加了一个内置插件 CircularDependencyRspackPlugin，检测运行时模块之间的循环依赖。

由于该插件基于 Rust 实现，直接和 Rspack 模块图进行了集成，避免了昂贵的复制以及序列化成本。该插件对每个 entry 的模块图进行一次遍历来找到所有的循环引用，而不是单独检查模块，这意味着该插件的性能要更加好。

使用方式参考:

```js
import { rspack } from '@rspack/core';

const config = {
  plugins: [
    new rspack.CircularDependencyRspackPlugin({
      failOnError: true,
    }),
  ],
};
```

完整配置参数参阅[文档](https://rspack.dev/zh/plugins/rspack/circular-dependency-rspack-plugin)。

### 支持 AMD 模块

我们增加了对 AMD 模块的支持。

与 Webpack 默认启用 AMD 模块支持不同，Rspack 选择默认禁用该特性。此功能旨在兼容仍需使用 AMD 格式的依赖，我们强烈建议开发者优先选用 ES Module 规范的依赖，以便 Rspack 能基于静态模块分析进行更高效的产物体积优化。

若确需启用 AMD 支持，请在配置中：

```js
const config = {
  // ...
  amd: {},
};
```

完整配置参数请参阅[文档](https://rspack.dev/config/other-options#amd)。

### JavaScript API 支持模块子类型

为提升与 Webpack API 的兼容性，Rspack 模块被构建为具体的子类型。目前已支持的模块子类型包括：

- NormalModule
- ContextModule
- ExternalModule
- ConcatenatedModule

现在你可通过两种方式来识别模块的具体类型：

```ts
// 方法一：实例类型校验
module instanceof NormalModule;

// 方法二：构造器特征检测
module.constructor.name === 'NormalModule';
```

新的类型定义可能会让你原有使用 JavaScript API 的代码遇到 TypeScript 类型报错，例如：

```ts
module.resource; // TypeScript Error: Property 'resource' does not exist on type 'Module'
```

现在当你访问 resource 属性时，需要使用以下方法断言具体的模块类型：

```ts
// 模式一：in操作符守卫
if ('resource' in module) {
  console.log(module.resource);
}

// 模式二：类型实例断言
if (module instanceof NormalModule) {
  module.resource;
}
```

## 性能优化

### 并行的 code splitting 算法

旧版本的 chunk 拆分算法是基于单线程而设计，并且计算过程有较多耦合，每一个 chunk 的生成会依赖其祖先 chunk 的一些输入，这导致其接入增量算法后非常复杂，为了更好地利用一些多线程的优势，以及更简单地接入增量架构中，我们重构了创建 chunk 的算法，现在的 code splitting 会更高效。

### 产物体积优化

Rspack 1.3 版本引入了对 `output.environment` 选项的完整支持，这允许你指定在 Rspack 生成的运行时代码中可使用的 ECMAScript 特性，能够生成更精简、更现代的运行时代码。

默认情况下，Rspack 会解析 `target` 配置项，并基于 `browserslist` 来判断目标环境所支持的 ECMAScript 特性，自动设置 `output.environment` 子选项的值，从而输出最优的代码。

例如，当检测到目标环境支持箭头函数时，Rspack 会将 `output.environment.arrowFunction` 设置为 `true`，从而在生成的代码中使用箭头函数语法。

```diff
- __webpack_require__.d = function(exports, definition) {
+ __webpack_require__.d = (exports, definition) => {
        for(var key in definition) {
         ...
        }
}
```

通过使用目标环境支持的现代 JavaScript 特性，Rspack 能够输出更小的运行时代码。在我们对一个真实大型项目的性能测试中，该优化减少了约 500KB 的产物体积（未经 gzip 压缩）。

### 内存优化

我们修复了一些内存的问题：

1. 实现了清理过期缓存的内部机制 `maxGenerations`。这个参数控制了缓存的存活时间，Rspack 默认将这个值设置为 1，意味着如果特定缓存在下一轮编译中没有被使用，该缓存将会被清除。

![Max generations](https://assets.rspack.dev/rspack/assets/rspack-v1-3-memory-improve-max-generations.png)

2. 我们在 macOS 上默认使用了 mimalloc v3。这缓解了macOS 在 rebuild 过程中的一些内存消耗问题。根据一些社区和内部项目的反馈，这将减少 rebuild 时的 RSS 使用量，具体减少的比例因项目大小而异，根据我们的测试，减少的比例从 10% 到 85% 不等。

## 生态系统

### Rsdoctor 1.0

在经过一年的迭代与验证后，我们正式推出 [Rsdoctor 1.0](https://github.com/web-infra-dev/rsdoctor) —— 一款为 Rspack 生态量身打造的构建分析工具，同时也完全兼容 webpack 生态。

Rsdoctor 致力于成为一站式、智能化的构建分析工具，通过可视化与智能分析，使整个构建流程变得透明、可预测和可优化，从而帮助开发团队精准定位瓶颈、优化性能并提升工程质量。

Rsdoctor 1.0 版本带来了诸多的新特性：

- 全面优化的 UI 界面，使信息展示更直观高效；
- 通过 Rust 重写耗时较长的数据处理逻辑，分析性能提升超过 20%；
- 新增模块搜索功能，用于快速分析模块引用关系和模块大小。

> 参考 [Rsdoctor 1.0 发布博客](https://rsdoctor.dev/zh/blog/release/release-note-1_0) 了解更多。

### Rsbuild 1.3

Rsbuild 1.3 已经与 Rspack 1.3 同步发布，新特性包括：

- 支持通过 [?inline](https://rsbuild.dev/zh/guide/basic/css-usage#inline) 查询参数引用 CSS 文件编译后的内容，并将其作为字符串导入：

```js
import inlineCss from './style.css?inline';

console.log(inlineCss); // 输出编译后的 CSS 文件内容
```

- 支持通过 [?raw](https://rsbuild.dev/zh/guide/basic/css-usage#raw) 查询参数引用 CSS 文件和静态资源的原始内容，并将其作为字符串导入：

```js
import rawSvg from './logo.svg?raw';
import rawCss from './style.css?raw';

console.log(rawSvg); // 输出 SVG 文件的原始内容
console.log(rawCss); // 输出 CSS 文件的原始内容
```

### Lynx 开源

[Lynx](https://lynxjs.org/) 是一套帮助 Web 开发者复用现有经验，通过一份代码同时构建移动端原生界面与 Web 端界面的技术方案。它最初由字节跳动的工程团队开发，并将由该团队继续推进其演进。

Lynx 基于 Rspack、Rsbuild 和 Rsdoctor 打造了现代化的工具链 [Rspeedy](https://lynxjs.org/zh/rspeedy/)，用于支持 Lynx 的快速开发。此外，Lynx 还有着高性能、多功能的渲染引擎、性能优先的双线程 UI 编程范式等诸多特性。

> 参考 [Lynx 发布博客](https://lynxjs.org/zh/blog/lynx-unlock-native-for-more.html) 了解更多。

### Re.Pack 5

[Re.Pack](https://github.com/callstack/repack) 是一个用于开发 React Native 应用的构建工具。

Re.Pack 5 已正式发布，通过接入 Rspack 带来了显著的性能改进，通过 Module Federation 2 带来了适当的微前端支持，简化了配置等。

> 参考 [Re.Pack 5 发布博客](https://re-pack.dev/blog/repack-5-release) 了解更多。

## 升级指南

### 升级 SWC 插件

在 Rspack 1.3 中，`swc_core` crate 已经升级到 v16。SWC Wasm 插件的用户需要确保与正在使用的 `swc_core` 版本一致，否则可能会导致意外问题。

> 详情请参考 [常见问题 - SWC 插件版本不匹配](https://rspack.dev/zh/errors/swc-plugin-version)。
