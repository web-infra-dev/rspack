---
date: 2025-8-18 11:00:00
sidebar: false
---

_2025 年 8 月 26 日_

# Rspack 1.5 发布公告

![Rspack 1.5](https://assets.rspack.rs/rspack/rspack-banner-v1-5.png)

---

Rspack 1.5 已经正式发布！

值得关注的变更如下：

- 新功能
  - [Barrel 文件优化](#barrel-文件优化)
  - [@rspack/browser 发布](##@rspack/browser-发布)
  - [使用 Rust 扩展 Rspack](#使用-rust-扩展-rspack)
  - [常量内联](#常量内联)
  - [增强 TypeScript 支持](#增强-typescript-支持)
  - [增强 lazy compilation](#增强-lazy-compilation)
  - [内置文件系统监听器](#内置文件系统监听器)
  - [内置虚拟模块插件](#内置虚拟模块插件)
  - [Module Federation 运行时提升](#module-federation-运行时提升)
- 其他
  - [Rspack 停止支持 Node.js 16](#rspack-停止支持-nodejs-16)
  - [内置 rspack-resolver](#rspack-core-内置-rspack-resolver)
  - [废弃和稳定](#废弃和稳定)
- Rstack 进展
  - [Rslint 发布](#rslint-发布)
  - [Rsbuild 1.5](#rsbuild-15)
  - [Rslib 0.12](#rslib-012)
  - [Rspress 2.0 beta](#rspress-20-beta)
  - [Rsdoctor 1.2](#rsdoctor-12)
  - [Rstest 0.2](#rstest-02)

## 新功能

### Barrel 文件优化

Barrel 文件是一种常见的模块导出模式，它通过创建统一的入口文件来重新导出多个模块，通常命名为 `index.js` 或 `index.ts`，例如：

```js
export * from './hooks';
export * from './utils';
export * from './components';
```

虽然这种模式简化了模块导入的使用方式，但是在构建过程中会带来性能问题：当导入 barrel 文件中的某个模块时，Rspack 需要解析和构建 barrel 文件依赖的所有模块，即使实际只使用了其中的一小部分。

为了解决这一问题，Rspack 1.5 引入了实验性的 [lazyBarrel](/config/experiments#experimentslazybarrel) 功能，它能够自动识别无副作用的 barrel 文件，对其中的 `reexports` 进行延迟构建优化，只在真正需要时才会解析和构建相关模块，从而显著减少不必要的模块解析和构建开销。这一优化对于包含大量 barrel 文件的项目尤其有效，能够带来显著的构建性能提升。

```js title="rspack.config.mjs"
export default {
  experiments: {
    lazyBarrel: true,
  },
};
```

在实际测试中，开启 barrel 文件优化后，两个不同规模的应用都获得了明显的构建性能提升：

- [Benchmark 应用](https://github.com/rspack-contrib/build-tools-performance/tree/main/cases/ui-components)：

| 指标             | 开启前    | 开启后    | 提升幅度 |
| ---------------- | --------- | --------- | -------- |
| 构建时间         | 1.47s     | 1.19s     | ~20%     |
| 模块路径解析次数 | 39,675 次 | 20,071 次 | -49%     |
| 模块构建次数     | 9,358 次  | 5,062 次  | -46%     |

- 某个内部应用：

| 指标             | 开启前     | 开启后     | 提升幅度 |
| ---------------- | ---------- | ---------- | -------- |
| 构建时间         | 17.9s      | 16.0s      | ~10%     |
| 模块路径解析次数 | 181,078 次 | 137,232 次 | -24%     |
| 模块构建次数     | 38,046 次  | 29,405 次  | -23%     |

我们已经在 Rsbuild 1.5 中默认开启了 barrel 文件优化，并计划在 Rspack 1.6 中对所有项目默认启用该功能。更多可参考 [`experiments.lazyBarrel` 文档](/config/experiments#experimentslazybarrel)。

### @rspack/browser 发布

![rspack-web-repl](https://assets.rspack.rs/rspack/assets/rspack-v1-5-repl.rspack.png)

在先前的 Rspack 1.4 中，我们正式引入了 Wasm target 支持，这意味着 Rspack 可以在基于 StackBlitz（WebContainers）的在线平台浏览器环境中运行。

在 Rspack 1.5 中，我们正式发布了 [@rspack/browser](https://www.npmjs.com/package/@rspack/browser)，它是专为纯浏览器环境设计的版本，允许你直接在任何现代浏览器中使用 Rspack，而无需依赖 WebContainers 或是特定平台。`@rspack/browser` 为复杂 Web 项目的在线打包提供底层支持，提供了更轻量的问题复现、配置分享方案，并通过提供在线交互式 Demo 的方式帮助开发者入门和学习 Rspack。

`@rspack/browser` 提供的 API 和 `@rspack/core` 的 JavaScript API 是对齐的。在此基础上，额外提供了为适配浏览器环境的特性和 API：

```js
import { rspack, builtinMemFs } from '@rspack/browser';
// Write files to memfs
builtinMemFs.volume.fromJSON({
  // ...project files
});

// Just like using JavaScript API of @rspack/core
rspack({}, (err, stats) => {
  if (err || stats.hasErrors()) {
    // ...
  }
  // Get output from memfs after bundling
  const files = builtinMemFs.volume.toJSON();
});
```

目前 `@rspack/browser` 还处于实验性阶段，可能会发生小型的破坏性改动。未来我们将持续完善在线打包所需的能力，欢迎前往 [Rspack Playground](https://playground.rspack.rs/) 进行体验。

### 使用 Rust 扩展 Rspack

现在你可以直接使用 Rust 来扩展 Rspack 了！通过官方提供的模板，开发者能够轻松编写自定义的 Rust Plugin 和 Rust Loader。

传统的 JavaScript 插件需要在 Rust 和 JavaScript 之间进行数据传递和类型转换，这会带来一定的性能开销。而使用 Custom Binding，你的自定义代码将直接与 Rspack Rust Core 集成，消除了跨语言通信的性能瓶颈，同时支持所有 Rspack JavaScript API。

特别适用于替换频繁与 Rust 通信的 Hooks（如 `compilation.hooks.processAssets`）和需要大量计算的自定义 Loader，能够显著提升这些场景下的构建性能。

主要优势：

- **原生性能** —— Rust 编写的扩展享受与 Rspack Rust Core 相同的原生性能。
- **完全兼容** —— 保留所有现有的 JavaScript API，无需修改现有项目。
- **开发便捷** —— 官方模板提供完整的开发环境和发布流程。
- **生产就绪** —— 内置 NPM provenance 支持，确保供应链安全。

使用[官方模板](https://github.com/rspack-contrib/rspack-binding-template)快速开始，了解更多请查看[设计理念](https://rspack-contrib.github.io/rspack-rust-book/custom-binding/getting-started/rationale.html)。

### 常量内联

[`experiments.inlineConst`](/config/experiments#experimentsinlineconst) 功能会对模块图的叶子节点中的常量进行 inline 优化，带来更小的产物体积。

比如有以下代码：

```js
// font-settings.js
export const bold = 0b001;
export const italic = 0b010;
export const underline = 0b100;

// index.js
import { bold, italic, underline } from './font-settings';

(function setupFont() {
  const fontStyle = {};
  // MY_FONT is defined by DefinePlugin({ FONT: 0b001 })
  if (MY_FONT & bold) fontStyle['font-weight'] = 'bold';
  if (MY_FONT & italic) fontStyle['font-style'] = 'italic';
  if (MY_FONT & underline) fontStyle['text-decoration'] = 'underline';
  applyFont(fontStyle);
})();
```

开启 inlineConst 使用 Rspack 打包， 实例中的 `if` 能够更加明确的被压缩器优化，得到更加精简的产物：

```js
(() => {
  'use strict';
  !(function () {
    let t = {};
    ((t['font-weight'] = 'bold'), applyFont(t));
  })(); /* rest of the app... */
})();
```

更多可参考 [experiments.inlineConst 文档](/config/experiments#experimentsinlineconst)，计划在 v1.6.0 默认开启该功能。

### 增强 TypeScript 支持

开启 [experiments.inlineEnum](/config/experiments#experimentsinlineenum) 和
[experiments.typeReexportsPresence](/config/experiments#experimentstypereexportspresence) 来增强 builtin:swc-loader 对 TypeScript 的支持。

`inlineEnum` 会对 TypeScript `enum` 进行 inline 优化，以优化产物体积：

```ts
// types.ts
export enum Kind {
  A,
  B,
}
// index.ts
import { Kind } from './types.ts';
console.log(Kind.A);
```

开启 `inlineEnum` 使用 Rspack 打包：

```js
// Bundled by Rspack (with minimize: true)
(() => {
  'use strict';
  !(function () {
    console.log(0);
  })();
})();
```

默认会对所有 `enum` 都进行 inline，可通过 ['const-only'](https://github.com/rspack-contrib/rstack-examples/tree/main/rspack/inline-const-enum) 和
[tsEnumIsMutable: true](https://github.com/rspack-contrib/rstack-examples/tree/main/rspack/inline-const-enum) 来仅对 `const enum` 进行 inline 优化，
更多详情可参考 [experiments.inlineEnum](https://rspack.rs/config/experiments#experimentsinlineenum)。

`typeReexportsPresence` 优化了对 TypeScript 的类型重导出的报错：

```ts
// 之前会报 ESModulesLinkingWarning，开启 typeReexportsPresence 后不会报警告
export { MyType } from './types.ts';
```

更多详情可参考 [experiments.typeReexportsPresence](https://rspack.rs/config/experiments#experimentstypereexportspresence)。

另外 Rspack 正在探索对 TypeScript 一等公民的支持，预计在未来 Rspack v2.0 无需配置即可使用 TypeScript，提供更好的 TypeScript 开发体验。

### 内置文件系统监听器

在过去，Rspack 使用 [watchpack](https://www.npmjs.com/package/watchpack) 进行文件监听。
在实践过程中，我们发现了一些问题。 Watchpack 在每次文件变更后会重新创建一个 Watchpack 实例， 并接受全量的文件监听列表，运行一次完整的流程。
当文件监听列表的数量庞大时，这将占用用户较大比例的 CPU 和内存资源， 例如：[#7490](https://github.com/web-infra-dev/rspack/issues/7490)。

为此，我们设计并实现了基于 Rust 的内置文件系统监听器。
这个监听器在整个 watch 周期内留存，每次 rebuild 时仅对已变更的文件进行增量更新，且仅监听必要的目录。
每次重新构建（rebuild）后，监听流程更新可达到毫秒级，在 10000 模块级别的大型项目中，热监听耗时将降低 **52.8%**。

使用配置 `experiments.nativeWatcher` 开启内置文件系统监听器。

```js
export default {
  watchOptions: {
    // Other watch options...
  },
  experiments: {
    nativeWatcher: true,
  },
};
```

更多参考 [`experiments.nativeWatcher`](/config/experiments#experimentsnativewatcher) 文档。

### 内置的虚拟模块插件

在 Rspack@1.4.0 中，我们支持了[自定义的 InputFileSystem](https://rspack.rs/blog/announcing-1-4#custom-input-file-system)。
自定义 InputFileSystem 在配合 Webpack Virtual Modules 插件使用时，如果虚拟模块数量较小时，该方案既兼顾了 Webpack 生态, 又保持了 Rspack 的高性能。但是在大量虚拟模块的场景下，性能劣化问题仍然存在。

为了解决大量虚拟文件的场景，我们新增内置的基于 Rust 的虚拟模块插件 [VirtualModulesPlugin](https://github.com/web-infra-dev/rspack/issues/10856)。插件将虚拟模块的存储转移到了 Rust 侧，大大降低了模块的读取和解析的开销，让虚拟文件功能在大量虚拟模块的场景下也能保持高性能。
此外虚拟文件插件 VirtualModulesPlugin 和 Webpack Virtual Modules 插件保持相同的 API ，替换起来非常的方便。

```js
// rspack.config.js
const rspack = require('@rspack/core');
module.exports = {
  plugins: [
    new rspack.experiments.VirtualModulesPlugin({
      'src/generated/config.js': 'export default { version: "1.0.0" };',
    }),
  ],
};
```

感谢我们的社区伙伴 [@nilptr](https://github.com/nilptr) 的[贡献](https://github.com/web-infra-dev/rspack/pull/11021)。

### Module Federation 运行时提升

此前 Module Federation 的运行时是通过在入口模块打补丁的形式运行起来的。新版的 Module Federation 插件通过将自己的运行时代码和 Rspack 的运行时代码合并，同时将 Module Federation 运行时代码提升到了运行时 chunk 中。这样能在应用启动前就将 Module Federation 的运行时提前准备好了。

这样改动带来如下收益：

1. 在多入口的场景下产物尺寸减少
2. 修复了 Module Federation 初始化出错的问题
3. Module Federation 可以提取到运行时 chunk 中
4. 提供一套基于 hook 的插件体系

下面是一个演示项目在使用新版 Module Federation 插件所带来的产物体积优化对比。

| Configuration                             | Before | After | Reduction |
| :---------------------------------------- | -----: | ----: | --------: |
| Single Entry                              |  140kb | 140kb |        0% |
| Multiple Entries (default)                |  210kb | 210kb |        0% |
| Multiple Entries + runtimeChunk: 'single' |  210kb |  70kb |       67% |
| Multiple Entries + runtimeChunk: true     |  210kb | 150kb |       29% |

## 性能优化

### 二进制产物尺寸优化

自 1.4.0 以来 Rspack 团队做了一些系列的优化来降低 Rspack 的安装尺寸。其中最重要的便是优化 Rspack node binding 的文件尺寸。

![binary-size-by-dates](https://assets.rspack.rs/rspack/assets/rspack-v1-5-binary-size.png)

产物尺寸优化是从我们的开路先锋 [@quininer](https://github.com/quininer) 优化 Rspack 的依赖
[browserlist-rs](https://github.com/browserslist/browserslist-rs/pull/32) 尺寸开始的；
接着各路开花，例如：这个 [Pull Request](https://github.com/web-infra-dev/rspack/pull/11077) 通过修改编译参数足足减少 5M 的产物尺寸；
还有 [@hardfirst](https://github.com/hardfist) 通过控制 [feature 开关](https://github.com/web-infra-dev/rspack/pull/10965) 带来了近 2M 的尺寸优化；
通过优化上游依赖 [wasmer](https://github.com/wasmerio/wasmer/pull/5621/files) 和 [SWC](https://github.com/swc-project/swc/pull/10638) 带来了近3M 的优化。
细心的读者可能会发现，产物优化不仅仅要在 Rspack 的本身做优化，还要求我们促进上游软件的优化。
除了构建一个更快的 bundler ，我们更想构建一个更加美好的社区。

### Seal 阶段性能提升

除了二进制产物的尺寸的优化外，构建速度优化我们没有停步。相较于 1.4.0 版本， 1.5.0 版本在 Seal 阶段践行了大量的优化。
在不影响产物的前提下，通过优化数据结构、提高代码的并行度、增加热点代码执行缓存等方式，对大型项目的 Seal 阶段有较大的提升。

以内部一个约 40000+ 的模块的项目为例，整体 Seal 阶段耗时降低约 50%。

![seal-performance-before](https://assets.rspack.rs/rspack/assets/rspack-v1-5-seal-phase-before.png)

![seal-performance-after](https://assets.rspack.rs/rspack/assets/rspack-v1-5-seal-phase-after.png)

其中几个主要的耗时阶段都有一定程度的优化：

| Phase                   | v1.4.0 | v1.5.0 | Reduction |
| ----------------------- | -----: | -----: | --------: |
| Flag dependency exports |  394ms |  181ms |       54% |
| Flag dependency usage   | 1828ms |  454ms |       75% |
| Code Splitting          | 2019ms |  777ms |       62% |
| Bundle Splitting        | 1588ms |  712ms |       55% |
| Module Concatenation    | 2645ms |  616ms |       76% |
| RealContentHashPlugin   |  881ms |  404ms |       54% |

Rspack 团队后续也会继续优化性能，在不牺牲产物体积的前提下，探索性能更加优秀的算法。

## 其他

### Rspack 停止支持 node 16

鉴于 Node.js 16 于 2023 年 9 月 11 已经停止维护，以及众多的社区 npm 包（如：webpack-dev-server, css-loader, sass-loader 等）也停止了对 Node.js 16 的支持，为了减低维护的复杂度，Rspack v1.5 将不再支持 Node.js 16。

| Package | v1.4 | v1.5 |
|--------------------|-----------:|-----------:|
| @rspack/core | >=16.0.0 | >=18.12.0 |
| @rspack/cli | >=18.12.0 | >=18.12.0 |
| @rspack/dev-server | >=18.12.0 | >=18.12.0 |
| @rsbuild/core | >=16.10.0 | >=18.12.0 |

### Rspack core 内置 rspack-resolver

为了 Rspack core 的用户能够更方便地使用 Rspack 的模块解析能力，我们将 [rspack-resolver](https://github.com/web-infra-dev/rspack-resolver) 内置到了 Rspack 的 JavaScript API。

用法参考 [Resolver API 文档](/api/javascript-api/resolver#resolver-api)

### 废弃和稳定

- 稳定 **LazyCompilation** 特性 -- `experiments.lazyCompilation` 配置项已经移动到了 Rspack 配置顶层。
- 废弃 `experiments.topLevelAwait` 配置 -- 当 `experiments.topLevelAwait` 被设置为 `false`时, Rspack 会打印一条废弃该特性的日志。 另外 `topLevelAwait` 特性计划将在 Rspack 2.0 并默认开启, 并移除配置项`experiments.topLevelAwait`。

## Rstack 进展

[Rstack](/guide/start/ecosystem#rstack) 是一个围绕 Rspack 打造的 JavaScript 统一工具链，具有优秀的性能和一致的架构。

### Rslint 发布

![rslint-logo](https://assets.rspack.rs/rslint/rslint-logo-256x256.png)

我们很高兴地宣布 [Rslint](https://rslint.rs/) 的发布！
Rslint 是一个 TypeScript 优先的新一代 Linter，由 Go 编写，并基于 typescript-go 提供的类型检查能力。
它起源于 [@auvred](https://github.com/auvred) 开发的 [tsgolint](https://github.com/typescript-eslint/tsgolint)，并在此基础上进行了扩展和优化。

Rslint 目前支持如下功能

- ESLint 风格的配置与指令：几乎无缝上手
- IDE 支持：提供 VS Code 与 Cursor 插件
- 自动修复：`rslint --fix` 一键修复代码问题
- 规则支持：已实现 50+ 条 `@typescript-eslint` 规则
- 测试验证：运行原始 `typescript-eslint` 测试套件，确保规则正确性

Rslint 仍处于早期阶段，我们正在积极开发更多功能和规则支持。
我们非常欢迎你来尝试，并给予宝贵的反馈，帮助我们一起打磨 Rslint！

### Rsbuild 1.5

#### 启用 Rspack 新特性

开箱即用一直是 Rsbuild 的核心设计理念。在 Rsbuild 1.5 中，我们默认启用了多项 Rspack 的最新特性，带来更优秀的开发体验和构建性能，包括：

- 启用 [lazyCompilation.imports](/config/lazy-compilation) 来按需编译动态导入的模块，这可以提升开发服务器的启动速度。
- 启用 [experiments.lazyBarrel](/config/experiments#experimentslazybarrel) 来优化 barrel 文件的构建速度，减少不必要的模块解析。
- 启用 [experiments.inlineEnum](/config/experiments#experimentsinlineenum) 来内联 TypeScript 枚举，这可以减少枚举被编译后的包体积。
- 启用 [experiments.typeReexportsPresence](/config/experiments#experimentsinlineenum) 来正确识别 TypeScript 类型重导出，提升类型处理的准确性。

将 Rsbuild 升级至最新版本后，上述特性将默认启用，无需任何额外配置即可获得更好的开发体验。

#### ESM 支持

Rsbuild 1.5 新增了 [output.module](https://rsbuild.rs/zh/config/output/module) 选项，用于输出 ES modules 格式的构建产物。

目前该选项针对 Node.js bundles 提供了 ESM 格式支持，未来我们将继续增加对 web 应用 ESM 格式的支持。

```ts title="rsbuild.config.ts"
export default {
  output: {
    target: 'node',
    module: true,
  },
};
```

### Rslib 0.12

#### 使用 Rstest

在 v0.12 版本中，我们在模板内添加了 Rstest 作为配套的测试框架，库开发者现在可以使用同一套 Rstack 工具链进行开发与测试。

![Using Rstest](https://assets.rspack.rs/rspack/assets/rspack-v1-5-rslib-using-rstest.png)

#### 新的 ESM 产物生成

我们正在积极设计并开发全新的 ESM 产物生成方案，以解决现有 ESM 产物存在的相关问题。目前，绝大部分的 interop 行为与 webpack 保持一致，详见 [interop 测试](https://jserfeng.github.io/interop-test/by-test-case)。

### Rspress 2.0 beta

#### @rspress/plugin-llms 支持 UI 展示

现在 Rstack 系列文档站都可以直接复制 Markdown 文本，便于配合大模型阅读文档。

这一能力通过 @rspress/plugin-llms 实现，这个插件会生成 [llms.txt](https://llmstxt.org/) 相关文件，你可以通过最新 beta 版本的 Rspress 来使用，详见 [@rspress/plugin-llms 文档](https://v2.rspress.rs/plugin/official-plugins/llms) 。

![plugin-llms Demo](https://assets.rspack.rs/rspack/assets/rspack-v1-5-rspress-plugin-llms-ui.png)

### Rsdoctor 1.2

Rsdoctor 1.2 版本带来了多项重要更新，新增了对聚合模块的精确分析能力，以及带来全新的 Treemap 视图。这些功能提升了构建产物分析的准确性和可视化体验，可以帮助你更好地理解和优化项目的打包产物。

请查看 [Rsdoctor 1.2 发布博客](https://rsdoctor.rs/zh/blog/release/release-note-1_2) 了解更多。

### Rstest 0.2

经过两个月时间、10 多个版本的快速迭代，新版的 Rstest 带来了更高的稳定性和特性：

#### Mock 模块

Mock 模块是测试中的常见需求，它允许你在测试中替换模块的实现。
现在，你可以使用 Rstest 的 mock API 对 ES 模块进行 mock。

![Mock 模块](https://assets.rspack.rs/rspack/assets/rspack-v1-5-rstest-mock-modules.png)

#### Watch 模式增强

Rstest 在 watch 模式下已支持增量 rerun, 这意味着只有当测试文件或关联文件（如被测试的模块）发生变化时才会重新运行该测试文件，从而大幅提升测试效率。

此外，在 watch 模式下运行 Rstest 时，你可以使用键盘快捷键来执行各种便捷操作。

![Rstest 快捷键](https://assets.rspack.rs/rspack/assets/rspack-v1-5-rstest-cli-shortcuts.png)
