---
sidebar: false
---

# 术语表

该索引列出了整个 Rspack 生态系统中的常用术语。

## asset（静态资源）

静态资源是对图像、字体、视频等静态文件的统称。这些文件通常会最终输出为单独的文件，而不是打包到代码块中，但是通过其也可以转换成 base64 内联到代码块中

## asset module（资源模块）

Asset 模块是一种特殊的模块类型，用来处理静态资源，例如图片、字体、视频等。

- [资源模块](/guide/features/asset-module)

## async chunk

Async chunk 指的是被异步加载的 [chunk](#chunk)，当你使用动态导入时，Rspack 会将该模块打包到 async chunk 中。

## bundle splitting

Bundle splitting 是一种允许你将代码分割或合并到多个 bundle 的技术，这对于并行请求和更好的浏览器缓存很有用，它不用于减少初始化 bundle 的大小。

- [代码分割](/guide/optimization/code-splitting)

## built-in module type（内置模块类型）

Rspack 中的内置模块类型指的是那些不需要依赖 loader 和 plugin 即可支持的模块类型，例如 JavaScript、CSS、JSON、静态资源等，而像 TypeScript、HTML、Markdown、YAML 等需要依赖 loader 和 plugin 才能支持的模块类型则不是内置模块类型。

- [资源模块](/guide/features/asset-module)
- [CSS](/guide/tech/css)
- [JSON](/guide/tech/json)
- [rules[].type](/config/module-rules#rulestype)

## chunk

Chunk 是一组绑定在一起的模块。Rspack 会将相互关联的模块打包成一个 chunk，然后生成对应的文件。

## chunk graph（chunk 图）

Chunk 图是一种表示块之间关系的数据结构。它是一个有向图，图中的每个节点代表一个块，每条边代表块之间的依赖关系。

## code splitting

Code splitting 是一种技术，它允许你将你的代码分割成多个块，并且只在应用程序运行时加载必要的块。这可以帮助你减少初始包的大小，加快应用程序的加载时间。

- [代码分割](/guide/optimization/code-splitting)

## dependency

Dependency 是从模块编译后的代码解析出来的，它用于存储模块的导入关系，以便递归生成模块图。在生成产物代码时，它可以注入模块的导入和导出相关代码，也可以用于代码替换和注入运行时依赖。

## initial chunk

Initial chunk 是被同步加载的 [chunk](#chunk)，包含页面的入口模块和被静态导入的模块。

## loader

Loader 是用来转换模块内容的。例如，我们可以使用 loader 将 TypeScript 模块转化为 JavaScript 模块，或者将 CSS 模块转化为 JavaScript 模块，将 CSS 注入到页面中。

- [Loader](/guide/features/loader)

## module（模块）

模块允许你将应用拆分为多个文件，并且在这些文件可以通过导入和导出进行模块内容的共享和复用，这可以帮助你将代码组织成独立的部分，并使用良好的接口在彼此间进行通信。

## module type（模块类型）

模块类型是模块的一种属性，它们可以通过不同的方式进行解析和处理。我们可以通过指明模块的模块类型来告诉 Rspack 如何处理它们。例如，我们可以通过指定模块类型为 JavaScript 来告诉 Rspack 该模块是一个 JavaScript 模块，然后 Rspack 就会使用 JavaScript 解析器来解析该模块，如果指定的模块类型为 CSS，那么 Rspack 就会使用 CSS 解析器来解析该模块。

- [rules[].type](/config/module-rules#rulestype)

## module specifier（模块标识符）

模块标识符是一个可以解析为模块文件路径的字符串。例如，在下面的代码中，`./modules/foo.js` 就是模块标识符。

```js
import { foo } from './modules/foo.js';
```

## module resolution（模块解析）

模块解析是指 Rspack 如何找到模块的过程。Rspack 会根据模块的路径来解析模块，例如，当我们在代码中使用 `import 'foo'` 时，Rspack 就会根据模块的路径来解析模块。

- [模块解析](/guide/features/module-resolution)

## module graph（模块图）

> module graph 也被称为 dependency graph（依赖图）。

模块图是一种表示模块之间关系的数据结构。它是一个有向图，图中的每个节点代表一个模块，每条边代表模块之间的依赖关系。

## NAPI-RS

[NAPI-RS](https://napi.rs/) 是一个在 Rust 中构建预编译的 Node.js 插件的框架。它通过提供 Node-API 的高级抽象，简化了创建和发布本地 Node.js 附加组件的过程。

## plugin（插件）

插件可以用来扩展 Rspack 的功能。它可以用来定制构建过程，或与其他工具集成。Rspack 提供了很多钩子，你可以用它们来定制构建过程。

- [插件](/guide/features/plugin)

## runtime

runtime（运行时）是指在浏览器或其他环境中运行过程中，Rspack 用来连接模块化应用所需的所有代码。它包含了连接模块所需的加载和解析逻辑。

- [optimization.runtimeChunk](/config/optimization#optimizationruntimechunk)

## scope hoisting （作用域合并）

作用域提升是一种将多个模块作用域进行合并的技术，它在可能的情况下将多个模块合并到一个单一的作用域中，而不是将每个模块包装在单独的函数中。这样对代码压缩更友好，并可以通过减少模块查找成本来提高运行时性能。

- [optimization.concatenateModules](/config/optimization#optimizationconcatenatemodules)

## tree shaking （摇树优化）

Tree shaking 是一种允许你从包中删除未使用代码的技术。它是一种特殊的死代码优化方式。像 Rspack 这样的编译器将通过分析代码的静态语法，然后删除未使用的代码来完成此操作。

- [Tree shaking](/guide/optimization/tree-shaking)
