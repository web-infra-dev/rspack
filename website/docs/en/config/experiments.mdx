import { ApiMeta, Stability } from '../../../components/ApiMeta';
import WebpackLicense from '@components/WebpackLicense';
import PropertyType from '@components/PropertyType';

<WebpackLicense from="https://webpack.js.org/configuration/experiments/" />

# Experiments

Enable and try out some experimental features.

- **Type:** `object`

:::tip
In minor releases, Rspack may make changes to the APIs of these experimental features and provide detailed explanations of these changes in the release notes. So if you are using experimental features, please pay attention to the minor release notes.
:::

## experiments.asyncWebAssembly

- **Type:** `boolean`
- **Default:** `false`

Support the new WebAssembly according to the [updated specification](https://github.com/WebAssembly/esm-integration), it makes a WebAssembly module an async module.

```js title="rspack.config.mjs"
export default {
  experiments: {
    asyncWebAssembly: true,
  },
};
```

And it is enabled by default when [experiments.futureDefaults](#experimentsfuturedefaults) is set to `true`.

## experiments.outputModule

- **Type:** `boolean`
- **Default:** `true`

Once enabled, Rspack will output ECMAScript module syntax whenever possible. For instance, `import()` to load chunks, ESM exports to expose chunk data, among others.

```js title="rspack.config.mjs"
export default {
  experiments: {
    outputModule: true,
  },
};
```

## experiments.css

- **Type:** `boolean`
- **Default:** `false`

Once enabled, Rspack will enable native CSS support, and CSS related parser and generator options.

- [`module.parser["css/auto"]`](/config/module#moduleparsercssauto)
- [`module.parser.css`](/config/module#moduleparsercss)
- [`module.parser["css/module"]`](/config/module#moduleparsercssmodule)
- [`module.generator["css/auto"]`](/config/module#modulegeneratorcssauto)
- [`module.generator.css`](/config/module#modulegeneratorcss)
- [`module.generator["css/module"]`](/config/module#modulegeneratorcssmodule)

Basic example:

```js title="rspack.config.mjs"
export default {
  experiments: {
    css: true,
  },
};
```

## experiments.futureDefaults

- **Type:** `boolean`
- **Default:** `false`

Use defaults of the next major Rspack and show warnings in any problematic places.

```js title="rspack.config.mjs"
export default {
  experiments: {
    futureDefaults: true,
  },
};
```

## experiments.topLevelAwait

- **Type:** `boolean`
- **Default:** `true`

Enable support for [Top-level await](https://github.com/tc39/proposal-top-level-await), `Top-level await` can only be used in modules with [ModuleType](/config/module#ruletype) is `javascript/esm`.

Enabled by default and can be disabled with this configuration:

```js title="rspack.config.mjs"
export default {
  experiments: {
    topLevelAwait: false,
  },
};
```

## experiments.lazyCompilation

- **Type:** `boolean | LazyCompilationOptions`
- **Default:** `false`

```ts
type LazyCompilationOptions =
  | boolean
  | {
      backend?: LazyCompilationBackendOptions;
      /**
       * Enable lazy compilation for entries.
       */
      entries?: boolean;
      /**
       * Enable lazy compilation for dynamic imports.
       */
      imports?: boolean;
      /**
       * Specify which imported modules should be lazily compiled.
       */
      test?: RegExp | ((m: Module) => boolean);
    };
```

Enable lazy compilation, which can greatly improve the dev startup performance of multi-page applications (MPA) or large single-page applications (SPA). For example, if you have twenty entry points, only the accessed entry points will be built. Or if there are many `import()` statements in the project, each module pointed to by `import()` will only be built when it is actually accessed.

If set to true, lazy compilation will be applied by default to both entry modules and modules pointed to by `import()`. You can decide whether it applies only to entries or only to `import()` through a configuration object. The `entries` option determines whether it applies to entries, while the `import()` option determines whether it applies to `import()`.

```js title="rspack.config.mjs"
const isDev = process.env.NODE_ENV === 'development';

export default {
  experiments: {
    // only enabled in dev mode
    lazyCompilation: isDev,
  },
};
```

In addition, you can also configure a `test` parameter for more fine-grained control over which modules are lazily compiled. The `test` parameter can be a regular expression that matches only those modules that should be lazily compiled. It can also be a function where the input is of type 'Module' and returns a boolean value indicating whether it meets the criteria for lazy compilation logic.

:::tip
The current lazy compilation aligns with the webpack implementation, **and is still in the experimental stage**. In some scenarios, lazy compilation might not work as expected, or the performance improvement may be insignificant.
:::

## experiments.lazyCompilation.backend

- **Type:** `LazyCompilationBackendOptions`

```ts
type LazyCompilationBackendOptions = {
  /**
   * Custom client script path.
   */
  client?: string;
  /**
   * Specify the port or options to listen from the server.
   */
  listen?: number | ListenOptions | ((server: Server) => void);
  /**
   * Specify the protocol used by the client.
   */
  protocol?: 'http' | 'https';
  /**
   * Specify how to create a server that handles EventSource requests.
   */
  server?:
    | ServerOptionsImport<typeof IncomingMessage>
    | ServerOptionsHttps<typeof IncomingMessage, typeof ServerResponse>
    | (() => Server);
};
```

Enabling lazy compilation will start a separate server to handle requests from clients. You can customize the behavior of the server by configuring `lazyCompilation.backend`, and you can also provide your own server instance.

### lazyCompilation.backend.server

- **Type:**

```ts
type ServerOptions =
  | ServerOptionsImport<typeof IncomingMessage>
  | ServerOptionsHttps<typeof IncomingMessage, typeof ServerResponse>
  | (() => Server);
```

```js title="rspack.config.mjs"
export default {
  experiments: {
    lazyCompilation: {
      backend: {
        server() {
          return yourServer;
        },
      },
    },
  },
};
```

You can provide a custom server instance to handle requests from clients for `lazy-compilation`. The provided server must meet the following interface requirements.

```ts
import type { IncomingMessage, ServerResponse } from 'node:http';
import type { AddressInfo, ListenOptions, Socket } from 'node:net';

interface Server {
  // Register callback function to handle requests
  on(
    event: 'request',
    callback: (req: IncomingMessage, res: ServerResponse) => void,
  ): void;

  // Register callback function for new client connections
  on(event: 'connection', callback: (socket: Socket) => void): void;

  // Register callback function for new client connections
  on(event: 'listening', callback: (err?: Error) => void): void;

  // Unregister registered callbacks
  off(event: string, callback: () => void): void;

  // Show address information of the server
  address(): AddressInfo;

  close(callback: (err?: any) => void): void;

  listen(listenOption: number | ListenOption): void;
}
```

### lazyCompilation.backend.listen

- **Type:** `number | ListenOptions | ((server: Server) => void)`

```ts
type ListenOptions = {
  port?: number | undefined;
  host?: string | undefined;
  backlog?: number | undefined;
  path?: string | undefined;
  exclusive?: boolean | undefined;
  readableAll?: boolean | null;
  writableAll?: boolean | null;
  ip6Only?: boolean | null;
};
```

Specify how the sever listens ,you can pass in object form listening configuration,such as specifying listening ports,you can also pass in functions control how listen is done.

When providing a custom server instance, you are responsible for calling the server's `listen` method to start the service, unless you explicitly configure a function forms` listen` option.

### Exclude HMR client

If you do not use Rspack's own dev server and instead use your own server as the dev server, you generally need to add another client modules in the entry configuration to enable capabilities such as HMR. It is best to exclude these client module from lazy compilation by configuring `test`.

If not excluded and lazy compilation of entry is enabled, this client will not be compiled when accessing the page for the first time, so an additional refresh is needed to make it take effect.

For example:

```js title="rspack.config.mjs"
import { rspack } from '@rspack/core';

const options = {
  experiments: {
    lazyCompilation: {
      test(module) {
        const isMyClient = module.nameForCondition().endsWith('dev-client.js');
        // make sure that dev-client.js won't be lazy compiled
        return !isMyClient;
      },
    },
  },
};
const compiler = rspack(options);

new compiler.webpack.EntryPlugin(compiler.context, 'dev-client.js', {
  // name: undefined means this is global entry
  name: undefined,
}).apply(compiler);
```

## experiments.layers

<ApiMeta addedVersion="1.0.0-beta.1" />

- **Type:** `boolean`
- **Default:** `false`

Controls whether to enable the layer feature. Layers can add an identifier prefix to all modules in a subgraph starting from a module in the module graph, to distinguish them from modules in different layers. For example:

The `layer` of the `index.js` module is by default `null`, and its `identifier` is `./index.js`. If we set `layer = 'client'` for it, its `identifier` will become `(client)/./index.js`. At this point, the `index.js` modules in these two different layers will be treated as distinct modules, because their unique `identifier`s are different. As a result, the final output will include the artifacts of both modules.

By default, a module's layer is `null`, and it will inherit its parent module's layer. You can add a layer to an entry module using `entryOptions.layer`, and you can add a layer to matched modules using [`module.rule[].layer`](/config/module#rulelayer). Additionally, you can match based on the parent module's layer using [`module.rule[].issuerLayer`](/config/module#ruleissuerlayer).

```js title="rspack.config.mjs"
export default {
  experiments: {
    layers: true,
  },
};
```

## experiments.incremental

<ApiMeta addedVersion="1.1.0-beta.0" />

<PropertyType
  type="boolean | Incremental"
  defaultValueList={[
    { defaultValue: 'false', mode: 'production' },
    { defaultValue: '{ make: true, emitAssets: true }', mode: 'development' },
  ]}
/>

```ts
type Incremental = {
  make?: boolean;
  inferAsyncModules?: boolean;
  providedExports?: boolean;
  dependenciesDiagnostics?: boolean;
  sideEffects?: boolean;
  buildChunkGraph?: boolean;
  moduleIds?: boolean;
  chunkIds?: boolean;
  modulesHashes?: boolean;
  modulesCodegen?: boolean;
  modulesRuntimeRequirements?: boolean;
  chunksRuntimeRequirements?: boolean;
  chunksHashes?: boolean;
  chunksRender?: boolean;
  emitAssets?: boolean;
};
```

Whether to enable incremental rebuild to speed up the rebuild speed. It is recommended to enable it only during development.

```js title="rspack.config.mjs"
const isDev = process.env.NODE_ENV === 'development';

export default {
  mode: isDev ? 'development' : 'production',
  experiments: {
    incremental: isDev,
  },
};
```

`true` means enable incremental for all stages. `false` means disable incremental for all stages. Incremental can also be enabled only for specified partial stages:

```js title="rspack.config.mjs"
export default {
  experiments: {
    // enable incremental for all stages
    incremental: true,
    // disable incremental for all stages
    incremental: false,
    // enable only for specified partial stages
    incremental: {
      make: true,
      emitAssets: true,
    },
  },
};
```

Currently, incremental for the `make` and `emitAssets` stages is enabled by default. This is also the default behavior since Rspack v1.0. As this feature further stabilizes, we will enable incremental for more stages by default.

:::tip
This feature is experimental. You can check its relevant progress at [rspack#8106](https://github.com/web-infra-dev/rspack/issues/8106). You can also report bugs and any related feedback here.
:::

## experiments.parallelCodeSplitting

<ApiMeta addedVersion="1.2.0" />

- **Type:** `boolean`
- **Default:** `false`

Enabling this configuration will activate a new multi-threaded code splitting algorithm. If your project includes many dynamic imports, this can greatly reduce the time spent on the code splitting process. In the future, Rspack will have this enabled by default.

```js title="rspack.config.mjs"
export default {
  experiments: {
    parallelCodeSplitting: true,
  },
};
```

## experiments.rspackFuture

- **Type:** `object`

- **Default:** See options down below for details

Used to control whether to enable Rspack future default options, check out the details [here](https://github.com/web-infra-dev/rspack/pull/4107).

### rspackFuture.bundlerInfo

<ApiMeta addedVersion="1.0.0" />

- **Type**:
  ```ts
  type BundlerInfo = {
    version?: string,
    bundler?: string,
    force?: ('version' | 'uniqueId')[] ï½œ boolean;
  };
  ```

Used to inject the currently used Rspack information into the generated asset:

- `version`: Used to specify the Rspack version, defaults to the `version` field in `@rspack/core/package.json`.
- `bundler`: Used to specify the name of the packaging tool, defaults to `rspack`.
- `force`: Whether to force the injection of Rspack information, which will be added to chunk as a runtime module, and defaults to `true` to force injection. An array can be used to select the items to be forced injected.

#### Disable default injection

The default injection can be disabled by setting `force` to `false`. Then injection will only occur when `__rspack_version__` and `__rspack_unique_id__` are detected in the code:

- [`__rspack_version__`](/api/runtime-api/module-variables#__rspack_version__): Inject version information.
- [`__rspack_unique_id__`](/api/runtime-api/module-variables#__rspack_unique_id__): Inject the unique ID of the bundler.

```js title="rspack.config.mjs"
export default {
  experiments: {
    rspackFuture: { bundlerInfo: { force: false } },
  },
};
```

## experiments.cache

<ApiMeta addedVersion="1.2.0-alpha.0" />

- **Type:** `ExperimentCacheOptions`

- **Default:** production mode is `false`, development mode is `true`

```ts
type ExperimentCacheOptions =
  | boolean
  | {
      type: 'memory';
    }
  | {
      type: 'persistent';
      buildDependencies?: string[];
      version?: string;
      snapshot?: {
        immutablePaths?: Array<string | RegExp>;
        unmanagedPaths?: Array<string | RegExp>;
        managedPaths?: Array<string | RegExp>;
      };
      storage?: {
        type: 'filesystem';
        directory?: string;
      };
    };
```

Control experimental caching behavior. This will only work if [config.cache](/config/cache) is set to `true`.

:::info title="Note"
In production mode, the default value of `config.cache` is `false`, which will cause this configuration item invalid. It is recommended to directly configure `config.cache` to `true`.
:::

### Disable cache

Configuring `experiment.cache` to `false` to disable cache, which is no different from configuring the [config.cache](/config/cache) to `false`.

```js title="rspack.config.mjs"
export default {
  cache: true,
  experiments: {
    cache: false,
  },
};
```

### Memory cache

Configuring `experiment.cache` to `true` or `{ "type": "memory" }` to enable memory cache.

```js title="rspack.config.mjs"
export default {
  cache: true,
  experiments: {
    cache: true,
  },
};
```

### Persistent cache

Configuring `experiment.cache` to `{ "type": "persistent" }` to enable persistent cache.

```js title="rspack.config.mjs"
export default {
  cache: true,
  experiments: {
    cache: {
      type: 'persistent',
    },
  },
};
```

#### cache.buildDependencies

- **Type:** `string[]`

- **Default:** `[]`

`cache.buildDependencies` is an array of files containing build dependencies, Rspack will use the hash of each of these files to invalidate the persistent cache.

:::tip
It's recommended to set `cache.buildDependencies`: [__filename] in your rspack configuration to get the latest configuration.
:::

```js title="rspack.config.mjs"
export default {
  cache: true,
  experiments: {
    cache: {
      type: 'persistent',
      buildDependencies: [__filename, path.join(__dirname, './tsconfig.json')],
    },
  },
};
```

#### cache.version

- **Type:** `string`

- **Default:** `""`

Cache versions, different versions of caches are isolated from each other.

:::tip title="Persistent cache invalidation"

In addition to [buildDependencies](#cachebuilddependencies) and [version](#cacheversion) configurations that affect persistent cache invalidation, Rspack also invalidates persistent cache when the following fields change.

- [config.name](/config/other-options#name)
- [config.mode](/config/mode#mode)

:::

#### cache.snapshot

Configure snapshot strategy. Snapshot is used to determine which files have been modified during shutdown. The following configurations are supported:

##### snapshot.immutablePaths

- **Type:** `(RegExp | string)[]`

- **Default:** `[]`

An array of paths to immutable files, changes to these paths will be ignored during hot restart.

##### snapshot.managedPaths

- **Type:** `(RegExp | string)[]`

- **Default:** `[/\/node_modules\//]`

An array of paths managed by the package manager. During hot start, it will determine whether to modify the path based on the version in package.json.

##### snapshot.unmanagedPaths

- **Type:** `(RegExp | string)[]`

- **Default:** `[]`

Specifies an array of paths in `snapshot.managedPaths` that are not managed by the package manager

#### cache.storage

- **Type:** `{ type: 'filesystem', directory: string }`

- **Default:** `{ type: 'filesystem', directory: 'node_modules/.cache/rspack' }`

Configure cache storage. Currently only file system storage is supported. The cache directory can be set through `directory`. The default is `node_modules/.cache/rspack`.

```js title="rspack.config.mjs"
export default {
  cache: true,
  experiments: {
    cache: {
      type: 'persistent',
      storage: {
        type: 'filesystem',
        directory: 'node_modules/.cache/rspack',
      },
    },
  },
};
```

:::tip
Rspack will generate a cache folder in the `storage.directory` based on [config.name](/config/other-options#name), [config.mode](/config/mode#mode), the file contents in [buildDependencies](#cachebuilddependencies) and [version](#cacheversion).

Rspack will automatically clean up cache folders that have not been accessed for a long time (7 days) at startup.
:::

### Migrating from webpack config

The Rspack cache configuration is different from the webpack cache configuration. You can refer to the following steps to migrate the webpack cache configuration.

1. According to the cache type, set the Rspack cache type. Continue with the next step for persistent cache, and stop here for other types of cache.

```diff title="rspack.config.mjs"
export default {
- cache: {
-   type: 'filesystem',
- },
+ cache: true,
+ experiments: {
+   cache: {
+     type: 'persistent',
+   },
+ },
};
```

2. Migrate `cache.buildDependencies`

```diff title="rspack.config.mjs"
export default {
- cache: {
-   buildDependencies: {
-     config: [__filename, path.join(__dirname, "package.json")],
-     ts: [path.join(__dirname, "tsconfig.json")]
-   }
- },
  experiments: {
    cache: {
      type: "persistent",
+     buildDependencies: [
+       __filename,
+       path.join(__dirname, "package.json"),
+       path.join(__dirname, "tsconfig.json")
+     ]
    },
  },
};
```

3. Migrate `cache.version` and `cache.name`

```diff title="rspack.config.mjs"
export default {
- cache: {
-   name: `${config.name}-${config.mode}-${otherFlags}`,
-   version: appVersion
- },
  experiments: {
    cache: {
      type: "persistent",
+     version: `${config.name}-${config.mode}-${otherFlags}-${appVersion}`
    },
  },
};
```

4. Migrate `snapshot`

```diff title="rspack.config.mjs"
export default {
- snapshot: {
-   immutablePaths: [path.join(__dirname, "constant")],
-   managedPaths: [path.join(__dirname, "node_modules")],
-   unmanagedPaths: []
- },
  experiments: {
    cache: {
      type: "persistent",
+     snapshot: {
+       immutablePaths: [path.join(__dirname, "constant")],
+       managedPaths: [path.join(__dirname, "node_modules")],
+       unmanagedPaths: []
+     }
    },
  },
};
```

5. Migrate `cache.cacheDirectory`

```diff title="rspack.config.mjs"
export default {
- cache: {
-   cacheDirectory: path.join(__dirname, "node_modules/.cache/test")
- },
  experiments: {
    cache: {
      type: "persistent",
+     storage: {
+       type: "filesystem",
+       directory: path.join(__dirname, "node_modules/.cache/test")
+     }
    },
  },
};
```

Sample migration code:

```js
function transform(webpackConfig, rspackConfig) {
  rspackConfig.experiments = rspackConfig.experiments || {};
  if (webpackConfig.cache === undefined) {
    webpackConfig.cache = webpackConfig.mode === 'development';
  }
  // 1. if using disable cache, just set `experiments.cache` = false
  if (!webpackConfig.cache) {
    rspackConfig.experiments.cache = false;
    return;
  }
  // 2. if using memory cache, just set `experiments.cache` = true
  if (webpackConfig.cache === true || webpackConfig.cache.type === 'memory') {
    rspackConfig.experiments.cache = true;
    return;
  }
  // 3. using persistent cache, set `experiments.cache` = { type: "persistent" }
  rspackConfig.experiments.cache = { type: 'persistent' };
  // 4. building `experiments.cache` from webpack config
  rspackConfig.experiments.cache.buildDependencies = Object.values(
    webpackConfig.cache.buildDependencies || {},
  ).flat();
  rspackConfig.experiments.cache.version = [
    webpackConfig.cache.name,
    webpackConfig.cache.version,
  ].join();
  rspackConfig.experiments.cache.snapshot = {
    immutablePaths: webpackConfig.snapshot?.immutablePaths,
    managedPaths: webpackConfig.snapshot?.managedPaths,
    unmanagedPaths: webpackConfig.snapshot?.unmanagedPaths,
  };
  rspackConfig.experiments.cache.storage = {
    type: 'filesystem',
    directory: webpackConfig.cache?.cacheDirectory,
  };
}
```
