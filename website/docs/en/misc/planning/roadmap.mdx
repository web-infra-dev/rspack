# Roadmap

The current document lists some important features that Rspack will support, some of which are already in progress, while others will be implemented in future versions of Rspack.

> Last updated: 2024-10

## Rspack 1.x iteration

Rspack will release a minor version every 2-3 months, each containing significant new features and improvements.

## Faster HMR

We are developing a new incremental build implementation that will significantly enhance Rspack's HMR performance.

Rspack v1.1 will support this feature experimentally, and will continue to optimize it in future versions until it is enabled by default.

## Persistent cache

Persistent Cache can cache the build artifacts during multiple builds, significantly reducing the time for subsequent builds, especially providing a substantial performance boost for large projects.

We are implementing the Persistent Cache feature for Rspack and plan to release experimental support in Rspack v1.2.

## Portable cache

The evolution path of Rspack's caching capabilities follows a sequential implementation of memory cache, persistent cache, and portable cache. Currently, Rspack has implemented the memory cache and is implementing the persistent cache.

After that, we plan to continue implementing portable cache. This means that Rspack's build cache will not only be persistent, but also portable across environments and machines. This will help teams make better use of the cache and lay the groundwork for distributed builds.

## Webpack API alignment

As webpack contains a large number of APIs, we will be working to support the most frequently used loaders and plugins based on feedback from the community first.

## Stable Rust API

Currently, higher-level tools can use the JS API to integrate Rspack, which provides good extensibility. However, the communication overhead between Rust and JavaScript that limits the performance of Rspack. We also provide the [SWC Wasm plugin](/guide/features/builtin-swc-loader#jscexperimentalplugins) to support extensions, but its performance is still slower than native languages.To provide higher-level tools with more flexible integration options and better performance, we plan to expose Rspack's Rust API for integration.

## Improved ESM output

ESM is the standard for JavaScript modules. We are currently improving Rspack and webpack's support for ESM output and creating a library build tool based on Rspack called Rslib. This will allow developers to make better use of ESM's static analysis and tree-shaking when building npm packages.

## React Server Components support

At ByteDance, we have experimentally supported RSC ([React Server Components](https://react.dev/reference/rsc/server-components)) based on Rspack and validated it in a large web application. In the future, Rspack will provide first-class support for RSC, with more core features to make RSC easier to implement. For example, Rspack now supports the [layer](/config/experiments#experimentslayers) feature, which allows to build for multiple environments in a single run.

## TypeScript-based optimization

Currently, when Rspack processes TypeScript modules, it first converts them to JavaScript through a loader before further processing. This provides flexibility but also hinders further optimization of the build output. For example, developers need to use `enum` instead of `const enum`, but `enum` is difficult to optimize as a constant. In the future, we plan to treat TypeScript as a first-class citizen in Rspack, leveraging TypeScript's static information to provide more advanced compile-time optimization of the build output (such as [type-based property renaming](https://github.com/google/closure-compiler/wiki/Type-Based-Property-Renaming)).
