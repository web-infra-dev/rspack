import { Table } from '@builtIns';
import WebpackLicense from '@components/WebpackLicense';

<WebpackLicense from="https://webpack.js.org/plugins/dll-plugin/#dllreferenceplugin" />

# DllReferencePlugin

The `DllReferencePlugin` is used be reference the dll-only-bundle to require pre-built dependencies.

## Options

- **Types:**

```ts
type DllReferencePluginOptionsContent = {
  /**
   * Module info.
   */
  [k: string]: {
    /**
     * Meta information about the module.
     */
    buildMeta?: {
      [k: string]: any;
    };
    /**
     * Information about the provided exports of the module.
     */
    exports?: string[] | true;
    /**
     * Module ID.
     */
    id?: string;
  };
};

type DllReferencePluginOptionsManifest = {
  /**
   * The mappings from module specifier to module info.
   */
  content: DllReferencePluginOptionsContent;
  /**
   * The name where the dll is exposed (external name).
   */
  name?: string;
  /**
   * The type how the dll is exposed (external type).
   */
  type?: DllReferencePluginOptionsSourceType;
};

/**
 * The type how the dll is exposed (external type).
 */
type DllReferencePluginOptionsSourceType =
  | 'var'
  | 'assign'
  | 'this'
  | 'window'
  | 'global'
  | 'commonjs'
  | 'commonjs2'
  | 'commonjs-module'
  | 'amd'
  | 'amd-require'
  | 'umd'
  | 'umd2'
  | 'jsonp'
  | 'system';

type DllReferencePluginOptions =
  | {
      /**
       * Context of requests in the manifest (or content property) as absolute path.
       */
      context?: string;
      /**
       * Extensions used to resolve modules in the dll bundle (only used when using 'scope').
       */
      extensions?: string[];
      /**
       * An object containing content and name or a string to the absolute path of the JSON manifest to be loaded upon compilation.
       */
      manifest: string | DllReferencePluginOptionsManifest;
      /**
       * The name where the dll is exposed (external name, defaults to manifest.name).
       */
      name?: string;
      /**
       * Prefix which is used for accessing the content of the dll.
       */
      scope?: string;
      /**
       * How the dll is exposed (libraryTarget, defaults to manifest.type).
       */
      sourceType?: DllReferencePluginOptionsSourceType;
      /**
       * The way how the export of the dll bundle is used.
       */
      type?: 'require' | 'object';
    }
  | {
      /**
       * The mappings from module specifier to module info.
       */
      content: DllReferencePluginOptionsContent;
      /**
       * Context of requests in the manifest (or content property) as absolute path.
       */
      context?: string;
      /**
       * Extensions used to resolve modules in the dll bundle (only used when using 'scope').
       */
      extensions?: string[];
      /**
       * The name where the dll is exposed (external name).
       */
      name: string;
      /**
       * Prefix which is used for accessing the content of the dll.
       */
      scope?: string;
      /**
       * How the dll is exposed (libraryTarget).
       */
      sourceType?: DllReferencePluginOptionsSourceType;
      /**
       * The way how the export of the dll bundle is used.
       */
      type?: 'require' | 'object';
    };
```

This plugin references a dll manifest file to map dependency names to module ids, then require them as needed.

## Examples

### Basic example

```js
new rspack.DllReferencePlugin({
  // Manifest should be generated by DllPlugin
  manifest: require('../lib/manifest.json'),

  name: '[name]_dll_lib',
});
```

Application require dependencies will reference to pre-built using `DllPlugin`.

### With scope

The content of the dll is accessible under a module prefix when set scope.

```js
new rspack.DllReferencePlugin({
  // Manifest should be generated by DllPlugin
  manifest: require('../lib/manifest.json'),

  name: '[name]_dll_lib',

  scope: 'xyz',
});
```

Access via `require('xzy/abc')`, you can require `abc` from another pre-built lib.
