---
date: 2025-6-26 16:00:00
sidebar: false
---

_June 26, 2025_

# Announcing Rspack 1.4

![Rspack 1.4](https://assets.rspack.dev/rspack/rspack-banner-v1-4.png)

---

Rspack 1.4 has been released!

Notable changes:

- New features
  - [Running in the browser](#running-in-the-browser)
  - [Faster SWC](#faster-swc)
  - [Smaller bundles](#smaller-bundles)
  - [Incremental build by default](#incremental-build-by-default)
  - [New CssChunkingPlugin](#new-csschunkingplugin)
  - [More flexible lazy compilation](#more-flexible-lazy-compilation)
  - [Custom input file system](#custom-input-file-system)
  - [Performance analysis tool](#performance-analysis-tool)
- Rstack progress
  - [Rsbuild 1.4](#rsbuild-14)
  - [Rslib 0.10](#rslib-010)
  - [Rspress 2.0 beta](#rspress-20-beta)
  - [Rsdoctor MCP](#rsdoctor-mcp)
  - [Rstest released](#rstest-released)
- Ecosystem
  - [next-rspack](#next-rspack)
  - [Kmi](#kmi)
- Upgrade guide

## New features

### Running in the browser

Starting with Rspack 1.4, we have added Wasm target support, which means Rspack can now run in browser environments, including online platforms like [StackBlitz](https://stackblitz.com/) ([WebContainers](https://blog.stackblitz.com/posts/introducing-webcontainers/)). This enables developers to quickly create prototypes and share code examples without having to configure local environments.

You can try out our [online example](https://stackblitz.com/~/github.com/rspack-contrib/rsbuild-stackblitz-example) directly, or learn about the StackBlitz usage guide in [this documentation](/guide/start/quick-start#preview-with-stackblitz).

<video
  src="https://assets.rspack.dev/rspack/assets/rspack-v1-4-wasm-target.mp4"
  autoPlay
  muted
  loop
/>

In future versions, we will continue to optimize the Wasm version's usability and bundle size.

We are also developing the `@rspack/browser` package, which is a browser-specific version of Rspack, allowing you to use Rspack directly in any modern browser without relying on WebContainers or specific platforms.

### Faster SWC

Over the past few months, we have been continuously collaborating with the SWC team to optimize the performance and reliability of the JavaScript toolchain. After a period of optimization, we are pleased to see that SWC's performance has improved significantly, benefiting both Rspack users and all SWC-based tools:

- JavaScript parser is **30%～35%** faster
- JavaScript minifier is **10%** faster

<img
  src="https://assets.rspack.rs/rspack/assets/rspack-v1-4-swc-benchmark.png"
  alt="SWC benchmark"
/>

> The above data is from: [CodSpeed - SWC](https://codspeed.io/swc-project/swc), compared against SWC 16 used by Rspack 1.3 as the baseline.

Here's the professional English translation:

### Smaller bundles

SWC has enhanced its dead code elimination (DCE) capabilities in the current version, which combined with Rspack's powerful [tree shaking](/guide/optimization/tree-shaking) functionality, enables Rspack 1.4 to generate smaller bundles.

We tested this using `react-router` as an example: by importing only part of its exports in the source code and then comparing the build outputs from different bundlers, we found that Rspack generates smallest bundles.

```js title="src/index.js"
import { BrowserRouter, Routes, Route } from 'react-router';

console.log(BrowserRouter, Routes, Route);
```

The output bundle sizes by different bundlers are as follows:

| Bundler          | Minified Size | Min+Gzipped Size |
| ---------------- | ------------- | ---------------- |
| Rspack (Rsbuild) | **36.35 kB**  | **13.26 kB**     |
| webpack          | 36.96 kB      | 13.37 kB         |
| Vite             | 42.67 kB      | 15.67 kB         |
| Rolldown         | 42.74 kB      | 15.17 kB         |
| Rolldown Vite    | 43.42 kB      | 15.46 kB         |
| Farm             | 43.42 kB      | 15.63 kB         |
| Parcel           | 44.62 kB      | 16.07 kB         |
| esbuild          | 46.12 kB      | 16.63 kB         |
| Bun              | 57.73 kB      | 20.8 kB          |

> Data from [react-router-tree-shaking-compare](https://github.com/chenjiahan/react-router-tree-shaking-compare).

### Incremental build by default

After extensive optimization, Rspack's incremental build has become stable. In Rspack 1.4, we've enabled incremental build for all phases by default, which significantly speeds up rebuilds - HMR performance typically improves by **30%-40%**, depending on the project.

Here is a performance comparison from one user after enabling incremental build:

<img
  src="https://assets.rspack.dev/rspack/assets/rspack-v1-4-incremental-data.png"
  alt="incremental benchmark"
  width="760"
/>

If you need to revert to the previous behavior, you can set [experiments.incremental](/config/experiments#experimentsincremental) to `'safe'`. However, we recommend that most projects use the new default configuration to achieve optimal performance.

```js title="rspack.config.mjs"
export default {
  experiments: {
    // Revert to previous behavior
    incremental: 'safe',
  },
};
```

### New CssChunkingPlugin

Rspack 1.4 introduces an experimental [CssChunkingPlugin](/plugins/rspack/css-chunking-plugin) specifically designed for handling CSS code splitting. This plugin ensures that styles are loaded in the same order as they are imported in the source code, preventing UI issues caused by incorrect CSS loading order.

```js title="rspack.config.mjs"
import { rspack } from '@rspack/core';

export default {
  plugins: [
    new rspack.experiments.CssChunkingPlugin({
      // ...options
    }),
  ],
};
```

Once `CssChunkingPlugin` is enabled, CSS code splitting will be handled entirely by this plugin, and the `optimization.splitChunks` configuration will no longer affect CSS modules. You can check the [documentation](/plugins/rspack/css-chunking-plugin) for more details.

> This plugin is inspired by Next.js's [CSS Chunking](https://nextjs.org/docs/app/api-reference/config/next-config-js/cssChunking) feature. Thanks to the Next.js team for their innovation in this area.

### Enhanced lazy compilation

Rspack now supports enabling lazy compilation with `MultiCompiler`, which means that when you use multiple Rspack configurations in a single build, you can independently configure the [lazyCompilation options](/config/experiments#experimentslazycompilation) for each compiler instance.

```js title="rspack.config.mjs"
export default [
  {
    target: 'web',
    experiments: {
      // enable lazy compilation for client
      lazyCompilation: true,
    },
  },
  {
    target: 'node',
    experiments: {
      // disable lazy compilation for server
      lazyCompilation: false,
    },
  },
];
```

Here's the English translation:

### Custom input file system

Rspack now allows you to customize `compiler.inputFileSystem` (the compiler's input file system). This feature can be enabled by configuring [experiments.useInputFileSystem](/config/experiments#experimentsuseinputfilesystem). Typical use cases include:

- Using [memfs](https://github.com/streamich/memfs) instead of the default input file system in browsers.
- Working with the [webpack-virtual-modules plugin](https://www.npmjs.com/package/webpack-virtual-modules) to support virtual modules.

```js title="rspack.config.mjs"
import VirtualModulesPlugin from 'webpack-virtual-modules';

export default {
  entry: './virtualEntry.js',
  plugins: [
    new VirtualModulesPlugin({
      'virtualEntry.js': `console.log('virtual entry')`,
    }),
  ],
  experiments: {
    useInputFileSystem: [/virtualEntry\.js$/],
  },
};
```

Since the custom `inputFileSystem` is implemented in JavaScript, it may lead to performance degradation. To mitigate this issue, `useInputFileSystem` allows you to pass an array of regular expressions to filter which files need to be read from the custom `inputFileSystem`, which avoids performance overhead caused by replacing the native file system.

In the future, we also plan to add built-in virtual module support in Rspack to provide better performance and user experience.

> For detailed usage, see the [documentation](/config/experiments#experimentsuseinputfilesystem).

### Performance analysis tools

Rspack 1.4 introduces more precise tracing capabilities, which can be used for performance analysis based on [perfetto](https://perfetto.dev/) to quickly identify build performance bottlenecks.

You can enable tracing through the `RSPACK_PROFILE` environment variable:

```sh
RSPACK_PROFILE=OVERVIEW rspack build
```

The generated `rspack.pftrace` file can be visualized and analyzed at [ui.perfetto.dev](https://ui.perfetto.dev/):

<img
  src="https://assets.rspack.dev/rspack/assets/rspack-v1-4-tracing.png"
  alt="tracing"
/>

> For more detailed usage, see the [Tracing documentation](/contribute/development/tracing).

### Dependency upgrades

In Rspack 1.4, we have upgraded several major dependencies, including:

- Rspack now uses [Zod v4](https://zod.dev/v4) for configuration validation.
- `create-rspack` now provides [Biome v2](https://biomejs.dev/blog/biome-v2/) as an optional linter and formatter.

## Rstack progress

[Rstack](/guide/start/ecosystem#rstack) is a unified JavaScript toolchain built around Rspack, with high performance and consistent architecture.

### Rsbuild 1.4

Rsbuild 1.4 已与 Rspack 1.4 同步发布，值得关注的特性有：

#### Chrome DevTools 集成

我们引入了全新的 [rsbuild-plugin-devtools-json](https://github.com/rspack-contrib/rsbuild-plugin-devtools-json) 插件，通过该插件，你可以无缝集成 Chrome DevTools 的 ["自动工作区文件夹"](https://chromium.googlesource.com/devtools/devtools-frontend/+/main/docs/ecosystem/automatic_workspace_folders.md) (Automatic Workspace Folders) 新特性。这意味着你可以在 DevTools 中直接修改和调试项目源码，并将改动保存到本地文件系统。

<img
  src="https://assets.rspack.dev/rspack/assets/rspack-v1-4-rsbuild-plugin-dev-tools-json.png"
  alt="rsbuild plugin devtools json"
  width="760"
/>

#### 改进查询参数

Rsbuild 现在内置支持 `.js?raw` 查询参数，允许你将 JavaScript、TypeScript 和 JSX 文件的原始内容作为文本导入。这在需要将代码作为字符串进行处理的场景下非常有用（例如展示代码示例）。

```js
import rawJs from './script1.js?raw';
import rawTs from './script2.ts?raw';
import rawJsx from './script3.jsx?raw';

console.log(rawJs); // JS 文件的原始内容
console.log(rawTs); // TS 文件的原始内容
console.log(rawJsx); // JSX 文件的原始内容
```

#### 改进浏览器兼容性

当你在 monorepo 中引用其他包的 JS 文件时，Rsbuild 现在默认会使用 SWC 编译它们，这有助于避免外部依赖引入的浏览器兼容性问题。

以下图为例，假设 app 的构建目标为 ES2016，utils 的构建目标为 ES2021，当 `app/src/index.js` 引用 `utils/dist/index.js` 时，SWC 现在会将它降级到 ES2016。

<img
  src="https://assets.rspack.dev/rspack/assets/rspack-v1-4-rsbuild-monorepo-compile-scope.png"
  alt="rsbuild monorepo compile scope"
  width="600"
/>

### Rslib 0.10

Rslib 目前已发布 v0.10 版本，主要新增了以下功能：

#### ESM 产物优化

Rslib 现在默认生成更简洁清晰、体积更小的 ESM 产物。

<img
  src="https://assets.rspack.dev/rspack/assets/rspack-v1-4-rslib-esm.png"
  alt="rslib esm"
  width="700"
/>

#### 构建 Vue 组件库

通过引入 [rsbuild-plugin-unplugin-vue](https://github.com/rspack-contrib/rsbuild-plugin-unplugin-vue) 插件，你可以使用 Rslib 生成 Vue 组件库的 bundleless 产物。

```ts title="rslib.config.mjs"
import { defineConfig } from '@rslib/core';
import { pluginUnpluginVue } from 'rsbuild-plugin-unplugin-vue';

export default defineConfig({
  plugins: [pluginUnpluginVue()],
  lib: [
    {
      format: 'esm',
      bundle: false,
      output: {
        target: 'web',
      },
    },
  ],
});
```

#### 输出 IIFE 格式

Rslib 现在可以生成 [IIFE 格式](https://rslib.rs/zh/guide/basic/output-format#iife) 的产物，将代码包裹在函数表达式中。

<img
  src="https://assets.rspack.dev/rspack/assets/rspack-v1-4-rslib-iife.png"
  alt="rslib iife"
  width="700"
/>

> 阅读 [博客](https://rslib.rs/blog/introducing-rslib) 进一步了解 Rslib。

### Rspress 2.0 beta

我们正在积极开发 [Rspress 2.0](https://github.com/web-infra-dev/rspress)，并发布了多个 beta 版本。目前，我们已完成大部分代码重构工作，并在 Rspress 2.0 中默认集成 [Shiki](https://shiki.style/) 来提供更强大的代码高亮功能。

同时，我们正在开发全新的主题，预览效果如下：

<img
  src="https://assets.rspack.dev/rspack/assets/rspack-v1-4-rspress-preview.png"
  alt="rspress theme preview"
  width="800"
/>

### Rsdoctor MCP

Rsdoctor 推出了 [@rsdoctor/mcp-server](https://rsdoctor.rs/zh/guide/start/mcp)，结合大模型来帮助你更好地分析构建数据。它能调用 Rsdoctor 的本地构建分析数据，支持通过问答方式快速获取构建分析结果。

Rsdoctor MCP 主要提供产物信息分析、依赖问题分析、产物优化建议和编译优化建议等功能，能够分析构建产物的体积组成、项目依赖关系、重复依赖问题，并针对产物体积优化、代码分割以及编译性能提供相应的优化建议。

<video
  src="https://assets.rspack.dev/rspack/assets/rspack-v1-4-rsdoctor-mcp.mp4"
  autoPlay
  muted
  loop
/>

### Rstest 发布

[Rstest](https://github.com/web-infra-dev/rstest) 是一个全新的基于 Rspack 的测试框架，它为 Rspack 生态提供了全面、一流的支持，能够轻松集成到现有的 Rspack 项目中，提供与 Jest 兼容的 API。

在这个月，我们发布了 Rstest 的 v0.0.3 版本，初步支持了 Node.js 和 UI 组件的测试，并在 Rsbuild 等仓库中接入使用。

<img
  src="https://assets.rspack.dev/rspack/assets/rspack-v1-4-rstest.png"
  alt="rstest"
  width="600"
/>

> Rstest 目前仍处于早期阶段，我们建议你再关注一段时间，以确保它能够提供更完整的测试能力。

## 生态系统

### next-rspack

自从 [Rspack 加入 Next.js 生态](/blog/rspack-next-partner) 以来，我们的首要目标是提升 next-rspack 的稳定性和测试覆盖率。

在最新版本中，Rspack 对 Next.js 的功能支持已基本完善，测试覆盖率达到：

- 生产构建 **99.4%**
- 开发构建 **98.4%**

接下来，我们计划继续推进测试覆盖率至 100%，并进一步优化 next-rspack 的性能表现。

<img
  src="https://assets.rspack.dev/rspack/assets/rspack-v1-4-next-rspack.png"
  alt="next-rspack"
  width="760"
/>

### Kmi

[Kmi](https://github.com/kmijs/kmi) 是一个基于 Umi 和 Rspack 的框架，通过集成 Rspack 作为构建工具，Kmi 为 Umi 项目带来了数倍于 webpack 的构建性能提升。

对于正在使用 Umi 框架的开发者而言，Kmi 提供了一种渐进式的迁移路径，让他们能够在保持项目稳定性的同时，享受 Rspack 带来的性能优势。

更多信息请参考 [Kmi 仓库](https://github.com/kmijs/kmi)。

## 升级指南

### SWC 插件版本升级

如果你的项目中使用了 SWC Wasm 插件（如 `@swc/plugin-emotion` 等），需要将插件升级至兼容 `swc_core@29` 的版本，否则可能因版本不兼容导致构建报错。

> 详情请查阅：[常见问题 - SWC 插件版本不匹配](/errors/swc-plugin-version)。

### Lazy compilation 中间件

Lazy compilation 中间件的接入方式有所变化，该中间件现在可以从 compiler 实例中自动读取 [lazyCompilation](/config/experiments#experimentslazycompilation) 选项，因此你不再需要手动传入 `lazyCompilation` 选项。

```js
import { experiments, rspack } from '@rspack/core';
import { RspackDevServer } from '@rspack/dev-server';

const compiler = rspack([
  // ...multiple configs
]);

// no longer need to pass options to the middleware
const middleware = experiments.lazyCompilationMiddleware(compiler);

const server = new RspackDevServer(
  {
    setupMiddlewares: other => [middleware, ...other],
  },
  compiler,
);
```
