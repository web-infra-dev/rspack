/* esm.sh - p-map@7.0.3 */
async function $(t,c,{concurrency:e=Number.POSITIVE_INFINITY,stopOnError:r=!0,signal:f}={}){return new Promise((n,w)=>{if(t[Symbol.iterator]===void 0&&t[Symbol.asyncIterator]===void 0)throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof t})`);if(typeof c!="function")throw new TypeError("Mapper function is required");if(!(Number.isSafeInteger(e)&&e>=1||e===Number.POSITIVE_INFINITY))throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${e}\` (${typeof e})`);let l=[],m=[],s=new Map,u=!1,o=!1,I=!1,i=0,b=0,g=t[Symbol.iterator]===void 0?t[Symbol.asyncIterator]():t[Symbol.iterator](),E=()=>{y(f.reason)},N=()=>{f?.removeEventListener("abort",E)},T=a=>{n(a),N()},y=a=>{u=!0,o=!0,w(a),N()};f&&(f.aborted&&y(f.reason),f.addEventListener("abort",E,{once:!0}));let x=async()=>{if(o)return;let a=await g.next(),h=b;if(b++,a.done){if(I=!0,i===0&&!o){if(!r&&m.length>0){y(new AggregateError(m));return}if(o=!0,s.size===0){T(l);return}let p=[];for(let[d,v]of l.entries())s.get(d)!==S&&p.push(v);T(p)}return}i++,(async()=>{try{let p=await a.value;if(o)return;let d=await c(p,h);d===S&&s.set(h,d),l[h]=d,i--,await x()}catch(p){if(r)y(p);else{m.push(p),i--;try{await x()}catch(d){y(d)}}}})()};(async()=>{for(let a=0;a<e;a++){try{await x()}catch(h){y(h);break}if(I||u)break}})()})}function M(t,c,{concurrency:e=Number.POSITIVE_INFINITY,backpressure:r=e}={}){if(t[Symbol.iterator]===void 0&&t[Symbol.asyncIterator]===void 0)throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof t})`);if(typeof c!="function")throw new TypeError("Mapper function is required");if(!(Number.isSafeInteger(e)&&e>=1||e===Number.POSITIVE_INFINITY))throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${e}\` (${typeof e})`);if(!(Number.isSafeInteger(r)&&r>=e||r===Number.POSITIVE_INFINITY))throw new TypeError(`Expected \`backpressure\` to be an integer from \`concurrency\` (${e}) and up or \`Infinity\`, got \`${r}\` (${typeof r})`);return{async*[Symbol.asyncIterator](){let f=t[Symbol.asyncIterator]===void 0?t[Symbol.iterator]():t[Symbol.asyncIterator](),n=[],w=0,l=!1,m=0;function s(){if(l||!(w<e&&n.length<r))return;let u=(async()=>{let{done:o,value:I}=await f.next();if(o)return{done:!0};w++,s();try{let i=await c(await I,m++);if(w--,i===S){let b=n.indexOf(u);b>0&&n.splice(b,1)}return s(),{done:!1,value:i}}catch(i){return l=!0,{error:i}}})();n.push(u)}for(s();n.length>0;){let{error:u,done:o,value:I}=await n[0];if(n.shift(),u)throw u;if(o)return;s(),I!==S&&(yield I)}}}}var S=Symbol("skip");export{$ as default,M as pMapIterable,S as pMapSkip};
//# sourceMappingURL=p-map.mjs.map