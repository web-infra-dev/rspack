## API Report File for "@rspack/lite-tapable"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
type Append<T extends any[], U> = {
    0: [U];
    1: [T[0], U];
    2: [T[0], T[1], U];
    3: [T[0], T[1], T[2], U];
    4: [T[0], T[1], T[2], T[3], U];
    5: [T[0], T[1], T[2], T[3], T[4], U];
    6: [T[0], T[1], T[2], T[3], T[4], T[5], U];
    7: [T[0], T[1], T[2], T[3], T[4], T[5], T[6], U];
    8: [T[0], T[1], T[2], T[3], T[4], T[5], T[6], T[7], U];
}[Measure<T["length"]>];

// @public (undocumented)
type ArgumentNames<T extends any[]> = FixedSizeArray<T["length"], string>;

// @public (undocumented)
export type AsArray<T> = T extends any[] ? T : [T];

// @public (undocumented)
export class AsyncParallelHook<T, AdditionalOptions = UnsetAdditionalOptions> extends HookBase<T, void, AdditionalOptions> {
    // (undocumented)
    callAsyncStageRange(queried: QueriedHook<T, void, AdditionalOptions>, ...args: Append<AsArray<T>, Callback<Error, void>>): void;
}

// @public (undocumented)
export class AsyncSeriesBailHook<T, R, AdditionalOptions = UnsetAdditionalOptions> extends HookBase<T, R, AdditionalOptions> {
    // (undocumented)
    callAsyncStageRange(queried: QueriedHook<T, R, AdditionalOptions>, ...args: Append<AsArray<T>, Callback<Error, R>>): void;
}

// @public (undocumented)
export class AsyncSeriesHook<T, AdditionalOptions = UnsetAdditionalOptions> extends HookBase<T, void, AdditionalOptions> {
    // (undocumented)
    callAsyncStageRange(queried: QueriedHook<T, void, AdditionalOptions>, ...args: Append<AsArray<T>, Callback<Error, void>>): void;
}

// @public (undocumented)
export class AsyncSeriesWaterfallHook<T, AdditionalOptions = UnsetAdditionalOptions> extends HookBase<T, AsArray<T>[0], AdditionalOptions> {
    constructor(args?: FixedSizeArray<AsArray<T>["length"], string>, name?: string);
    // (undocumented)
    callAsyncStageRange(queried: QueriedHook<T, AsArray<T>[0], AdditionalOptions>, ...args: Append<AsArray<T>, Callback<Error, AsArray<T>[0]>>): void;
}

// @public (undocumented)
export type Callback<E, T> = (error: E | null, result?: T) => void;

// @public (undocumented)
type ExtractHookAdditionalOptions<H> = H extends Hook<any, any, infer A> ? A : never;

// @public (undocumented)
type ExtractHookArgs<H> = H extends Hook<infer T, any> ? T : never;

// @public (undocumented)
type ExtractHookReturn<H> = H extends Hook<any, infer R> ? R : never;

// @public (undocumented)
type FixedSizeArray<T extends number, U> = T extends 0 ? void[] : ReadonlyArray<U> & {
    0: U;
    length: T;
};

// @public (undocumented)
export type Fn<T, R> = (...args: AsArray<T>) => R;

// @public (undocumented)
export type FnAsync<T, R> = (...args: Append<AsArray<T>, InnerCallback<Error, R>>) => void;

// @public (undocumented)
export type FnPromise<T, R> = (...args: AsArray<T>) => Promise<R>;

// @public (undocumented)
type FullTap = Tap & {
    type: "sync" | "async" | "promise";
    fn: Function;
};

// @public (undocumented)
export interface Hook<T = any, R = any, AdditionalOptions = UnsetAdditionalOptions> {
    // (undocumented)
    intercept(interceptor: HookInterceptor<T, R, AdditionalOptions>): void;
    // (undocumented)
    isUsed(): boolean;
    // (undocumented)
    name?: string;
    // (undocumented)
    queryStageRange(stageRange: StageRange): QueriedHook<T, R, AdditionalOptions>;
    // (undocumented)
    tap(opt: Options<AdditionalOptions>, fn: Fn<T, R>): void;
    // (undocumented)
    tapAsync(opt: Options<AdditionalOptions>, fn: FnAsync<T, R>): void;
    // (undocumented)
    tapPromise(opt: Options<AdditionalOptions>, fn: FnPromise<T, R>): void;
    // (undocumented)
    withOptions(opt: TapOptions & IfSet<AdditionalOptions>): Hook<T, R, AdditionalOptions>;
}

// @public (undocumented)
export class HookBase<T, R, AdditionalOptions = UnsetAdditionalOptions> implements Hook<T, R, AdditionalOptions> {
    constructor(args?: FixedSizeArray<AsArray<T>["length"], string>, name?: string);
    // (undocumented)
    args: ArgumentNames<AsArray<T>>;
    // (undocumented)
    callAsync(...args: Append<AsArray<T>, Callback<Error, R>>): void;
    // (undocumented)
    callAsyncStageRange(queried: QueriedHook<T, R, AdditionalOptions>, ...args: Append<AsArray<T>, Callback<Error, R>>): void;
    // (undocumented)
    _insert(item: FullTap & IfSet<AdditionalOptions>): void;
    // (undocumented)
    intercept(interceptor: HookInterceptor<T, R, AdditionalOptions>): void;
    // (undocumented)
    interceptors: HookInterceptor<T, R, AdditionalOptions>[];
    // (undocumented)
    isUsed(): boolean;
    // (undocumented)
    name?: string;
    // (undocumented)
    _prepareArgs(args: AsArray<T>): (T | undefined)[];
    // (undocumented)
    promise(...args: AsArray<T>): Promise<R>;
    // (undocumented)
    promiseStageRange(queried: QueriedHook<T, R, AdditionalOptions>, ...args: AsArray<T>): Promise<R>;
    // (undocumented)
    queryStageRange(stageRange: StageRange): QueriedHook<T, R, AdditionalOptions>;
    // (undocumented)
    _runCallInterceptors(...args: any[]): void;
    // (undocumented)
    _runDoneInterceptors(): void;
    // (undocumented)
    _runErrorInterceptors(e: Error): void;
    // (undocumented)
    _runRegisterInterceptors(options: FullTap & IfSet<AdditionalOptions>): FullTap & IfSet<AdditionalOptions>;
    // (undocumented)
    _runResultInterceptors(r: R): void;
    // (undocumented)
    _runTapInterceptors(tap: FullTap & IfSet<AdditionalOptions>): void;
    // (undocumented)
    tap(options: Options<AdditionalOptions>, fn: Fn<T, R>): void;
    // (undocumented)
    _tap(type: "sync" | "async" | "promise", options: Options<AdditionalOptions>, fn: Function): void;
    // (undocumented)
    tapAsync(options: Options<AdditionalOptions>, fn: FnAsync<T, R>): void;
    // (undocumented)
    tapPromise(options: Options<AdditionalOptions>, fn: FnPromise<T, R>): void;
    // (undocumented)
    taps: (FullTap & IfSet<AdditionalOptions>)[];
    // (undocumented)
    withOptions(options: TapOptions & IfSet<AdditionalOptions>): Hook<T, R, AdditionalOptions>;
}

// @public (undocumented)
export type HookFactory<H> = (key: HookMapKey, hook?: H) => H;

// @public (undocumented)
export interface HookInterceptor<T, R, AdditionalOptions = UnsetAdditionalOptions> {
    // (undocumented)
    call?: (...args: any[]) => void;
    // (undocumented)
    done?: () => void;
    // (undocumented)
    error?: (err: Error) => void;
    // (undocumented)
    loop?: (...args: any[]) => void;
    // (undocumented)
    name?: string;
    // (undocumented)
    register?: (tap: FullTap & IfSet<AdditionalOptions>) => FullTap & IfSet<AdditionalOptions>;
    // (undocumented)
    result?: (result: R) => void;
    // (undocumented)
    tap?: (tap: FullTap & IfSet<AdditionalOptions>) => void;
}

// @public (undocumented)
export class HookMap<H extends Hook> {
    constructor(factory: HookFactory<H>, name?: string);
    // (undocumented)
    _factory: HookFactory<H>;
    // (undocumented)
    for(key: HookMapKey): H;
    // (undocumented)
    get(key: HookMapKey): H | undefined;
    // (undocumented)
    intercept(interceptor: HookMapInterceptor<H>): void;
    // (undocumented)
    _interceptors: HookMapInterceptor<H>[];
    // (undocumented)
    isUsed(): boolean;
    // (undocumented)
    _map: Map<HookMapKey, H>;
    // (undocumented)
    name?: string;
    // (undocumented)
    queryStageRange(stageRange: StageRange): QueriedHookMap<H>;
}

// @public (undocumented)
export interface HookMapInterceptor<H> {
    // (undocumented)
    factory?: HookFactory<H>;
}

// @public (undocumented)
export type HookMapKey = any;

// @public (undocumented)
type IfSet<X> = X extends UnsetAdditionalOptions ? {} : X;

// @public (undocumented)
type InnerCallback<E, T> = (error?: E | null | false, result?: T) => void;

// @public (undocumented)
export const maxStage: number;

// @public (undocumented)
type Measure<T extends number> = T extends 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 ? T : never;

// @public (undocumented)
export const minStage: number;

// @public (undocumented)
export class MultiHook<H extends Hook> {
    constructor(hooks: H[], name?: string);
    // (undocumented)
    hooks: H[];
    // (undocumented)
    intercept(interceptor: HookInterceptor<ExtractHookArgs<Hook>, ExtractHookReturn<Hook>, ExtractHookAdditionalOptions<Hook>>): void;
    // (undocumented)
    isUsed(): boolean;
    // (undocumented)
    name?: string;
    // (undocumented)
    tap(options: Options<ExtractHookAdditionalOptions<Hook>>, fn: Fn<ExtractHookArgs<Hook>, ExtractHookReturn<Hook>>): void;
    // (undocumented)
    tapAsync(options: Options<ExtractHookAdditionalOptions<Hook>>, fn: FnAsync<ExtractHookArgs<Hook>, ExtractHookReturn<Hook>>): void;
    // (undocumented)
    tapPromise(options: Options<ExtractHookAdditionalOptions<Hook>>, fn: FnPromise<ExtractHookArgs<Hook>, ExtractHookReturn<Hook>>): void;
    // (undocumented)
    withOptions(options: TapOptions & IfSet<ExtractHookAdditionalOptions<Hook>>): MultiHook<Hook<any, any, UnsetAdditionalOptions>>;
}

// @public (undocumented)
export type Options<AdditionalOptions = UnsetAdditionalOptions> = string | (Tap & IfSet<AdditionalOptions>);

// @public (undocumented)
export class QueriedHook<T, R, AdditionalOptions = UnsetAdditionalOptions> {
    constructor(stageRange: StageRange, hook: HookBase<T, R, AdditionalOptions>);
    // (undocumented)
    call(...args: AsArray<T>): R;
    // (undocumented)
    callAsync(...args: Append<AsArray<T>, Callback<Error, R>>): void;
    // (undocumented)
    hook: HookBase<T, R, AdditionalOptions>;
    // (undocumented)
    isUsed(): boolean;
    // (undocumented)
    promise(...args: AsArray<T>): Promise<R>;
    // (undocumented)
    stageRange: StageRange;
    // (undocumented)
    tapsInRange: (FullTap & IfSet<AdditionalOptions>)[];
}

// @public (undocumented)
export class QueriedHookMap<H extends Hook> {
    constructor(stageRange: StageRange, hookMap: HookMap<H>);
    // (undocumented)
    for(key: HookMapKey): QueriedHook<any, any, UnsetAdditionalOptions>;
    // (undocumented)
    get(key: HookMapKey): QueriedHook<any, any, UnsetAdditionalOptions> | undefined;
    // (undocumented)
    hookMap: HookMap<H>;
    // (undocumented)
    isUsed(): boolean;
    // (undocumented)
    stageRange: StageRange;
}

// @public (undocumented)
export const safeStage: (stage: number) => number;

// @public (undocumented)
export type StageRange = readonly [number, number];

// @public (undocumented)
export class SyncBailHook<T, R, AdditionalOptions = UnsetAdditionalOptions> extends HookBase<T, R, AdditionalOptions> {
    // (undocumented)
    call(...args: AsArray<T>): R;
    // (undocumented)
    callAsyncStageRange(queried: QueriedHook<T, R, AdditionalOptions>, ...args: Append<AsArray<T>, Callback<Error, R>>): void;
    // (undocumented)
    callStageRange(queried: QueriedHook<T, R, AdditionalOptions>, ...args: AsArray<T>): R;
    // (undocumented)
    tapAsync(): never;
    // (undocumented)
    tapPromise(): never;
}

// @public (undocumented)
export class SyncHook<T, R = void, AdditionalOptions = UnsetAdditionalOptions> extends HookBase<T, R, AdditionalOptions> {
    // (undocumented)
    call(...args: AsArray<T>): R;
    // (undocumented)
    callAsyncStageRange(queried: QueriedHook<T, R, AdditionalOptions>, ...args: Append<AsArray<T>, Callback<Error, R>>): void;
    // (undocumented)
    callStageRange(queried: QueriedHook<T, R, AdditionalOptions>, ...args: AsArray<T>): R;
    // (undocumented)
    tapAsync(): never;
    // (undocumented)
    tapPromise(): never;
}

// @public (undocumented)
export class SyncWaterfallHook<T, AdditionalOptions = UnsetAdditionalOptions> extends HookBase<T, AsArray<T>[0], AdditionalOptions> {
    constructor(args?: FixedSizeArray<AsArray<T>["length"], string>, name?: string);
    // (undocumented)
    call(...args: AsArray<T>): AsArray<T>[0];
    // (undocumented)
    callAsyncStageRange(queried: QueriedHook<T, AsArray<T>[0], AdditionalOptions>, ...args: Append<AsArray<T>, Callback<Error, AsArray<T>[0]>>): void;
    // (undocumented)
    callStageRange(queried: QueriedHook<T, AsArray<T>[0], AdditionalOptions>, ...args: AsArray<T>): AsArray<T>[0];
    // (undocumented)
    tapAsync(): never;
    // (undocumented)
    tapPromise(): never;
}

// @public (undocumented)
type Tap = TapOptions & {
    name: string;
};

// @public (undocumented)
type TapOptions = {
    before?: string;
    stage?: number;
};

// @public (undocumented)
class UnsetAdditionalOptions {
    // (undocumented)
    _UnsetAdditionalOptions: true;
}

// (No @packageDocumentation comment for this package)

```
