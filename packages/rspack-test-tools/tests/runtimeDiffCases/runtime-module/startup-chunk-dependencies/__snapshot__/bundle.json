{
  "modules": {
    "javascript/esm|__WORKSPACE__/node_modules/.pnpm/@jridgewell+gen-mapping@0.3.5/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs": "(function () {\n  __webpack_require__.r(__webpack_exports__);\n  __webpack_require__.d(__webpack_exports__, {\n    \"GenMapping\": function () {\n      return GenMapping;\n    },\n    \"addMapping\": function () {\n      return addMapping;\n    },\n    \"addSegment\": function () {\n      return addSegment;\n    },\n    \"allMappings\": function () {\n      return allMappings;\n    },\n    \"fromMap\": function () {\n      return fromMap;\n    },\n    \"maybeAddMapping\": function () {\n      return maybeAddMapping;\n    },\n    \"maybeAddSegment\": function () {\n      return maybeAddSegment;\n    },\n    \"setIgnore\": function () {\n      return setIgnore;\n    },\n    \"setSourceContent\": function () {\n      return setSourceContent;\n    },\n    \"toDecodedMap\": function () {\n      return toDecodedMap;\n    },\n    \"toEncodedMap\": function () {\n      return toEncodedMap;\n    }\n  });\n  var __WEBPACK_IMPORTED_MODULE_xxx__ = __webpack_require__(\"../../../../../../node_modules/.pnpm/@jridgewell+set-array@1.2.1/node_modules/@jridgewell/set-array/dist/set-array.mjs\");\n  var __WEBPACK_IMPORTED_MODULE_xxx__ = __webpack_require__(\"../../../../../../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\");\n  var __WEBPACK_IMPORTED_MODULE_xxx__ = __webpack_require__(\"../../../../../../node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs\");\n  const COLUMN = 0;\n  const SOURCES_INDEX = 1;\n  const SOURCE_LINE = 2;\n  const SOURCE_COLUMN = 3;\n  const NAMES_INDEX = 4;\n  const NO_NAME = -1;\n  class GenMapping {\n    constructor({\n      \"file\": file,\n      \"sourceRoot\": sourceRoot\n    } = {}) {\n      this._names = new __WEBPACK_IMPORTED_MODULE_xxx__.SetArray();\n      this._sources = new __WEBPACK_IMPORTED_MODULE_xxx__.SetArray();\n      this._sourcesContent = [];\n      this._mappings = [];\n      this.file = file;\n      this.sourceRoot = sourceRoot;\n      this._ignoreList = new __WEBPACK_IMPORTED_MODULE_xxx__.SetArray();\n    }\n  }\n  function cast(map) {\n    return map;\n  }\n  function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n    return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n  }\n  function addMapping(map, mapping) {\n    return addMappingInternal(false, map, mapping);\n  }\n  const maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n    return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n  };\n  const maybeAddMapping = (map, mapping) => {\n    return addMappingInternal(true, map, mapping);\n  };\n  function setSourceContent(map, source, content) {\n    const {\n      \"_sources\": sources,\n      \"_sourcesContent\": sourcesContent\n    } = cast(map);\n    const index = (0, __WEBPACK_IMPORTED_MODULE_xxx__.put)(sources, source);\n    sourcesContent[index] = content;\n  }\n  function setIgnore(map, source, ignore = true) {\n    const {\n      \"_sources\": sources,\n      \"_sourcesContent\": sourcesContent,\n      \"_ignoreList\": ignoreList\n    } = cast(map);\n    const index = (0, __WEBPACK_IMPORTED_MODULE_xxx__.put)(sources, source);\n    if (index === sourcesContent.length) sourcesContent[index] = null;\n    if (ignore) (0, __WEBPACK_IMPORTED_MODULE_xxx__.put)(ignoreList, index);else (0, __WEBPACK_IMPORTED_MODULE_xxx__.remove)(ignoreList, index);\n  }\n  function toDecodedMap(map) {\n    const {\n      \"_mappings\": mappings,\n      \"_sources\": sources,\n      \"_sourcesContent\": sourcesContent,\n      \"_names\": names,\n      \"_ignoreList\": ignoreList\n    } = cast(map);\n    removeEmptyFinalLines(mappings);\n    return {\n      \"file\": map.file || undefined,\n      \"ignoreList\": ignoreList.array,\n      \"mappings\": mappings,\n      \"names\": names.array,\n      \"sourceRoot\": map.sourceRoot || undefined,\n      \"sources\": sources.array,\n      \"sourcesContent\": sourcesContent,\n      \"version\": 3\n    };\n  }\n  function toEncodedMap(map) {\n    const decoded = toDecodedMap(map);\n    return Object.assign(Object.assign({}, decoded), {\n      \"mappings\": (0, __WEBPACK_IMPORTED_MODULE_xxx__.encode)(decoded.mappings)\n    });\n  }\n  function fromMap(input) {\n    const map = new __WEBPACK_IMPORTED_MODULE_xxx__.TraceMap(input);\n    const gen = new GenMapping({\n      \"file\": map.file,\n      \"sourceRoot\": map.sourceRoot\n    });\n    putAll(cast(gen)._names, map.names);\n    putAll(cast(gen)._sources, map.sources);\n    cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n    cast(gen)._mappings = (0, __WEBPACK_IMPORTED_MODULE_xxx__.decodedMappings)(map);\n    if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList);\n    return gen;\n  }\n  function allMappings(map) {\n    const out = [];\n    const {\n      \"_mappings\": mappings,\n      \"_sources\": sources,\n      \"_names\": names\n    } = cast(map);\n    for (let i = 0; i < mappings.length; i++) {\n      const line = mappings[i];\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        const generated = {\n          \"column\": seg[COLUMN],\n          \"line\": i + 1\n        };\n        let source = undefined;\n        let original = undefined;\n        let name = undefined;\n        if (seg.length !== 1) {\n          source = sources.array[seg[SOURCES_INDEX]];\n          original = {\n            \"column\": seg[SOURCE_COLUMN],\n            \"line\": seg[SOURCE_LINE] + 1\n          };\n          if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n        }\n        out.push({\n          \"generated\": generated,\n          \"name\": name,\n          \"original\": original,\n          \"source\": source\n        });\n      }\n    }\n    return out;\n  }\n  function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n    const {\n      \"_mappings\": mappings,\n      \"_sources\": sources,\n      \"_sourcesContent\": sourcesContent,\n      \"_names\": names\n    } = cast(map);\n    const line = getLine(mappings, genLine);\n    const index = getColumnIndex(line, genColumn);\n    if (!source) {\n      if (skipable && skipSourceless(line, index)) return;\n      return insert(line, index, [genColumn]);\n    }\n    const sourcesIndex = (0, __WEBPACK_IMPORTED_MODULE_xxx__.put)(sources, source);\n    const namesIndex = name ? (0, __WEBPACK_IMPORTED_MODULE_xxx__.put)(names, name) : NO_NAME;\n    if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;\n    if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) return;\n    return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n  }\n  function getLine(mappings, index) {\n    for (let i = mappings.length; i <= index; i++) mappings[i] = [];\n    return mappings[index];\n  }\n  function getColumnIndex(line, genColumn) {\n    let index = line.length;\n    for (let i = index - 1; i >= 0; index = i--) {\n      const current = line[i];\n      if (genColumn >= current[COLUMN]) break;\n    }\n    return index;\n  }\n  function insert(array, index, value) {\n    for (let i = array.length; i > index; i--) array[i] = array[i - 1];\n    array[index] = value;\n  }\n  function removeEmptyFinalLines(mappings) {\n    const {\n      \"length\": length\n    } = mappings;\n    let len = length;\n    for (let i = len - 1; i >= 0; len = i, i--) if (mappings[i].length > 0) break;\n    if (len < length) mappings.length = len;\n  }\n  function putAll(setarr, array) {\n    for (let i = 0; i < array.length; i++) (0, __WEBPACK_IMPORTED_MODULE_xxx__.put)(setarr, array[i]);\n  }\n  function skipSourceless(line, index) {\n    if (index === 0) return true;\n    const prev = line[index - 1];\n    return prev.length === 1;\n  }\n  function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n    if (index === 0) return false;\n    const prev = line[index - 1];\n    if (prev.length === 1) return false;\n    return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);\n  }\n  function addMappingInternal(skipable, map, mapping) {\n    const {\n      \"generated\": generated,\n      \"source\": source,\n      \"original\": original,\n      \"name\": name,\n      \"content\": content\n    } = mapping;\n    if (!source) return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);\n  }\n});",
    "javascript/esm|__WORKSPACE__/node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs": "(function () {\n  __webpack_require__.r(__webpack_exports__);\n  __webpack_require__.d(__webpack_exports__, {\n    \"default\": function () {\n      return resolve;\n    }\n  });\n  const schemeRegex = /^[\\w+.-]+:\\/\\//;\n  const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n  const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n  function isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n  }\n  function isSchemeRelativeUrl(input) {\n    return input.startsWith(\"//\");\n  }\n  function isAbsolutePath(input) {\n    return input.startsWith(\"/\");\n  }\n  function isFileUrl(input) {\n    return input.startsWith(\"file:\");\n  }\n  function isRelative(input) {\n    return /^[.?#]/.test(input);\n  }\n  function parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || \"\", match[3], match[4] || \"\", match[5] || \"/\", match[6] || \"\", match[7] || \"\");\n  }\n  function parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl(\"file:\", \"\", match[1] || \"\", \"\", isAbsolutePath(path) ? path : \"/\" + path, match[3] || \"\", match[4] || \"\");\n  }\n  function makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n      \"hash\": hash,\n      \"host\": host,\n      \"path\": path,\n      \"port\": port,\n      \"query\": query,\n      \"scheme\": scheme,\n      \"type\": 7,\n      \"user\": user\n    };\n  }\n  function parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n      const url = parseAbsoluteUrl(\"http:\" + input);\n      url.scheme = \"\";\n      url.type = 6;\n      return url;\n    }\n    if (isAbsolutePath(input)) {\n      const url = parseAbsoluteUrl(\"http://foo.com\" + input);\n      url.scheme = \"\";\n      url.host = \"\";\n      url.type = 5;\n      return url;\n    }\n    if (isFileUrl(input)) return parseFileUrl(input);\n    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl(\"http://foo.com/\" + input);\n    url.scheme = \"\";\n    url.host = \"\";\n    url.type = input ? input.startsWith(\"?\") ? 3 : input.startsWith(\"#\") ? 2 : 4 : 1;\n    return url;\n  }\n  function stripPathFilename(path) {\n    if (path.endsWith(\"/..\")) return path;\n    const index = path.lastIndexOf(\"/\");\n    return path.slice(0, index + 1);\n  }\n  function mergePaths(url, base) {\n    normalizePath(base, base.type);\n    if (url.path === \"/\") url.path = base.path;else url.path = stripPathFilename(base.path) + url.path;\n  }\n  function normalizePath(url, type) {\n    const rel = type <= 4;\n    const pieces = url.path.split(\"/\");\n    let pointer = 1;\n    let positive = 0;\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n      const piece = pieces[i];\n      if (!piece) {\n        addTrailingSlash = true;\n        continue;\n      }\n      addTrailingSlash = false;\n      if (piece === \".\") continue;\n      if (piece === \"..\") {\n        if (positive) {\n          addTrailingSlash = true;\n          positive--;\n          pointer--;\n        } else if (rel) pieces[pointer++] = piece;\n        continue;\n      }\n      pieces[pointer++] = piece;\n      positive++;\n    }\n    let path = \"\";\n    for (let i = 1; i < pointer; i++) path += \"/\" + pieces[i];\n    if (!path || addTrailingSlash && !path.endsWith(\"/..\")) path += \"/\";\n    url.path = path;\n  }\n  function resolve(input, base) {\n    if (!input && !base) return \"\";\n    const url = parseUrl(input);\n    let inputType = url.type;\n    if (base && inputType !== 7) {\n      const baseUrl = parseUrl(base);\n      const baseType = baseUrl.type;\n      switch (inputType) {\n        case 1:\n          url.hash = baseUrl.hash;\n        case 2:\n          url.query = baseUrl.query;\n        case 3:\n        case 4:\n          mergePaths(url, baseUrl);\n        case 5:\n          url.user = baseUrl.user;\n          url.host = baseUrl.host;\n          url.port = baseUrl.port;\n        case 6:\n          url.scheme = baseUrl.scheme;\n      }\n      if (baseType > inputType) inputType = baseType;\n    }\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n    switch (inputType) {\n      case 2:\n      case 3:\n        return queryHash;\n      case 4:\n        const path = url.path.slice(1);\n        if (!path) return queryHash || \".\";\n        if (isRelative(base || input) && !isRelative(path)) return \"./\" + path + queryHash;\n        return path + queryHash;\n      case 5:\n        return url.path + queryHash;\n      default:\n        return url.scheme + \"//\" + url.user + url.host + url.port + url.path + queryHash;\n    }\n  }\n});",
    "javascript/esm|__WORKSPACE__/node_modules/.pnpm/@jridgewell+set-array@1.2.1/node_modules/@jridgewell/set-array/dist/set-array.mjs": "(function () {\n  __webpack_require__.r(__webpack_exports__);\n  __webpack_require__.d(__webpack_exports__, {\n    \"SetArray\": function () {\n      return SetArray;\n    },\n    \"get\": function () {\n      return get;\n    },\n    \"pop\": function () {\n      return pop;\n    },\n    \"put\": function () {\n      return put;\n    },\n    \"remove\": function () {\n      return remove;\n    }\n  });\n  class SetArray {\n    constructor() {\n      this._indexes = {\n        \"__proto__\": null\n      };\n      this.array = [];\n    }\n  }\n  function cast(set) {\n    return set;\n  }\n  function get(setarr, key) {\n    return cast(setarr)._indexes[key];\n  }\n  function put(setarr, key) {\n    const index = get(setarr, key);\n    if (index !== undefined) return index;\n    const {\n      \"array\": array,\n      \"_indexes\": indexes\n    } = cast(setarr);\n    const length = array.push(key);\n    return indexes[key] = length - 1;\n  }\n  function pop(setarr) {\n    const {\n      \"array\": array,\n      \"_indexes\": indexes\n    } = cast(setarr);\n    if (array.length === 0) return;\n    const last = array.pop();\n    indexes[last] = undefined;\n  }\n  function remove(setarr, key) {\n    const index = get(setarr, key);\n    if (index === undefined) return;\n    const {\n      \"array\": array,\n      \"_indexes\": indexes\n    } = cast(setarr);\n    for (let i = index + 1; i < array.length; i++) {\n      const k = array[i];\n      array[i - 1] = k;\n      indexes[k]--;\n    }\n    indexes[key] = undefined;\n    array.pop();\n  }\n});",
    "javascript/esm|__WORKSPACE__/node_modules/.pnpm/@jridgewell+source-map@0.3.6/node_modules/@jridgewell/source-map/dist/source-map.mjs": "(function () {\n  __webpack_require__.r(__webpack_exports__);\n  __webpack_require__.d(__webpack_exports__, {\n    \"SourceMapConsumer\": function () {\n      return SourceMapConsumer;\n    },\n    \"SourceMapGenerator\": function () {\n      return SourceMapGenerator;\n    }\n  });\n  var __WEBPACK_IMPORTED_MODULE_xxx__ = __webpack_require__(\"../../../../../../node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs\");\n  var __WEBPACK_IMPORTED_MODULE_xxx__ = __webpack_require__(\"../../../../../../node_modules/.pnpm/@jridgewell+gen-mapping@0.3.5/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs\");\n  class SourceMapConsumer {\n    constructor(map, mapUrl) {\n      const trace = this._map = new __WEBPACK_IMPORTED_MODULE_xxx__.AnyMap(map, mapUrl);\n      this.file = trace.file;\n      this.names = trace.names;\n      this.sourceRoot = trace.sourceRoot;\n      this.sources = trace.resolvedSources;\n      this.sourcesContent = trace.sourcesContent;\n      this.version = trace.version;\n    }\n    static fromSourceMap(map, mapUrl) {\n      if (map.toDecodedMap) return new SourceMapConsumer(map.toDecodedMap(), mapUrl);\n      return new SourceMapConsumer(map.toJSON(), mapUrl);\n    }\n    get mappings() {\n      return (0, __WEBPACK_IMPORTED_MODULE_xxx__.encodedMappings)(this._map);\n    }\n    originalPositionFor(needle) {\n      return (0, __WEBPACK_IMPORTED_MODULE_xxx__.originalPositionFor)(this._map, needle);\n    }\n    generatedPositionFor(originalPosition) {\n      return (0, __WEBPACK_IMPORTED_MODULE_xxx__.generatedPositionFor)(this._map, originalPosition);\n    }\n    allGeneratedPositionsFor(originalPosition) {\n      return (0, __WEBPACK_IMPORTED_MODULE_xxx__.allGeneratedPositionsFor)(this._map, originalPosition);\n    }\n    hasContentsOfAllSources() {\n      if (!this.sourcesContent || this.sourcesContent.length !== this.sources.length) return false;\n      for (const content of this.sourcesContent) if (content == null) return false;\n      return true;\n    }\n    sourceContentFor(source, nullOnMissing) {\n      const sourceContent = (0, __WEBPACK_IMPORTED_MODULE_xxx__.sourceContentFor)(this._map, source);\n      if (sourceContent != null) return sourceContent;\n      if (nullOnMissing) return null;\n      throw new Error(`\"${source}\" is not in the SourceMap.`);\n    }\n    eachMapping(callback, context) {\n      (0, __WEBPACK_IMPORTED_MODULE_xxx__.eachMapping)(this._map, context ? callback.bind(context) : callback);\n    }\n    destroy() {}\n  }\n  class SourceMapGenerator {\n    constructor(opts) {\n      this._map = opts instanceof __WEBPACK_IMPORTED_MODULE_xxx__.GenMapping ? opts : new __WEBPACK_IMPORTED_MODULE_xxx__.GenMapping(opts);\n    }\n    static fromSourceMap(consumer) {\n      return new SourceMapGenerator((0, __WEBPACK_IMPORTED_MODULE_xxx__.fromMap)(consumer));\n    }\n    addMapping(mapping) {\n      (0, __WEBPACK_IMPORTED_MODULE_xxx__.maybeAddMapping)(this._map, mapping);\n    }\n    setSourceContent(source, content) {\n      (0, __WEBPACK_IMPORTED_MODULE_xxx__.setSourceContent)(this._map, source, content);\n    }\n    toJSON() {\n      return (0, __WEBPACK_IMPORTED_MODULE_xxx__.toEncodedMap)(this._map);\n    }\n    toString() {\n      return JSON.stringify(this.toJSON());\n    }\n    toDecodedMap() {\n      return (0, __WEBPACK_IMPORTED_MODULE_xxx__.toDecodedMap)(this._map);\n    }\n  }\n});",
    "javascript/esm|__WORKSPACE__/node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs": "(function () {\n  __webpack_require__.r(__webpack_exports__);\n  __webpack_require__.d(__webpack_exports__, {\n    \"decode\": function () {\n      return decode;\n    },\n    \"decodeGeneratedRanges\": function () {\n      return decodeGeneratedRanges;\n    },\n    \"decodeOriginalScopes\": function () {\n      return decodeOriginalScopes;\n    },\n    \"encode\": function () {\n      return encode;\n    },\n    \"encodeGeneratedRanges\": function () {\n      return encodeGeneratedRanges;\n    },\n    \"encodeOriginalScopes\": function () {\n      return encodeOriginalScopes;\n    }\n  });\n  const comma = \",\".charCodeAt(0);\n  const semicolon = \";\".charCodeAt(0);\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  const intToChar = new Uint8Array(64);\n  const charToInt = new Uint8Array(128);\n  for (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n  }\n  function decodeInteger(reader, relative) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n      const c = reader.next();\n      integer = charToInt[c];\n      value |= (integer & 31) << shift;\n      shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) value = -0x80000000 | -value;\n    return relative + value;\n  }\n  function encodeInteger(builder, num, relative) {\n    let delta = num - relative;\n    delta = delta < 0 ? -delta << 1 | 1 : delta << 1;\n    do {\n      let clamped = delta & 0b011111;\n      delta >>>= 5;\n      if (delta > 0) clamped |= 0b100000;\n      builder.write(intToChar[clamped]);\n    } while (delta > 0);\n    return num;\n  }\n  function hasMoreVlq(reader, max) {\n    if (reader.pos >= max) return false;\n    return reader.peek() !== comma;\n  }\n  const bufLength = 1024 * 16;\n  const td = typeof TextDecoder !== \"undefined\" ? new TextDecoder() : typeof Buffer !== \"undefined\" ? {\n    decode(buf) {\n      const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n      return out.toString();\n    }\n  } : {\n    decode(buf) {\n      let out = \"\";\n      for (let i = 0; i < buf.length; i++) out += String.fromCharCode(buf[i]);\n      return out;\n    }\n  };\n  class StringWriter {\n    constructor() {\n      this.pos = 0;\n      this.out = \"\";\n      this.buffer = new Uint8Array(bufLength);\n    }\n    write(v) {\n      const {\n        \"buffer\": buffer\n      } = this;\n      buffer[this.pos++] = v;\n      if (this.pos === bufLength) {\n        this.out += td.decode(buffer);\n        this.pos = 0;\n      }\n    }\n    flush() {\n      const {\n        \"buffer\": buffer,\n        \"out\": out,\n        \"pos\": pos\n      } = this;\n      return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n    }\n  }\n  class StringReader {\n    constructor(buffer) {\n      this.pos = 0;\n      this.buffer = buffer;\n    }\n    next() {\n      return this.buffer.charCodeAt(this.pos++);\n    }\n    peek() {\n      return this.buffer.charCodeAt(this.pos);\n    }\n    indexOf(char) {\n      const {\n        \"buffer\": buffer,\n        \"pos\": pos\n      } = this;\n      const idx = buffer.indexOf(char, pos);\n      return idx === -1 ? buffer.length : idx;\n    }\n  }\n  const EMPTY = [];\n  function decodeOriginalScopes(input) {\n    const {\n      \"length\": length\n    } = input;\n    const reader = new StringReader(input);\n    const scopes = [];\n    const stack = [];\n    let line = 0;\n    for (; reader.pos < length; reader.pos++) {\n      line = decodeInteger(reader, line);\n      const column = decodeInteger(reader, 0);\n      if (!hasMoreVlq(reader, length)) {\n        const last = stack.pop();\n        last[2] = line;\n        last[3] = column;\n        continue;\n      }\n      const kind = decodeInteger(reader, 0);\n      const fields = decodeInteger(reader, 0);\n      const hasName = fields & 0b0001;\n      const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];\n      let vars = EMPTY;\n      if (hasMoreVlq(reader, length)) {\n        vars = [];\n        do {\n          const varsIndex = decodeInteger(reader, 0);\n          vars.push(varsIndex);\n        } while (hasMoreVlq(reader, length));\n      }\n      scope.vars = vars;\n      scopes.push(scope);\n      stack.push(scope);\n    }\n    return scopes;\n  }\n  function encodeOriginalScopes(scopes) {\n    const writer = new StringWriter();\n    for (let i = 0; i < scopes.length;) i = _encodeOriginalScopes(scopes, i, writer, [0]);\n    return writer.flush();\n  }\n  function _encodeOriginalScopes(scopes, index, writer, state) {\n    const scope = scopes[index];\n    const {\n      0: startLine,\n      1: startColumn,\n      2: endLine,\n      3: endColumn,\n      4: kind,\n      \"vars\": vars\n    } = scope;\n    if (index > 0) writer.write(comma);\n    state[0] = encodeInteger(writer, startLine, state[0]);\n    encodeInteger(writer, startColumn, 0);\n    encodeInteger(writer, kind, 0);\n    const fields = scope.length === 6 ? 0b0001 : 0;\n    encodeInteger(writer, fields, 0);\n    if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n    for (const v of vars) encodeInteger(writer, v, 0);\n    for (index++; index < scopes.length;) {\n      const next = scopes[index];\n      const {\n        0: l,\n        1: c\n      } = next;\n      if (l > endLine || l === endLine && c >= endColumn) break;\n      index = _encodeOriginalScopes(scopes, index, writer, state);\n    }\n    writer.write(comma);\n    state[0] = encodeInteger(writer, endLine, state[0]);\n    encodeInteger(writer, endColumn, 0);\n    return index;\n  }\n  function decodeGeneratedRanges(input) {\n    const {\n      \"length\": length\n    } = input;\n    const reader = new StringReader(input);\n    const ranges = [];\n    const stack = [];\n    let genLine = 0;\n    let definitionSourcesIndex = 0;\n    let definitionScopeIndex = 0;\n    let callsiteSourcesIndex = 0;\n    let callsiteLine = 0;\n    let callsiteColumn = 0;\n    let bindingLine = 0;\n    let bindingColumn = 0;\n    do {\n      const semi = reader.indexOf(\";\");\n      let genColumn = 0;\n      for (; reader.pos < semi; reader.pos++) {\n        genColumn = decodeInteger(reader, genColumn);\n        if (!hasMoreVlq(reader, semi)) {\n          const last = stack.pop();\n          last[2] = genLine;\n          last[3] = genColumn;\n          continue;\n        }\n        const fields = decodeInteger(reader, 0);\n        const hasDefinition = fields & 0b0001;\n        const hasCallsite = fields & 0b0010;\n        const hasScope = fields & 0b0100;\n        let callsite = null;\n        let bindings = EMPTY;\n        let range;\n        if (hasDefinition) {\n          const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n          definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);\n          definitionSourcesIndex = defSourcesIndex;\n          range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];\n        } else range = [genLine, genColumn, 0, 0];\n        range.isScope = !!hasScope;\n        if (hasCallsite) {\n          const prevCsi = callsiteSourcesIndex;\n          const prevLine = callsiteLine;\n          callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n          const sameSource = prevCsi === callsiteSourcesIndex;\n          callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n          callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);\n          callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n        }\n        range.callsite = callsite;\n        if (hasMoreVlq(reader, semi)) {\n          bindings = [];\n          do {\n            bindingLine = genLine;\n            bindingColumn = genColumn;\n            const expressionsCount = decodeInteger(reader, 0);\n            let expressionRanges;\n            if (expressionsCount < -1) {\n              expressionRanges = [[decodeInteger(reader, 0)]];\n              for (let i = -1; i > expressionsCount; i--) {\n                const prevBl = bindingLine;\n                bindingLine = decodeInteger(reader, bindingLine);\n                bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n                const expression = decodeInteger(reader, 0);\n                expressionRanges.push([expression, bindingLine, bindingColumn]);\n              }\n            } else expressionRanges = [[expressionsCount]];\n            bindings.push(expressionRanges);\n          } while (hasMoreVlq(reader, semi));\n        }\n        range.bindings = bindings;\n        ranges.push(range);\n        stack.push(range);\n      }\n      genLine++;\n      reader.pos = semi + 1;\n    } while (reader.pos < length);\n    return ranges;\n  }\n  function encodeGeneratedRanges(ranges) {\n    if (ranges.length === 0) return \"\";\n    const writer = new StringWriter();\n    for (let i = 0; i < ranges.length;) i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n    return writer.flush();\n  }\n  function _encodeGeneratedRanges(ranges, index, writer, state) {\n    const range = ranges[index];\n    const {\n      0: startLine,\n      1: startColumn,\n      2: endLine,\n      3: endColumn,\n      \"isScope\": isScope,\n      \"callsite\": callsite,\n      \"bindings\": bindings\n    } = range;\n    if (state[0] < startLine) {\n      catchupLine(writer, state[0], startLine);\n      state[0] = startLine;\n      state[1] = 0;\n    } else if (index > 0) writer.write(comma);\n    state[1] = encodeInteger(writer, range[1], state[1]);\n    const fields = (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n    encodeInteger(writer, fields, 0);\n    if (range.length === 6) {\n      const {\n        4: sourcesIndex,\n        5: scopesIndex\n      } = range;\n      if (sourcesIndex !== state[2]) state[3] = 0;\n      state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n      state[3] = encodeInteger(writer, scopesIndex, state[3]);\n    }\n    if (callsite) {\n      const {\n        0: sourcesIndex,\n        1: callLine,\n        2: callColumn\n      } = range.callsite;\n      if (sourcesIndex !== state[4]) {\n        state[5] = 0;\n        state[6] = 0;\n      } else if (callLine !== state[5]) state[6] = 0;\n      state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n      state[5] = encodeInteger(writer, callLine, state[5]);\n      state[6] = encodeInteger(writer, callColumn, state[6]);\n    }\n    if (bindings) for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);\n        encodeInteger(writer, expRange[0], 0);\n      }\n    }\n    for (index++; index < ranges.length;) {\n      const next = ranges[index];\n      const {\n        0: l,\n        1: c\n      } = next;\n      if (l > endLine || l === endLine && c >= endColumn) break;\n      index = _encodeGeneratedRanges(ranges, index, writer, state);\n    }\n    if (state[0] < endLine) {\n      catchupLine(writer, state[0], endLine);\n      state[0] = endLine;\n      state[1] = 0;\n    } else writer.write(comma);\n    state[1] = encodeInteger(writer, endColumn, state[1]);\n    return index;\n  }\n  function catchupLine(writer, lastLine, line) {\n    do writer.write(semicolon); while (++lastLine < line);\n  }\n  function decode(mappings) {\n    const {\n      \"length\": length\n    } = mappings;\n    const reader = new StringReader(mappings);\n    const decoded = [];\n    let genColumn = 0;\n    let sourcesIndex = 0;\n    let sourceLine = 0;\n    let sourceColumn = 0;\n    let namesIndex = 0;\n    do {\n      const semi = reader.indexOf(\";\");\n      const line = [];\n      let sorted = true;\n      let lastCol = 0;\n      genColumn = 0;\n      while (reader.pos < semi) {\n        let seg;\n        genColumn = decodeInteger(reader, genColumn);\n        if (genColumn < lastCol) sorted = false;\n        lastCol = genColumn;\n        if (hasMoreVlq(reader, semi)) {\n          sourcesIndex = decodeInteger(reader, sourcesIndex);\n          sourceLine = decodeInteger(reader, sourceLine);\n          sourceColumn = decodeInteger(reader, sourceColumn);\n          if (hasMoreVlq(reader, semi)) {\n            namesIndex = decodeInteger(reader, namesIndex);\n            seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n          } else seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        } else seg = [genColumn];\n        line.push(seg);\n        reader.pos++;\n      }\n      if (!sorted) sort(line);\n      decoded.push(line);\n      reader.pos = semi + 1;\n    } while (reader.pos <= length);\n    return decoded;\n  }\n  function sort(line) {\n    line.sort(sortComparator);\n  }\n  function sortComparator(a, b) {\n    return a[0] - b[0];\n  }\n  function encode(decoded) {\n    const writer = new StringWriter();\n    let sourcesIndex = 0;\n    let sourceLine = 0;\n    let sourceColumn = 0;\n    let namesIndex = 0;\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n      if (i > 0) writer.write(semicolon);\n      if (line.length === 0) continue;\n      let genColumn = 0;\n      for (let j = 0; j < line.length; j++) {\n        const segment = line[j];\n        if (j > 0) writer.write(comma);\n        genColumn = encodeInteger(writer, segment[0], genColumn);\n        if (segment.length === 1) continue;\n        sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n        sourceLine = encodeInteger(writer, segment[2], sourceLine);\n        sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n        if (segment.length === 4) continue;\n        namesIndex = encodeInteger(writer, segment[4], namesIndex);\n      }\n    }\n    return writer.flush();\n  }\n});",
    "javascript/esm|__WORKSPACE__/node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs": "(function () {\n  __webpack_require__.r(__webpack_exports__);\n  __webpack_require__.d(__webpack_exports__, {\n    \"AnyMap\": function () {\n      return AnyMap;\n    },\n    \"GREATEST_LOWER_BOUND\": function () {\n      return GREATEST_LOWER_BOUND;\n    },\n    \"LEAST_UPPER_BOUND\": function () {\n      return LEAST_UPPER_BOUND;\n    },\n    \"TraceMap\": function () {\n      return TraceMap;\n    },\n    \"allGeneratedPositionsFor\": function () {\n      return allGeneratedPositionsFor;\n    },\n    \"decodedMap\": function () {\n      return decodedMap;\n    },\n    \"decodedMappings\": function () {\n      return decodedMappings;\n    },\n    \"eachMapping\": function () {\n      return eachMapping;\n    },\n    \"encodedMap\": function () {\n      return encodedMap;\n    },\n    \"encodedMappings\": function () {\n      return encodedMappings;\n    },\n    \"generatedPositionFor\": function () {\n      return generatedPositionFor;\n    },\n    \"isIgnored\": function () {\n      return isIgnored;\n    },\n    \"originalPositionFor\": function () {\n      return originalPositionFor;\n    },\n    \"presortedDecodedMap\": function () {\n      return presortedDecodedMap;\n    },\n    \"sourceContentFor\": function () {\n      return sourceContentFor;\n    },\n    \"traceSegment\": function () {\n      return traceSegment;\n    }\n  });\n  var __WEBPACK_IMPORTED_MODULE_xxx__ = __webpack_require__(\"../../../../../../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\");\n  var __WEBPACK_IMPORTED_MODULE_xxx__ = __webpack_require__(\"../../../../../../node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs\");\n  function resolve(input, base) {\n    if (base && !base.endsWith(\"/\")) base += \"/\";\n    return (0, __WEBPACK_IMPORTED_MODULE_xxx__[\"default\"])(input, base);\n  }\n  function stripFilename(path) {\n    if (!path) return \"\";\n    const index = path.lastIndexOf(\"/\");\n    return path.slice(0, index + 1);\n  }\n  const COLUMN = 0;\n  const SOURCES_INDEX = 1;\n  const SOURCE_LINE = 2;\n  const SOURCE_COLUMN = 3;\n  const NAMES_INDEX = 4;\n  const REV_GENERATED_LINE = 1;\n  const REV_GENERATED_COLUMN = 2;\n  function maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length) return mappings;\n    if (!owned) mappings = mappings.slice();\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) mappings[i] = sortSegments(mappings[i], owned);\n    return mappings;\n  }\n  function nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) if (!isSorted(mappings[i])) return i;\n    return mappings.length;\n  }\n  function isSorted(line) {\n    for (let j = 1; j < line.length; j++) if (line[j][COLUMN] < line[j - 1][COLUMN]) return false;\n    return true;\n  }\n  function sortSegments(line, owned) {\n    if (!owned) line = line.slice();\n    return line.sort(sortComparator);\n  }\n  function sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n  }\n  let found = false;\n  function binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n      const mid = low + (high - low >> 1);\n      const cmp = haystack[mid][COLUMN] - needle;\n      if (cmp === 0) {\n        found = true;\n        return mid;\n      }\n      if (cmp < 0) low = mid + 1;else high = mid - 1;\n    }\n    found = false;\n    return low - 1;\n  }\n  function upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; index = i++) if (haystack[i][COLUMN] !== needle) break;\n    return index;\n  }\n  function lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; index = i--) if (haystack[i][COLUMN] !== needle) break;\n    return index;\n  }\n  function memoizedState() {\n    return {\n      \"lastIndex\": -1,\n      \"lastKey\": -1,\n      \"lastNeedle\": -1\n    };\n  }\n  function memoizedBinarySearch(haystack, needle, state, key) {\n    const {\n      \"lastKey\": lastKey,\n      \"lastNeedle\": lastNeedle,\n      \"lastIndex\": lastIndex\n    } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n    if (key === lastKey) {\n      if (needle === lastNeedle) {\n        found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n        return lastIndex;\n      }\n      if (needle >= lastNeedle) low = lastIndex === -1 ? 0 : lastIndex;else high = lastIndex;\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return state.lastIndex = binarySearch(haystack, needle, low, high);\n  }\n  function buildBySources(decoded, memos) {\n    const sources = memos.map(buildNullArray);\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        if (seg.length === 1) continue;\n        const sourceIndex = seg[SOURCES_INDEX];\n        const sourceLine = seg[SOURCE_LINE];\n        const sourceColumn = seg[SOURCE_COLUMN];\n        const originalSource = sources[sourceIndex];\n        const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);\n        const memo = memos[sourceIndex];\n        let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n        memo.lastIndex = ++index;\n        insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\n      }\n    }\n    return sources;\n  }\n  function insert(array, index, value) {\n    for (let i = array.length; i > index; i--) array[i] = array[i - 1];\n    array[index] = value;\n  }\n  function buildNullArray() {\n    return {\n      \"__proto__\": null\n    };\n  }\n  const AnyMap = function (map, mapUrl) {\n    const parsed = parse(map);\n    if (!(\"sections\" in parsed)) return new TraceMap(parsed, mapUrl);\n    const mappings = [];\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    const ignoreList = [];\n    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);\n    const joined = {\n      \"file\": parsed.file,\n      \"ignoreList\": ignoreList,\n      \"mappings\": mappings,\n      \"names\": names,\n      \"sources\": sources,\n      \"sourcesContent\": sourcesContent,\n      \"version\": 3\n    };\n    return presortedDecodedMap(joined);\n  };\n  function parse(map) {\n    return typeof map === \"string\" ? JSON.parse(map) : map;\n  }\n  function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n    const {\n      \"sections\": sections\n    } = input;\n    for (let i = 0; i < sections.length; i++) {\n      const {\n        \"map\": map,\n        \"offset\": offset\n      } = sections[i];\n      let sl = stopLine;\n      let sc = stopColumn;\n      if (i + 1 < sections.length) {\n        const nextOffset = sections[i + 1].offset;\n        sl = Math.min(stopLine, lineOffset + nextOffset.line);\n        if (sl === stopLine) sc = Math.min(stopColumn, columnOffset + nextOffset.column);else if (sl < stopLine) sc = columnOffset + nextOffset.column;\n      }\n      addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n    }\n  }\n  function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n    const parsed = parse(input);\n    if (\"sections\" in parsed) return recurse(...arguments);\n    const map = new TraceMap(parsed, mapUrl);\n    const sourcesOffset = sources.length;\n    const namesOffset = names.length;\n    const decoded = decodedMappings(map);\n    const {\n      \"resolvedSources\": resolvedSources,\n      \"sourcesContent\": contents,\n      \"ignoreList\": ignores\n    } = map;\n    append(sources, resolvedSources);\n    append(names, map.names);\n    if (contents) append(sourcesContent, contents);else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n    if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\n    for (let i = 0; i < decoded.length; i++) {\n      const lineI = lineOffset + i;\n      if (lineI > stopLine) return;\n      const out = getLine(mappings, lineI);\n      const cOffset = i === 0 ? columnOffset : 0;\n      const line = decoded[i];\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        const column = cOffset + seg[COLUMN];\n        if (lineI === stopLine && column >= stopColumn) return;\n        if (seg.length === 1) {\n          out.push([column]);\n          continue;\n        }\n        const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n        const sourceLine = seg[SOURCE_LINE];\n        const sourceColumn = seg[SOURCE_COLUMN];\n        out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n      }\n    }\n  }\n  function append(arr, other) {\n    for (let i = 0; i < other.length; i++) arr.push(other[i]);\n  }\n  function getLine(arr, index) {\n    for (let i = arr.length; i <= index; i++) arr[i] = [];\n    return arr[index];\n  }\n  const LINE_GTR_ZERO = \"`line` must be greater than 0 (lines start at line 1)\";\n  const COL_GTR_EQ_ZERO = \"`column` must be greater than or equal to 0 (columns start at column 0)\";\n  const LEAST_UPPER_BOUND = -1;\n  const GREATEST_LOWER_BOUND = 1;\n  class TraceMap {\n    constructor(map, mapUrl) {\n      const isString = typeof map === \"string\";\n      if (!isString && map._decodedMemo) return map;\n      const parsed = isString ? JSON.parse(map) : map;\n      const {\n        \"version\": version,\n        \"file\": file,\n        \"names\": names,\n        \"sourceRoot\": sourceRoot,\n        \"sources\": sources,\n        \"sourcesContent\": sourcesContent\n      } = parsed;\n      this.version = version;\n      this.file = file;\n      this.names = names || [];\n      this.sourceRoot = sourceRoot;\n      this.sources = sources;\n      this.sourcesContent = sourcesContent;\n      this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;\n      const from = resolve(sourceRoot || \"\", stripFilename(mapUrl));\n      this.resolvedSources = sources.map(s => resolve(s || \"\", from));\n      const {\n        \"mappings\": mappings\n      } = parsed;\n      if (typeof mappings === \"string\") {\n        this._encoded = mappings;\n        this._decoded = undefined;\n      } else {\n        this._encoded = undefined;\n        this._decoded = maybeSort(mappings, isString);\n      }\n      this._decodedMemo = memoizedState();\n      this._bySources = undefined;\n      this._bySourceMemos = undefined;\n    }\n  }\n  function cast(map) {\n    return map;\n  }\n  function encodedMappings(map) {\n    var _a;\n    var _b;\n    return (_a = (_b = cast(map))._encoded) !== null && _a !== void 0 ? _a : _b._encoded = (0, __WEBPACK_IMPORTED_MODULE_xxx__.encode)(cast(map)._decoded);\n  }\n  function decodedMappings(map) {\n    var _a;\n    return (_a = cast(map))._decoded || (_a._decoded = (0, __WEBPACK_IMPORTED_MODULE_xxx__.decode)(cast(map)._encoded));\n  }\n  function traceSegment(map, line, column) {\n    const decoded = decodedMappings(map);\n    if (line >= decoded.length) return null;\n    const segments = decoded[line];\n    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n    return index === -1 ? null : segments[index];\n  }\n  function originalPositionFor(map, needle) {\n    let {\n      \"line\": line,\n      \"column\": column,\n      \"bias\": bias\n    } = needle;\n    line--;\n    if (line < 0) throw new Error(LINE_GTR_ZERO);\n    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n    const decoded = decodedMappings(map);\n    if (line >= decoded.length) return OMapping(null, null, null, null);\n    const segments = decoded[line];\n    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n    if (index === -1) return OMapping(null, null, null, null);\n    const segment = segments[index];\n    if (segment.length === 1) return OMapping(null, null, null, null);\n    const {\n      \"names\": names,\n      \"resolvedSources\": resolvedSources\n    } = map;\n    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n  }\n  function generatedPositionFor(map, needle) {\n    const {\n      \"source\": source,\n      \"line\": line,\n      \"column\": column,\n      \"bias\": bias\n    } = needle;\n    return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n  }\n  function allGeneratedPositionsFor(map, needle) {\n    const {\n      \"source\": source,\n      \"line\": line,\n      \"column\": column,\n      \"bias\": bias\n    } = needle;\n    return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n  }\n  function eachMapping(map, cb) {\n    const decoded = decodedMappings(map);\n    const {\n      \"names\": names,\n      \"resolvedSources\": resolvedSources\n    } = map;\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        const generatedLine = i + 1;\n        const generatedColumn = seg[0];\n        let source = null;\n        let originalLine = null;\n        let originalColumn = null;\n        let name = null;\n        if (seg.length !== 1) {\n          source = resolvedSources[seg[1]];\n          originalLine = seg[2] + 1;\n          originalColumn = seg[3];\n        }\n        if (seg.length === 5) name = names[seg[4]];\n        cb({\n          \"generatedColumn\": generatedColumn,\n          \"generatedLine\": generatedLine,\n          \"name\": name,\n          \"originalColumn\": originalColumn,\n          \"originalLine\": originalLine,\n          \"source\": source\n        });\n      }\n    }\n  }\n  function sourceIndex(map, source) {\n    const {\n      \"sources\": sources,\n      \"resolvedSources\": resolvedSources\n    } = map;\n    let index = sources.indexOf(source);\n    if (index === -1) index = resolvedSources.indexOf(source);\n    return index;\n  }\n  function sourceContentFor(map, source) {\n    const {\n      \"sourcesContent\": sourcesContent\n    } = map;\n    if (sourcesContent == null) return null;\n    const index = sourceIndex(map, source);\n    return index === -1 ? null : sourcesContent[index];\n  }\n  function isIgnored(map, source) {\n    const {\n      \"ignoreList\": ignoreList\n    } = map;\n    if (ignoreList == null) return false;\n    const index = sourceIndex(map, source);\n    return index === -1 ? false : ignoreList.includes(index);\n  }\n  function presortedDecodedMap(map, mapUrl) {\n    const tracer = new TraceMap(clone(map, []), mapUrl);\n    cast(tracer)._decoded = map.mappings;\n    return tracer;\n  }\n  function decodedMap(map) {\n    return clone(map, decodedMappings(map));\n  }\n  function encodedMap(map) {\n    return clone(map, encodedMappings(map));\n  }\n  function clone(map, mappings) {\n    return {\n      \"file\": map.file,\n      \"ignoreList\": map.ignoreList || map.x_google_ignoreList,\n      \"mappings\": mappings,\n      \"names\": map.names,\n      \"sourceRoot\": map.sourceRoot,\n      \"sources\": map.sources,\n      \"sourcesContent\": map.sourcesContent,\n      \"version\": map.version\n    };\n  }\n  function OMapping(source, line, column, name) {\n    return {\n      \"column\": column,\n      \"line\": line,\n      \"name\": name,\n      \"source\": source\n    };\n  }\n  function GMapping(line, column) {\n    return {\n      \"column\": column,\n      \"line\": line\n    };\n  }\n  function traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);else if (bias === LEAST_UPPER_BOUND) index++;\n    if (index === -1 || index === segments.length) return -1;\n    return index;\n  }\n  function sliceGeneratedPositions(segments, memo, line, column, bias) {\n    let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n    if (!found && bias === LEAST_UPPER_BOUND) min++;\n    if (min === -1 || min === segments.length) return [];\n    const matchedColumn = found ? column : segments[min][COLUMN];\n    if (!found) min = lowerBound(segments, matchedColumn, min);\n    const max = upperBound(segments, matchedColumn, min);\n    const result = [];\n    for (; min <= max; min++) {\n      const segment = segments[min];\n      result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n    }\n    return result;\n  }\n  function generatedPosition(map, source, line, column, bias, all) {\n    var _a;\n    line--;\n    if (line < 0) throw new Error(LINE_GTR_ZERO);\n    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n    const {\n      \"sources\": sources,\n      \"resolvedSources\": resolvedSources\n    } = map;\n    let sourceIndex = sources.indexOf(source);\n    if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n    if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n    const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));\n    const segments = generated[sourceIndex][line];\n    if (segments == null) return all ? [] : GMapping(null, null);\n    const memo = cast(map)._bySourceMemos[sourceIndex];\n    if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n    const index = traceSegmentInternal(segments, memo, line, column, bias);\n    if (index === -1) return GMapping(null, null);\n    const segment = segments[index];\n    return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n  }\n});",
    "__WORKSPACE__/packages/rspack-test-tools/tests/runtimeDiffCases/runtime-module/startup-chunk-dependencies/src/index.js": "(function () {\n  __webpack_require__.r(__webpack_exports__);\n  var __WEBPACK_IMPORTED_MODULE_xxx__ = __webpack_require__(\"./src/shared.js\");\n  __webpack_exports__[\"default\"] = \"index.js\";\n});",
    "__WORKSPACE__/packages/rspack-test-tools/tests/runtimeDiffCases/runtime-module/startup-chunk-dependencies/src/shared.js": "(function () {\n  __webpack_require__.r(__webpack_exports__);\n  var __WEBPACK_IMPORTED_MODULE_xxx__ = __webpack_require__(\"../../../../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js\");\n  var __WEBPACK_IMPORTED_MODULE_xxx__ = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_xxx__);\n  var __WEBPACK_IMPORTED_MODULE_xxx__ = __webpack_require__(\"../../../../../../node_modules/.pnpm/acorn@8.14.0/node_modules/acorn/dist/acorn.mjs\");\n  var __WEBPACK_IMPORTED_MODULE_xxx__ = __webpack_require__(\"../../../../../../node_modules/.pnpm/terser@5.39.0/node_modules/terser/main.js\");\n  console.log(__WEBPACK_IMPORTED_MODULE_xxx__().VERSION);\n  console.log(__WEBPACK_IMPORTED_MODULE_xxx__[\"default\"]);\n  console.log(__WEBPACK_IMPORTED_MODULE_xxx__[\"default\"]);\n});"
  },
  "runtimeModules": {
    "webpack/runtime/bootstrap": "var __webpack_module_cache__ = {};\nfunction __webpack_require__(moduleId) {\n  var cachedModule = __webpack_module_cache__[moduleId];\n  if (cachedModule !== undefined) return cachedModule.exports;\n  var module = __webpack_module_cache__[moduleId] = {\n    \"exports\": {},\n    \"id\": moduleId,\n    \"loaded\": false\n  };\n  __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n  module.loaded = true;\n  return module.exports;\n}\n__webpack_require__.m = __webpack_modules__;\n__webpack_require__.x = function () {\n  var __webpack_exports__ = __webpack_require__.O(undefined, [\"lodash\", \"terser\", \"acorn\"], function () {\n    return __webpack_require__(\"./src/index.js\");\n  });\n  __webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n  return __webpack_exports__;\n};",
    "webpack/runtime/chunk loaded": "!function () {\n  var deferred = [];\n  __webpack_require__.O = function (result, chunkIds, fn, priority) {\n    if (chunkIds) {\n      priority = priority || 0;\n      for (var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n      deferred[i] = [chunkIds, fn, priority];\n      return;\n    }\n    var notFulfilled = Infinity;\n    for (var i = 0; i < deferred.length; i++) {\n      var chunkIds = deferred[i][0];\n      var fn = deferred[i][1];\n      var priority = deferred[i][2];\n      var fulfilled = true;\n      for (var j = 0; j < chunkIds.length; j++) if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function (key) {\n        return __webpack_require__.O[key](chunkIds[j]);\n      })) chunkIds.splice(j--, 1);else {\n        fulfilled = false;\n        if (priority < notFulfilled) notFulfilled = priority;\n      }\n      if (fulfilled) {\n        deferred.splice(i--, 1);\n        var r = fn();\n        if (r !== undefined) result = r;\n      }\n    }\n    return result;\n  };\n}();",
    "webpack/runtime/compat get default export": "!function () {\n  __webpack_require__.n = function (module) {\n    var getter = module && module.__esModule ? function () {\n      return module[\"default\"];\n    } : function () {\n      return module;\n    };\n    __webpack_require__.d(getter, {\n      \"a\": getter\n    });\n    return getter;\n  };\n}();",
    "webpack/runtime/define property getters": "!function () {\n  __webpack_require__.d = function (exports, definition) {\n    for (var key in definition) if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {\n      \"enumerable\": true,\n      \"get\": definition[key]\n    });\n  };\n}();",
    "webpack/runtime/ensure chunk": "!function () {\n  __webpack_require__.f = {};\n  __webpack_require__.e = function (chunkId) {\n    return Promise.all(Object.keys(__webpack_require__.f).reduce(function (promises, key) {\n      __webpack_require__.f[key](chunkId, promises);\n      return promises;\n    }, []));\n  };\n}();",
    "webpack/runtime/get javascript chunk filename": "!function () {\n  __webpack_require__.u = function (chunkId) {\n    return \"\" + chunkId + \".js\";\n  };\n}();",
    "webpack/runtime/hasOwnProperty shorthand": "!function () {\n  __webpack_require__.o = function (obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  };\n}();",
    "webpack/runtime/make namespace object": "!function () {\n  __webpack_require__.r = function (exports) {\n    if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) Object.defineProperty(exports, Symbol.toStringTag, {\n      \"value\": \"Module\"\n    });\n    Object.defineProperty(exports, \"__esModule\", {\n      \"value\": true\n    });\n  };\n}();",
    "webpack/runtime/node module decorator": "!function () {\n  __webpack_require__.nmd = function (module) {\n    module.paths = [];\n    if (!module.children) module.children = [];\n    return module;\n  };\n}();",
    "webpack/runtime/require chunk loading": "!function () {\n  var installedChunks = {\n    \"bundle\": 1\n  };\n  __webpack_require__.O.require = function (chunkId) {\n    return installedChunks[chunkId];\n  };\n  var installChunk = function (chunk) {\n    var moreModules = chunk.modules,\n      chunkIds = chunk.ids,\n      runtime = chunk.runtime;\n    for (var moduleId in moreModules) if (__webpack_require__.o(moreModules, moduleId)) __webpack_require__.m[moduleId] = moreModules[moduleId];\n    if (runtime) runtime(__webpack_require__);\n    for (var i = 0; i < chunkIds.length; i++) installedChunks[chunkIds[i]] = 1;\n    __webpack_require__.O();\n  };\n  __webpack_require__.f.require = function (chunkId, promises) {\n    if (!installedChunks[chunkId]) installChunk(require(\"./\" + __webpack_require__.u(chunkId)));\n  };\n}();",
    "webpack/runtime/startup chunk dependencies": "!function () {\n  var next = __webpack_require__.x;\n  __webpack_require__.x = function () {\n    __webpack_require__.e(\"lodash\");\n    __webpack_require__.e(\"terser\");\n    __webpack_require__.e(\"acorn\");\n    return next();\n  };\n}();"
  }
}