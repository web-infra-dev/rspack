{
  "modules": {
    "__WORKSPACE__/packages/rspack-test-tools/tests/runtimeDiffCases/runtime-module/prefetch/src/index.js": "(function () {\n  __webpack_require__.nc = \"nonce\";\n  __webpack_require__.p = \"https://example.com/public/path/\";\n  __webpack_require__.e(\"chunk1\").then(__webpack_require__.bind(__webpack_require__, \"./src/chunk1.js\"));\n  __webpack_require__.e(\"chunk2\").then(__webpack_require__.bind(__webpack_require__, \"./src/chunk2.js\"));\n});"
  },
  "runtimeModules": {
    "webpack/runtime/bootstrap": "var __webpack_module_cache__ = {};\nfunction __webpack_require__(moduleId) {\n  var cachedModule = __webpack_module_cache__[moduleId];\n  if (cachedModule !== undefined) return cachedModule.exports;\n  var module = __webpack_module_cache__[moduleId] = {\n    \"exports\": {}\n  };\n  __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n  return module.exports;\n}\n__webpack_require__.m = __webpack_modules__;",
    "webpack/runtime/chunk loaded": "!function () {\n  var deferred = [];\n  __webpack_require__.O = function (result, chunkIds, fn, priority) {\n    if (chunkIds) {\n      priority = priority || 0;\n      for (var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n      deferred[i] = [chunkIds, fn, priority];\n      return;\n    }\n    var notFulfilled = Infinity;\n    for (var i = 0; i < deferred.length; i++) {\n      var chunkIds = deferred[i][0];\n      var fn = deferred[i][1];\n      var priority = deferred[i][2];\n      var fulfilled = true;\n      for (var j = 0; j < chunkIds.length; j++) if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function (key) {\n        return __webpack_require__.O[key](chunkIds[j]);\n      })) chunkIds.splice(j--, 1);else {\n        fulfilled = false;\n        if (priority < notFulfilled) notFulfilled = priority;\n      }\n      if (fulfilled) {\n        deferred.splice(i--, 1);\n        var r = fn();\n        if (r !== undefined) result = r;\n      }\n    }\n    return result;\n  };\n}();",
    "webpack/runtime/chunk prefetch function": "!function () {\n  __webpack_require__.F = {};\n  __webpack_require__.E = function (chunkId) {\n    Object.keys(__webpack_require__.F).map(function (key) {\n      __webpack_require__.F[key](chunkId);\n    });\n  };\n}();",
    "webpack/runtime/create fake namespace object": "!function () {\n  var getProto = Object.getPrototypeOf ? function (obj) {\n    return Object.getPrototypeOf(obj);\n  } : function (obj) {\n    return obj.__proto__;\n  };\n  var leafPrototypes;\n  __webpack_require__.t = function (value, mode) {\n    if (mode & 1) value = this(value);\n    if (mode & 8) return value;\n    if (typeof value === \"object\" && value) {\n      if (mode & 4 && value.__esModule) return value;\n      if (mode & 16 && typeof value.then === \"function\") return value;\n    }\n    var ns = Object.create(null);\n    __webpack_require__.r(ns);\n    var def = {};\n    leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n    for (var current = mode & 2 && value; typeof current == \"object\" && !~leafPrototypes.indexOf(current); current = getProto(current)) Object.getOwnPropertyNames(current).forEach(function (key) {\n      def[key] = function () {\n        return value[key];\n      };\n    });\n    def[\"default\"] = function () {\n      return value;\n    };\n    __webpack_require__.d(ns, def);\n    return ns;\n  };\n}();",
    "webpack/runtime/define property getters": "!function () {\n  __webpack_require__.d = function (exports, definition) {\n    for (var key in definition) if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {\n      \"enumerable\": true,\n      \"get\": definition[key]\n    });\n  };\n}();",
    "webpack/runtime/ensure chunk": "!function () {\n  __webpack_require__.f = {};\n  __webpack_require__.e = function (chunkId) {\n    return Promise.all(Object.keys(__webpack_require__.f).reduce(function (promises, key) {\n      __webpack_require__.f[key](chunkId, promises);\n      return promises;\n    }, []));\n  };\n}();",
    "webpack/runtime/get javascript chunk filename": "!function () {\n  __webpack_require__.u = function (chunkId) {\n    return \"\" + chunkId + \".js\";\n  };\n}();",
    "webpack/runtime/global": "!function () {\n  __webpack_require__.g = function () {\n    if (typeof globalThis === \"object\") return globalThis;\n    try {\n      return this || new Function(\"return this\")();\n    } catch (e) {\n      if (typeof window === \"object\") return window;\n    }\n  }();\n}();",
    "webpack/runtime/hasOwnProperty shorthand": "!function () {\n  __webpack_require__.o = function (obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  };\n}();",
    "webpack/runtime/load script": "!function () {\n  var inProgress = {};\n  __webpack_require__.l = function (url, done, key, chunkId) {\n    if (inProgress[url]) {\n      inProgress[url].push(done);\n      return;\n    }\n    var script, needAttach;\n    if (key !== undefined) {\n      var scripts = document.getElementsByTagName(\"script\");\n      for (var i = 0; i < scripts.length; i++) {\n        var s = scripts[i];\n        if (s.getAttribute(\"src\") == url) {\n          script = s;\n          break;\n        }\n      }\n    }\n    if (!script) {\n      needAttach = true;\n      script = document.createElement(\"script\");\n      script.charset = \"utf-8\";\n      script.timeout = 120;\n      if (__webpack_require__.nc) script.setAttribute(\"nonce\", __webpack_require__.nc);\n      script.src = url;\n      if (script.src.indexOf(window.location.origin + \"/\") !== 0) script.crossOrigin = \"anonymous\";\n    }\n    inProgress[url] = [done];\n    var onScriptComplete = function (prev, event) {\n      script.onerror = script.onload = null;\n      clearTimeout(timeout);\n      var doneFns = inProgress[url];\n      delete inProgress[url];\n      script.parentNode && script.parentNode.removeChild(script);\n      doneFns && doneFns.forEach(function (fn) {\n        return fn(event);\n      });\n      if (prev) return prev(event);\n    };\n    var timeout = setTimeout(onScriptComplete.bind(null, undefined, {\n      \"target\": script,\n      \"type\": \"timeout\"\n    }), 120000);\n    script.onerror = onScriptComplete.bind(null, script.onerror);\n    script.onload = onScriptComplete.bind(null, script.onload);\n    needAttach && document.head.appendChild(script);\n  };\n}();",
    "webpack/runtime/make namespace object": "!function () {\n  __webpack_require__.r = function (exports) {\n    if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) Object.defineProperty(exports, Symbol.toStringTag, {\n      \"value\": \"Module\"\n    });\n    Object.defineProperty(exports, \"__esModule\", {\n      \"value\": true\n    });\n  };\n}();",
    "webpack/runtime/publicPath": "!function () {\n  var scriptUrl;\n  if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\n  var document = __webpack_require__.g.document;\n  if (!scriptUrl && document) {\n    if (document.currentScript && document.currentScript.tagName.toUpperCase() === \"SCRIPT\") scriptUrl = document.currentScript.src;\n    if (!scriptUrl) {\n      var scripts = document.getElementsByTagName(\"script\");\n      if (scripts.length) {\n        var i = scripts.length - 1;\n        while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n      }\n    }\n  }\n  if (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\n  scriptUrl = scriptUrl.replace(/^blob:/, \"\").replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n  __webpack_require__.p = scriptUrl;\n}();",
    "webpack/runtime/jsonp chunk loading": "!function () {\n  var installedChunks = {\n    \"main\": 0\n  };\n  __webpack_require__.f.j = function (chunkId, promises) {\n    var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n    if (installedChunkData !== 0) if (installedChunkData) promises.push(installedChunkData[2]);else {\n      var promise = new Promise(function (resolve, reject) {\n        installedChunkData = installedChunks[chunkId] = [resolve, reject];\n      });\n      promises.push(installedChunkData[2] = promise);\n      var url = __webpack_require__.p + __webpack_require__.u(chunkId);\n      var error = new Error();\n      var loadingEnded = function (event) {\n        if (__webpack_require__.o(installedChunks, chunkId)) {\n          installedChunkData = installedChunks[chunkId];\n          if (installedChunkData !== 0) installedChunks[chunkId] = undefined;\n          if (installedChunkData) {\n            var errorType = event && (event.type === \"load\" ? \"missing\" : event.type);\n            var realSrc = event && event.target && event.target.src;\n            error.message = \"Loading chunk \" + chunkId + \" failed.\\n(\" + errorType + \": \" + realSrc + \")\";\n            error.name = \"ChunkLoadError\";\n            error.type = errorType;\n            error.request = realSrc;\n            installedChunkData[1](error);\n          }\n        }\n      };\n      __webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n    }\n  };\n  __webpack_require__.F.j = function (chunkId) {\n    if ((!__webpack_require__.o(installedChunks, chunkId) || installedChunks[chunkId] === undefined) && true) {\n      installedChunks[chunkId] = null;\n      var link = document.createElement(\"link\");\n      link.charset = \"utf-8\";\n      link.crossOrigin = \"anonymous\";\n      if (__webpack_require__.nc) link.setAttribute(\"nonce\", __webpack_require__.nc);\n      link.rel = \"prefetch\";\n      link.as = \"script\";\n      link.href = __webpack_require__.p + __webpack_require__.u(chunkId);\n      document.head.appendChild(link);\n    }\n  };\n  __webpack_require__.O.j = function (chunkId) {\n    return installedChunks[chunkId] === 0;\n  };\n  var webpackJsonpCallback = function (parentChunkLoadingFunction, data) {\n    var chunkIds = data[0];\n    var moreModules = data[1];\n    var runtime = data[2];\n    var moduleId,\n      chunkId,\n      i = 0;\n    if (chunkIds.some(function (id) {\n      return installedChunks[id] !== 0;\n    })) {\n      for (moduleId in moreModules) if (__webpack_require__.o(moreModules, moduleId)) __webpack_require__.m[moduleId] = moreModules[moduleId];\n      if (runtime) var result = runtime(__webpack_require__);\n    }\n    if (parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n    for (; i < chunkIds.length; i++) {\n      chunkId = chunkIds[i];\n      if (__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) installedChunks[chunkId][0]();\n      installedChunks[chunkId] = 0;\n    }\n    return __webpack_require__.O(result);\n  };\n  var chunkLoadingGlobal = self[\"webpackChunk\"] = self[\"webpackChunk\"] || [];\n  chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\n  chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));\n}();",
    "webpack/runtime/nonce": "!function () {\n  __webpack_require__.nc = undefined;\n}();",
    "webpack/runtime/chunk prefetch trigger": "!function () {\n  var chunkToChildrenMap = {\n    \"chunk1\": [\"chunk1-b\", \"chunk1-a\"],\n    \"chunk2\": [\"chunk1-a\"]\n  };\n  __webpack_require__.f.prefetch = function (chunkId, promises) {\n    Promise.all(promises).then(function () {\n      var chunks = chunkToChildrenMap[chunkId];\n      Array.isArray(chunks) && chunks.map(__webpack_require__.E);\n    });\n  };\n}();",
    "webpack/runtime/startup prefetch": "!function () {\n  __webpack_require__.O(0, [\"main\"], function () {\n    __webpack_require__.E(\"chunk1\");\n  }, 5);\n}();"
  }
}