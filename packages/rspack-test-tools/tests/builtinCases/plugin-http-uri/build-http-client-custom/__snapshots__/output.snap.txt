```js title=main.js
(self["webpackChunkwebpack"] = self["webpackChunkwebpack"] || []).push([["main"], {
"./custom-http-client.js": (function (module) {
// Track requests for testing
let requests = [];

/**
 * Custom HTTP client implementation that logs all requests
 * and returns mock responses for testing
 */
module.exports = function customHttpClient(url, headers) {
  // Track this request
  requests.push({ url, headers });

  // Simple mock server implementation
  if (url.startsWith("http://localhost") || url.startsWith("https://localhost")) {
    let content;

    // Mock responses based on URL
    if (url.endsWith("/module.js") || url === "http://localhost/") {
      content = 'export default "Module from custom HTTP client";';
    } else if (url.includes("/dependency.js")) {
      content = 'export default "Dependency module";';
    } else {
      // 404 for unknown paths
      return Promise.resolve({
        status: 404,
        headers: {},
        body: Buffer.from(`Not found: ${url}`)
      });
    }

    // Return a successful response
    return Promise.resolve({
      status: 200,
      headers: {
        "content-type": "application/javascript",
        "x-custom-header": "custom-value",
        "cache-control": "max-age=3600"
      },
      body: Buffer.from(content)
    });
  }

  // For real URLs, return a promise that would use the JS-provided fetch API
  return Promise.resolve().then(() => {
    // This part would normally use the provided fetch implementation
    // but we're returning a mock for the test
    return {
      status: 200,
      headers: {
        "content-type": "application/javascript"
      },
      body: Buffer.from('export default "Fetched module";')
    };
  });
};

// Expose for testing
module.exports.getRequests = function() {
  return requests;
};

module.exports.clearRequests = function() {
  requests = [];
};


}),
"./index.js": (function (module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.a(module, async function (__webpack_handle_async_dependencies__, __webpack_async_result__) { try {
__webpack_require__.r(__webpack_exports__);
/* ESM import */var http_localhost_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("http://localhost/module.js");
/* ESM import */var _custom_http_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./custom-http-client.js");
/* ESM import */var _custom_http_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_custom_http_client__WEBPACK_IMPORTED_MODULE_1__);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([http_localhost_module_js__WEBPACK_IMPORTED_MODULE_0__]);
http_localhost_module_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


it("should load a module using the custom HTTP client", () => {
  expect(http_localhost_module_js__WEBPACK_IMPORTED_MODULE_0__["default"]).toBe("Module from custom HTTP client");
});

it("should track requests made by the custom HTTP client", () => {
  const requests = _custom_http_client__WEBPACK_IMPORTED_MODULE_1___default().getRequests();

  // At least one request should have been made
  expect(requests.length).toBeGreaterThan(0);

  // The request should be for our module
  expect(requests.some(req => req.url === "http://localhost/module.js")).toBe(true);

  // Check that headers were passed to the client
  const moduleRequest = requests.find(req => req.url === "http://localhost/module.js");
  expect(moduleRequest).toBeDefined();
  expect(moduleRequest.headers).toBeDefined();
});

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

}),
"http://localhost/module.js": (function (module) {
"use strict";
module.exports = import("http://localhost/module.js");

}),

},function(__webpack_require__) {
var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId) }
var __webpack_exports__ = (__webpack_exec__("./index.js"));

}
]);
```