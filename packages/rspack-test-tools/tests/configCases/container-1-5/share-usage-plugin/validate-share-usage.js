const fs = require("fs");
const path = require("path");

/**
 * Validates the ShareUsagePlugin output with proper test assertions
 * @param {string} outputPath - Path to the build output directory
 */
module.exports = function validateShareUsage(outputPath) {
	// Check if share-usage.json was generated
	const shareUsageFile = path.join(outputPath, "share-usage.json");
	
	// Assert file exists
	if (!fs.existsSync(shareUsageFile)) {
		throw new Error("FAIL: share-usage.json file was not generated by ShareUsagePlugin");
	}
	
	// Read and parse the JSON
	let shareUsageData;
	try {
		const content = fs.readFileSync(shareUsageFile, "utf8");
		shareUsageData = JSON.parse(content);
	} catch (error) {
		throw new Error(`Failed to parse share-usage.json: ${error.message}`);
	}
	
	// Assert JSON structure
	if (typeof shareUsageData !== "object" || shareUsageData === null) {
		throw new Error("share-usage.json should be an object");
	}
	
	const modules = shareUsageData;
	
	// Assert we have the expected shared modules
	const expectedModules = ["lodash-es", "react", "local-cjs-module", "local-esm-module"];
	const actualModules = Object.keys(modules);
	
	for (const expectedModule of expectedModules) {
		if (!actualModules.includes(expectedModule)) {
			throw new Error(`Expected module '${expectedModule}' not found in share-usage.json`);
		}
	}
	
	// Validate and assert lodash-es usage
	assertLodashUsage(modules["lodash-es"]);
	
	// Validate and assert React usage
	assertReactUsage(modules["react"]);
	
	// Validate and assert local CJS module usage
	assertLocalCjsUsage(modules["local-cjs-module"]);
	
	// Validate and assert local ESM module usage
	assertLocalEsmUsage(modules["local-esm-module"]);
	
	// Verify macro syntax compatibility
	assertMacroSyntaxCompatibility(modules);
	
	// Create snapshot for comparison
	const snapshotPath = path.join(__dirname, "__file_snapshots__");
	if (!fs.existsSync(snapshotPath)) {
		fs.mkdirSync(snapshotPath, { recursive: true });
	}
	
	const snapshotFile = path.join(snapshotPath, "share-usage.json");
	fs.writeFileSync(snapshotFile, JSON.stringify(shareUsageData, null, 2));
	
	return true;
};

/**
 * Assert lodash-es module usage is correctly tracked
 */
function assertLodashUsage(lodashData) {
	assertModuleStructure(lodashData, "lodash-es");
	
	const expectedUsed = ["map", "filter", "isEmpty", "isArray", "isObject", "clone", "merge", "reduce"];
	const expectedUnused = ["uniq", "debounce", "groupBy", "partition", "cloneDeep", "mergeWith", "sortBy"];
	const usage = lodashData.chunk_characteristics.usage;
	
	// Assert all expected used exports are marked as used (true)
	for (const exp of expectedUsed) {
		if (!usage.hasOwnProperty(exp) || usage[exp] !== true) {
			throw new Error(`lodash-es: Expected '${exp}' to be marked as used (true) in usage object`);
		}
	}
	
	// Assert all expected unused exports are marked as unused (false)
	for (const exp of expectedUnused) {
		if (!usage.hasOwnProperty(exp) || usage[exp] !== false) {
			throw new Error(`lodash-es: Expected '${exp}' to be marked as unused (false) in usage object`);
		}
	}
}

/**
 * Assert React module usage is correctly tracked
 */
function assertReactUsage(reactData) {
	assertModuleStructure(reactData, "react");
	
	const expectedUsed = ["createElement", "default"];
	const expectedUnused = ["useState", "useEffect"];
	const usage = reactData.chunk_characteristics.usage;
	
	// Assert used exports are marked as true
	for (const exp of expectedUsed) {
		if (!usage.hasOwnProperty(exp) || usage[exp] !== true) {
			throw new Error(`react: Expected '${exp}' to be marked as used (true) in usage object`);
		}
	}
	
	// Assert unused exports are marked as false
	for (const exp of expectedUnused) {
		if (!usage.hasOwnProperty(exp) || usage[exp] !== false) {
			throw new Error(`react: Expected '${exp}' to be marked as unused (false) in usage object`);
		}
	}
}

/**
 * Assert local CJS module usage is correctly tracked
 */
function assertLocalCjsUsage(localCjsData) {
	assertModuleStructure(localCjsData, "local-cjs-module");
	
	const expectedUsed = ["usedLocalFunction", "constantValue", "nestedObject"];
	const expectedUnused = ["unusedLocalFunction", "unusedConstant", "directProperty"];
	const usage = localCjsData.chunk_characteristics.usage;
	
	// Assert used exports are marked as true
	for (const exp of expectedUsed) {
		if (!usage.hasOwnProperty(exp) || usage[exp] !== true) {
			throw new Error(`local-cjs-module: Expected '${exp}' to be marked as used (true) in usage object`);
		}
	}
	
	// Assert unused exports are marked as false
	for (const exp of expectedUnused) {
		if (!usage.hasOwnProperty(exp) || usage[exp] !== false) {
			throw new Error(`local-cjs-module: Expected '${exp}' to be marked as unused (false) in usage object`);
		}
	}
}

/**
 * Assert local ESM module usage is correctly tracked
 */
function assertLocalEsmUsage(localEsmData) {
	assertModuleStructure(localEsmData, "local-esm-module");
	
	const expectedUsed = ["usedLocalUtil", "USED_LOCAL_CONSTANT", "default"];
	const expectedUnused = ["unusedLocalUtil", "UNUSED_LOCAL_CONSTANT"];
	const usage = localEsmData.chunk_characteristics.usage;
	
	// Assert used exports are marked as true
	for (const exp of expectedUsed) {
		if (!usage.hasOwnProperty(exp) || usage[exp] !== true) {
			throw new Error(`local-esm-module: Expected '${exp}' to be marked as used (true) in usage object`);
		}
	}
	
	// Assert unused exports are marked as false
	for (const exp of expectedUnused) {
		if (!usage.hasOwnProperty(exp) || usage[exp] !== false) {
			throw new Error(`local-esm-module: Expected '${exp}' to be marked as unused (false) in usage object`);
		}
	}
}

/**
 * Assert module has correct structure
 */
function assertModuleStructure(moduleData, moduleName) {
	if (!moduleData) {
		throw new Error(`Module data for '${moduleName}' is missing`);
	}
	
	// Check required fields for new structure
	if (!moduleData.chunk_characteristics) {
		throw new Error(`${moduleName}: Missing required field 'chunk_characteristics'`);
	}
	
	const chunkChars = moduleData.chunk_characteristics;
	
	// Assert chunk characteristics structure
	if (!chunkChars.usage || typeof chunkChars.usage !== 'object') {
		throw new Error(`${moduleName}: chunk_characteristics.usage should be an object`);
	}
	
	// Assert entry_module_id is set (should never be null in Module Federation)
	if (chunkChars.entry_module_id === null || chunkChars.entry_module_id === undefined) {
		throw new Error(`${moduleName}: entry_module_id is null/undefined - should have a valid module ID`);
	}
	
	// Assert module ID format
	const moduleId = chunkChars.entry_module_id;
	if (typeof moduleId !== "string" || moduleId.length === 0) {
		throw new Error(`${moduleName}: entry_module_id should be a non-empty string`);
	}
	
	// Assert chunk metadata fields exist
	if (typeof chunkChars.is_runtime_chunk !== 'boolean') {
		throw new Error(`${moduleName}: is_runtime_chunk should be a boolean`);
	}
	if (typeof chunkChars.has_runtime !== 'boolean') {
		throw new Error(`${moduleName}: has_runtime should be a boolean`);
	}
	if (typeof chunkChars.is_entrypoint !== 'boolean') {
		throw new Error(`${moduleName}: is_entrypoint should be a boolean`);
	}
}

/**
 * Assert macro syntax compatibility
 */
function assertMacroSyntaxCompatibility(modules) {
	for (const [moduleName, moduleData] of Object.entries(modules)) {
		// Verify module name can be used in macro conditions
		if (!/^[a-zA-Z0-9_-]+$/.test(moduleName)) {
			throw new Error(`Module name '${moduleName}' contains invalid characters for macro conditions`);
		}
		
		// Verify all export names in usage object are valid identifiers
		const allExports = Object.keys(moduleData.chunk_characteristics.usage);
		
		for (const exportName of allExports) {
			// Allow 'default' and valid JavaScript identifiers
			if (exportName !== "default" && !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(exportName)) {
				throw new Error(`Export name '${exportName}' in module '${moduleName}' is not a valid JavaScript identifier`);
			}
		}
	}
}