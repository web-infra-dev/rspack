const fs = require("fs");
const path = require("path");

/**
 * Validates the ShareUsagePlugin output with proper test assertions
 * @param {string} outputPath - Path to the build output directory
 */
module.exports = function validateShareUsage(outputPath) {
	// Check if share-usage.json was generated
	const shareUsageFile = path.join(outputPath, "share-usage.json");
	
	// Assert file exists
	if (!fs.existsSync(shareUsageFile)) {
		throw new Error("FAIL: share-usage.json file was not generated by ShareUsagePlugin");
	}
	
	// Read and parse the JSON
	let shareUsageData;
	try {
		const content = fs.readFileSync(shareUsageFile, "utf8");
		shareUsageData = JSON.parse(content);
	} catch (error) {
		throw new Error(`Failed to parse share-usage.json: ${error.message}`);
	}
	
	// Assert JSON structure
	if (typeof shareUsageData !== "object" || shareUsageData === null) {
		throw new Error("share-usage.json should be an object");
	}
	
	const modules = shareUsageData;
	
	// Assert we have the expected shared modules
	const expectedModules = ["lodash-es", "react", "local-cjs-module", "local-esm-module"];
	const actualModules = Object.keys(modules);
	
	for (const expectedModule of expectedModules) {
		if (!actualModules.includes(expectedModule)) {
			throw new Error(`Expected module '${expectedModule}' not found in share-usage.json`);
		}
	}
	
	// Validate and assert lodash-es usage
	assertLodashUsage(modules["lodash-es"]);
	
	// Validate and assert React usage
	assertReactUsage(modules["react"]);
	
	// Validate and assert local CJS module usage
	assertLocalCjsUsage(modules["local-cjs-module"]);
	
	// Validate and assert local ESM module usage
	assertLocalEsmUsage(modules["local-esm-module"]);
	
	// Verify macro syntax compatibility
	assertMacroSyntaxCompatibility(modules);
	
	// Create snapshot for comparison
	const snapshotPath = path.join(__dirname, "__file_snapshots__");
	if (!fs.existsSync(snapshotPath)) {
		fs.mkdirSync(snapshotPath, { recursive: true });
	}
	
	const snapshotFile = path.join(snapshotPath, "share-usage.json");
	fs.writeFileSync(snapshotFile, JSON.stringify(shareUsageData, null, 2));
	
	return true;
};

/**
 * Assert lodash-es module usage is correctly tracked
 */
function assertLodashUsage(lodashData) {
	assertModuleStructure(lodashData, "lodash-es");
	
	const expectedUsed = ["map", "filter", "isEmpty", "isArray", "isObject", "clone", "merge", "reduce"];
	const expectedUnused = ["uniq", "debounce", "groupBy", "partition", "cloneDeep", "mergeWith", "sortBy"];
	
	// Assert all expected used exports are marked as used
	for (const exp of expectedUsed) {
		if (!lodashData.used_exports.includes(exp)) {
			throw new Error(`lodash-es: Expected '${exp}' to be in used_exports but it wasn't found`);
		}
	}
	
	// Assert all expected unused exports are marked as unused
	for (const exp of expectedUnused) {
		if (!lodashData.unused_exports.includes(exp)) {
			throw new Error(`lodash-es: Expected '${exp}' to be in unused_exports but it wasn't found`);
		}
	}
	
	// Assert no used export appears in unused
	for (const exp of lodashData.used_exports) {
		if (lodashData.unused_exports.includes(exp)) {
			throw new Error(`lodash-es: Export '${exp}' appears in both used and unused lists`);
		}
	}
}

/**
 * Assert React module usage is correctly tracked
 */
function assertReactUsage(reactData) {
	assertModuleStructure(reactData, "react");
	
	const expectedUsed = ["createElement", "default"];
	const expectedUnused = ["useState", "useEffect"];
	
	// Assert used exports
	for (const exp of expectedUsed) {
		if (!reactData.used_exports.includes(exp)) {
			throw new Error(`react: Expected '${exp}' to be in used_exports but it wasn't found`);
		}
	}
	
	// Assert unused exports
	for (const exp of expectedUnused) {
		if (!reactData.unused_exports.includes(exp)) {
			throw new Error(`react: Expected '${exp}' to be in unused_exports but it wasn't found`);
		}
	}
}

/**
 * Assert local CJS module usage is correctly tracked
 */
function assertLocalCjsUsage(localCjsData) {
	assertModuleStructure(localCjsData, "local-cjs-module");
	
	const expectedUsed = ["usedLocalFunction", "constantValue", "nestedObject"];
	const expectedUnused = ["unusedLocalFunction", "unusedConstant", "directProperty"];
	
	// Assert used exports
	for (const exp of expectedUsed) {
		if (!localCjsData.used_exports.includes(exp)) {
			throw new Error(`local-cjs-module: Expected '${exp}' to be in used_exports but it wasn't found`);
		}
	}
	
	// Assert unused exports
	for (const exp of expectedUnused) {
		if (!localCjsData.unused_exports.includes(exp)) {
			throw new Error(`local-cjs-module: Expected '${exp}' to be in unused_exports but it wasn't found`);
		}
	}
}

/**
 * Assert local ESM module usage is correctly tracked
 */
function assertLocalEsmUsage(localEsmData) {
	assertModuleStructure(localEsmData, "local-esm-module");
	
	const expectedUsed = ["usedLocalUtil", "USED_LOCAL_CONSTANT", "default"];
	const expectedUnused = ["unusedLocalUtil", "UNUSED_LOCAL_CONSTANT"];
	
	// Assert used exports
	for (const exp of expectedUsed) {
		if (!localEsmData.used_exports.includes(exp)) {
			throw new Error(`local-esm-module: Expected '${exp}' to be in used_exports but it wasn't found`);
		}
	}
	
	// Assert unused exports
	for (const exp of expectedUnused) {
		if (!localEsmData.unused_exports.includes(exp)) {
			throw new Error(`local-esm-module: Expected '${exp}' to be in unused_exports but it wasn't found`);
		}
	}
}

/**
 * Assert module has correct structure
 */
function assertModuleStructure(moduleData, moduleName) {
	if (!moduleData) {
		throw new Error(`Module data for '${moduleName}' is missing`);
	}
	
	// Check required fields
	const requiredFields = ["used_exports", "unused_exports", "possibly_unused_exports", "entry_module_id"];
	for (const field of requiredFields) {
		if (!(field in moduleData)) {
			throw new Error(`${moduleName}: Missing required field '${field}'`);
		}
	}
	
	// Assert arrays
	if (!Array.isArray(moduleData.used_exports)) {
		throw new Error(`${moduleName}: used_exports should be an array`);
	}
	if (!Array.isArray(moduleData.unused_exports)) {
		throw new Error(`${moduleName}: unused_exports should be an array`);
	}
	if (!Array.isArray(moduleData.possibly_unused_exports)) {
		throw new Error(`${moduleName}: possibly_unused_exports should be an array`);
	}
	
	// Assert entry_module_id is set (should never be null in Module Federation)
	if (moduleData.entry_module_id === null || moduleData.entry_module_id === undefined) {
		throw new Error(`${moduleName}: entry_module_id is null/undefined - should have a valid module ID`);
	}
	
	// Assert module ID format
	const moduleId = moduleData.entry_module_id;
	if (typeof moduleId !== "string" || moduleId.length === 0) {
		throw new Error(`${moduleName}: entry_module_id should be a non-empty string`);
	}
}

/**
 * Assert macro syntax compatibility
 */
function assertMacroSyntaxCompatibility(modules) {
	for (const [moduleName, moduleData] of Object.entries(modules)) {
		// Verify module name can be used in macro conditions
		if (!/^[a-zA-Z0-9_-]+$/.test(moduleName)) {
			throw new Error(`Module name '${moduleName}' contains invalid characters for macro conditions`);
		}
		
		// Verify all export names are valid identifiers
		const allExports = [
			...moduleData.used_exports,
			...moduleData.unused_exports,
			...moduleData.possibly_unused_exports
		];
		
		for (const exportName of allExports) {
			// Allow 'default' and valid JavaScript identifiers
			if (exportName !== "default" && !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(exportName)) {
				throw new Error(`Export name '${exportName}' in module '${moduleName}' is not a valid JavaScript identifier`);
			}
		}
	}
}