// Mocked @reduxjs/toolkit module for testing inter-shared-module dependency tracking
// This module imports from redux to simulate inter-dependency

// Import redux functions that toolkit uses internally
const redux = require('redux');

// Use redux functions internally
const {
	createStore,
	combineReducers,
	compose,
	applyMiddleware,
	bindActionCreators,
	isPlainObject
} = redux;

// Mock implementation of configureStore
// This uses redux functions internally
function configureStore(options = {}) {
	const { reducer, middleware = [], preloadedState, enhancers = [] } = options;
	
	// Use combineReducers from redux if reducer is an object
	const rootReducer = isPlainObject(reducer) ? combineReducers(reducer) : reducer;
	
	// Use compose and applyMiddleware from redux
	const composedEnhancer = compose(
		applyMiddleware(...middleware),
		...enhancers
	);
	
	// Use createStore from redux
	const store = createStore(rootReducer, preloadedState, composedEnhancer);
	
	return store;
}

// Mock implementation of createSlice
function createSlice(options) {
	const { name, initialState, reducers = {} } = options;
	
	// Use isPlainObject from redux to validate
	if (!isPlainObject(initialState)) {
		throw new Error('Initial state must be a plain object');
	}
	
	const actions = {};
	
	// Create action creators
	for (const key in reducers) {
		actions[key] = (payload) => ({
			type: `${name}/${key}`,
			payload
		});
	}
	
	// Create reducer
	const reducer = (state = initialState, action) => {
		const [sliceName, actionName] = action.type.split('/');
		if (sliceName === name && reducers[actionName]) {
			// For simplicity, just call the reducer with state
			// Real toolkit uses immer, but this is just a mock
			const newState = { ...state };
			reducers[actionName](newState, action);
			return newState;
		}
		return state;
	};
	
	return {
		name,
		reducer,
		actions
	};
}

// Mock implementation of createAsyncThunk
function createAsyncThunk(typePrefix, payloadCreator) {
	// Use bindActionCreators from redux internally
	const actionCreator = (arg) => async (dispatch, getState) => {
		dispatch({ type: `${typePrefix}/pending` });
		try {
			const result = await payloadCreator(arg, { dispatch, getState });
			dispatch({ type: `${typePrefix}/fulfilled`, payload: result });
			return result;
		} catch (error) {
			dispatch({ type: `${typePrefix}/rejected`, error });
			throw error;
		}
	};
	
	actionCreator.pending = `${typePrefix}/pending`;
	actionCreator.fulfilled = `${typePrefix}/fulfilled`;
	actionCreator.rejected = `${typePrefix}/rejected`;
	
	return actionCreator;
}

// Mock implementation of createAction
function createAction(type) {
	const actionCreator = (payload) => ({ type, payload });
	actionCreator.type = type;
	return actionCreator;
}

// Export all the functions that @reduxjs/toolkit provides
module.exports = {
	configureStore,
	createSlice,
	createAsyncThunk,
	createAction,
	// Re-export some redux utilities that toolkit exposes
	combineReducers,
	compose,
	// Additional exports that toolkit might have
	createReducer: () => {},
	createEntityAdapter: () => {},
	nanoid: () => Math.random().toString(36).substr(2, 9)
};