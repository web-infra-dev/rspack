const process = require('process');
const { isNumber } = require('util');
let data = ""



process.stdin.on("readable", () => {
  let chunk;
  while (null !== (chunk = process.stdin.read())) {
    data += chunk;
  }
});

process.stdin.on("end", () => {
  // process all the data and write it back to stdout

	// "numFailedTestSuites": 0,
	// "numFailedTests": 0,
	const jsonObj = JSON.parse(data) || {}
	if (isEmptyObject(jsonObj)) {
		process.exit(-1)
	}
	const failedTestSuites = jsonObj.numFailedTestSuites;
	const failedTests = jsonObj.numFailedTests;
	if (!isNumber(failedTestSuites) || !isNumber(failedTests)) {
		// data is broken
		console.error("Failed to get failed data from jest")
		process.exit(-1)
	}
	if (failedTests > 0 || failedTestSuites > 0) {
		process.exit(-1)
	}
	// in theory, if we could get correct stats of failedTests and failedTestSuites
	// the stats generated by jest should be valid, so we don't need to check any more
	console.log(`Total testSuites: ${jsonObj.numTotalTestSuites}`)
	console.log(`Total tests : ${jsonObj.numTotalTests}`)
	console.log(`Total passedTestSuites: ${jsonObj.numPassedTestSuites}`)
	console.log(`Total passedTests : ${jsonObj.numPassedTests}`)
	console.log(`Tests Compatibility: ${(jsonObj.numPassedTests / jsonObj.numTotalTests * 100).toFixed(3)}%`)
});


const isEmptyObject = (obj) => {
	return obj != undefined && typeof obj === 'object' && Object.keys(obj).length === 0
}
