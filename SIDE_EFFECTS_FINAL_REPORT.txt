================================================================================
COMPREHENSIVE SIDE EFFECTS ANALYSIS REPORT
mf_async_startup Feature Branch (feature/async-startup-runtime-promise)
================================================================================

EXECUTIVE SUMMARY
═════════════════

This branch implements Module Federation async startup using Promise-based 
runtime initialization. While the feature is well-intentioned, the implementation
has CRITICAL unintended side effects affecting non-federation code paths.

FINDINGS:
  - 12+ new unconditional code paths added
  - 3 CRITICAL severity issues detected
  - 2 HIGH severity issues detected  
  - 3 MEDIUM severity issues detected
  - 4 LOW severity issues detected
  
OVERALL RISK: HIGH - Potential regressions in production builds

================================================================================
CRITICAL ISSUES (Must Fix Before Merge)
════════════════════════════════════════

ISSUE #1: STARTUP_ENTRYPOINT Hijacking
────────────────────────────────────────
Location: crates/rspack_plugin_javascript/src/plugin/mod.rs
Lines: 569-593, 637-641

Problem: New code paths execute for ANY chunk with STARTUP_ENTRYPOINT set,
         not just federation async startup chunks.

Code Pattern:
  if !is_federation_async && runtime_requirements.contains(RuntimeGlobals::STARTUP_ENTRYPOINT)
  
This condition is TRUE when:
  1. mf_async_startup=false (feature disabled) ✓ CORRECT
  2. STARTUP_ENTRYPOINT is set by non-federation code ✓ WRONG
  
Impact: Non-federation async startup code gets federation-specific wrapping

Affected Code Paths:
  - Lines 569-593: Wraps startup function (header.push added)
  - Lines 637-641: Sets up STARTUP_ENTRYPOINT execution

Real-World Scenario:
  1. App uses custom async startup mechanism with STARTUP_ENTRYPOINT
  2. App enables Module Federation (but not async startup)
  3. Custom startup gets unexpected federation wrapping
  4. Runtime behavior changes unpredictably

Fix Recommendation:
  - Add mf_async_startup check: require both true AND STARTUP_ENTRYPOINT
  - Limit scope to federation-only code paths
  - Add comments explaining feature coupling

Risk if Not Fixed: CRITICAL
- Silent behavioral change for non-federation code
- Regression in existing Module Federation apps
- Difficult to debug (code runs without mf_async_startup enabled)


ISSUE #2: Startup Chunk Dependencies Early Exit
────────────────────────────────────────────────
Location: crates/rspack_plugin_runtime/src/startup_chunk_dependencies.rs
Lines: 32-37

Problem: Unconditional early return prevents STARTUP insertion for ANY
         STARTUP_ENTRYPOINT, regardless of feature enablement.

Code Pattern:
  if runtime_requirements.contains(RuntimeGlobals::STARTUP_ENTRYPOINT) {
    return Ok(());  // SKIP ENTIRE STARTUP INSERTION
  }

Why It's Bad:
  - Assumes all STARTUP_ENTRYPOINT means async federation
  - Actually could be from non-federation async code
  - Skips STARTUP insertion entirely
  - Breaks chunk dependency loading

Real-World Scenario:
  1. Non-federation code sets STARTUP_ENTRYPOINT for custom async startup
  2. Plugin sees STARTUP_ENTRYPOINT and returns early
  3. STARTUP requirement is never added
  4. Chunk dependencies fail to load
  5. Build works, but runtime crashes with "missing STARTUP"

Test Case:
  - Create non-federation webpack config with custom STARTUP_ENTRYPOINT
  - Enable mf_async_startup=true (just for federation elsewhere)
  - STARTUP won't be added to chunks that need it
  - Result: Chunked apps break silently

Fix Recommendation:
  - Add feature flag check: only skip if mf_async_startup=true
  - Or: Check for federation-specific markers before early exit
  - Add comment explaining when early exit is appropriate

Risk if Not Fixed: CRITICAL
- Breaking change for non-federation code
- Runtime failures in production
- Hard to debug (early return with no error message)


ISSUE #3: REQUIRE Chunk Loading Behavior Change
────────────────────────────────────────────────
Location: crates/rspack_plugin_runtime/src/lib.rs
Lines: 47-53

Problem: REQUIRE chunk loading now passes mf_async_startup flag instead of
         hardcoded false, affecting all non-federation require() code.

Code Change:
  OLD: StartupChunkDependenciesPlugin::new(..., false)
       CommonJsChunkLoadingPlugin::new(false)
  
  NEW: StartupChunkDependenciesPlugin::new(..., mf_async_startup)
       CommonJsChunkLoadingPlugin::new(mf_async_startup)

Why It's Bad:
  - REQUIRE chunk loading is not federation-specific
  - Feature coupling: federation flag affects require() behavior
  - Silent breaking change: no error, just different async behavior
  - Synchronous code expects synchronous require()

Real-World Scenario:
  1. Node.js app uses require()-based dynamic chunks
  2. App adds Module Federation plugin (mf_async_startup=true)
  3. All dynamic require() calls now use async loading
  4. Synchronous code that expects immediate module availability breaks
  5. Example: require('./chunk') fails because chunk loaded asynchronously

Breaking Change for These Patterns:
  - Server-side rendering with chunks
  - Worker threads with require()
  - Any code that assumes require() is synchronous

Fix Recommendation:
  - Revert to hardcoded false for non-federation REQUIRE
  - Only pass mf_async_startup for federation-specific paths
  - Or: Add config option to control REQUIRE async behavior

Risk if Not Fixed: CRITICAL
- Breaking change for existing apps
- Silent failure (no error, wrong behavior)
- Affects production builds immediately

================================================================================
HIGH SEVERITY ISSUES (Should Fix Before Merge)
═══════════════════════════════════════════════

ISSUE #4: Unconditional Variable Allocation
────────────────────────────────────────────
Location: crates/rspack_plugin_javascript/src/plugin/mod.rs
Lines: 357-358

Problem: Vectors allocated unconditionally but only used in one code path

Impact:
  - Memory overhead on every entry module processing
  - Vector allocation even when feature is disabled
  - Repeated for multiple entry modules

Example:
  ```rust
  let mut federation_entry_calls: Vec<String> = Vec::new();  // ALWAYS created
  let mut all_chunk_ids: Vec<String> = Vec::new();           // ALWAYS created
  
  // ... 100+ lines of code
  
  if is_federation_async {
    federation_entry_calls.push(...);  // Only used here
    all_chunk_ids.push(...);           // Only used here
  }
  ```

Fix: Move allocation inside `if is_federation_async` block


ISSUE #5: New STARTUP_ENTRYPOINT Code Path (Lines 569-593)
───────────────────────────────────────────────────────────
Location: crates/rspack_plugin_javascript/src/plugin/mod.rs
Lines: 569-593

Problem: NEW code path executing for STARTUP_ENTRYPOINT without verifying
         mf_async_startup is enabled

Code Pattern:
  if !is_federation_async && runtime_requirements.contains(STARTUP_ENTRYPOINT) {
    allow_inline_startup = false;
    header.push("// the startup function (async)...");
    // ... adds STARTUP_ENTRYPOINT function wrapper
  }

Why It's Bad:
  - Wraps functions when federation async is DISABLED
  - Condition only checks "is_federation_async is false" + "STARTUP_ENTRYPOINT present"
  - Doesn't verify mf_async_startup is true

Impact: Similar to Issue #1, affects non-federation async startup code

================================================================================
MEDIUM SEVERITY ISSUES (Nice to Fix)
════════════════════════════════════

ISSUE #6: Passive Flag Semantic Change
───────────────────────────────────────
Location: crates/rspack_plugin_runtime/src/array_push_callback_chunk_format.rs
Lines: 155-156

Pattern: `let passive = !compilation.options.experiments.mf_async_startup;`

Why Concerning:
  - Semantics tied to unrelated feature flag
  - Confusing for maintainers: "Why is passive inverted?"
  - Harder to debug: flag behavior depends on federation config

Functional Impact: When mf_async_startup=false, passive=true (same as before)
So: Not a breaking change, but confusing code


ISSUE #7: Duplicate Runtime Requirements Insertion
────────────────────────────────────────────────────
Locations:
  1. crates/rspack_plugin_javascript/src/plugin/mod.rs (new code)
  2. crates/rspack_plugin_mf/src/container/embed_federation_runtime_plugin.rs (existing)

Problem: Both plugins may insert STARTUP/STARTUP_ENTRYPOINT

Impact: Hard to trace where requirements come from, fragile coupling


ISSUE #8: Configuration Parameter Threading
──────────────────────────────────────────────
Locations:
  1. crates/rspack_binding_api/src/raw_options/raw_builtins/mod.rs
  2. crates/rspack/src/builder/builder_context.rs

Change: mf_async_startup parameter added to function signatures

Risk: Medium - All call sites correctly updated, but signature change is breaking

================================================================================
LOW SEVERITY ISSUES (Minor Concerns)
════════════════════════════════════

ISSUE #9: Web Worker Comment/Code Mismatch
───────────────────────────────────────────
Location: crates/rspack_plugin_web_worker_template/src/lib.rs
Line: 5-6

Comment says: "hardcoded in enable_chunk_loading_plugin"
Actually: hardcoded in caller (enable_chunk_loading_plugin(..., true, ...))

Risk: Low - Maintenance confusion only, no runtime impact

================================================================================
REGRESSION TEST SUITE NEEDED
════════════════════════════

Test Case 1: Non-Federation STARTUP_ENTRYPOINT
───────────────────────────────────────────────
Config:
  {
    mfAsyncStartup: false,
    entry: { main: './index.js' },
    // NO module federation
  }
  
Custom Setup:
  - Set STARTUP_ENTRYPOINT manually in build
  
Expected Result:
  - No federation-specific wrapping
  - STARTUP should still be added if needed
  
Current Result:
  - LIKELY FAILS (Issue #1, #2)
  
Test Code Pattern:
  ```javascript
  const { STARTUP_ENTRYPOINT } = require('webpack');
  // Set STARTUP_ENTRYPOINT on compilation
  // Build without mf_async_startup
  // Check generated code for federation patterns
  // Should NOT find federation wrapping
  ```


Test Case 2: REQUIRE Chunk Loading with Async Federation
────────────────────────────────────────────────────────
Config:
  {
    mfAsyncStartup: true,
    output: { chunkLoading: 'require' }  // Use REQUIRE
  }
  
Expected Result:
  - Chunks loaded synchronously
  
Current Result:
  - MIGHT load asynchronously (Issue #3)
  
Test Verification:
  - Check generated _require_ calls
  - Verify synchronous behavior in Node.js


Test Case 3: Array Push with Passive Mode
──────────────────────────────────────────
Config:
  {
    mfAsyncStartup: false,
    output: { chunkFormat: 'array-push' }
  }
  
Expected Result:
  - Passive entry startup generation
  
Verify: Check entry startup source for passive patterns


Test Case 4: Startup Chunk Dependencies + STARTUP_ENTRYPOINT
──────────────────────────────────────────────────────────
Config:
  {
    mfAsyncStartup: false,
    // STARTUP_ENTRYPOINT set by build
  }
  
Expected Result:
  - STARTUP requirement added
  - Chunk dependencies loaded
  
Current Result:
  - LIKELY FAILS (Issue #2 - early exit)

================================================================================
SUMMARY OF CODE RUNNING WHEN mf_async_startup=false
════════════════════════════════════════════════════

UNCONDITIONAL CODE (Always Runs):
1. Variable allocation (js_plugin lines 328-329, 357-358)
2. Loop processing with conditional branches (js_plugin lines 449-459)
3. Early return check (startup_chunk_dependencies lines 32-37) ❌ WRONG
4. Conditional requirement swaps (array_push lines 56-62)
5. Parameter threading through config (raw_builtins, builder_context)

CONDITIONALLY-PROTECTED CODE (Runs only when needed):
1. Federation async initialization (js_plugin lines 333-347) ✓ CORRECT
2. Federation Promise.all wrapping (js_plugin lines 525-559) ✓ CORRECT
3. Federation async pattern in embed_federation_runtime (lines 207-227) ✓ CORRECT

PROBLEMATIC CODE (Runs when shouldn't):
1. Lines 569-593 (js_plugin) - checks STARTUP_ENTRYPOINT without mf_async_startup
2. Lines 637-641 (js_plugin) - checks STARTUP_ENTRYPOINT without mf_async_startup
3. Lines 32-37 (startup_chunk_dependencies) - early exit unconditionally
4. Lines 47-53 (lib.rs) - REQUIRE behavior change

================================================================================
RECOMMENDATIONS PRIORITY ORDER
══════════════════════════════

MUST FIX (Before Merge):
  1. ✓ Fix Issue #2 (startup_chunk_dependencies early exit)
     - Add: && compilation.options.experiments.mf_async_startup check
  
  2. ✓ Fix Issue #1 (STARTUP_ENTRYPOINT hijacking)
     - Change condition to: if is_federation_async && ... 
     - Or: Add explicit mf_async_startup check
  
  3. ✓ Fix Issue #3 (REQUIRE chunk loading)
     - Revert to hardcoded false OR
     - Add federation-specific context check

SHOULD FIX (Strongly Recommended):
  4. ✓ Extract Issue #4 (variable allocation)
     - Move federation_entry_calls/all_chunk_ids inside conditional
  
  5. ✓ Add regression tests
     - Test cases 1-4 above
     - Test non-federation STARTUP_ENTRYPOINT
     - Test REQUIRE async behavior

NICE TO FIX (Before Merge):
  6. ✓ Clarify Issue #6 (passive flag semantics)
     - Add comments explaining inversion
  
  7. ✓ Decouple Issue #7 (duplicate requirements)
     - Add comments about plugin coordination
  
  8. ✓ Fix Issue #9 (comment mismatch)
     - Update web worker comment

================================================================================
RISK ASSESSMENT
═══════════════

If Issues NOT Fixed:
  - CRITICAL regressions in non-federation code
  - Potential runtime crashes in production
  - Silent failures (no error messages)
  - Difficult to debug (feature scope violation)

If Issues Fixed:
  - Safe to merge
  - Good foundation for async federation
  - Proper feature isolation

Current Status: ❌ NOT READY FOR PRODUCTION
Recommendation: REQUEST CHANGES before merge

================================================================================
DETAILED ANALYSIS FILES
═══════════════════════

This report is supported by three detailed analysis documents:

1. side_effects_analysis.md
   - Complete technical analysis
   - Code snippets and line references
   - Detailed explanations of each issue

2. specific_code_issues.md
   - 7 specific issues with exact code patterns
   - Real-world scenarios
   - Before/after comparisons
   - Specific fix recommendations

3. side_effects_summary.txt
   - Quick reference table
   - Severity rankings
   - Issue categorization

================================================================================
