================================================================================
MODULE FEDERATION RUNTIME ANALYSIS - EXECUTIVE SUMMARY
================================================================================

Date: October 27, 2025
Branch: feature/async-startup-runtime-promise
Crate: rspack_plugin_mf

================================================================================
COMPREHENSIVE ANALYSIS COMPLETED
================================================================================

Analysis Documents Generated:

1. MF_RUNTIME_ANALYSIS.md (34 KB)
   - Complete architectural analysis
   - 8 major sections covering all aspects
   - Detailed code examples and flow diagrams
   - Implementation recommendations

2. MF_RUNTIME_QUICK_REFERENCE.md (10 KB)
   - Quick reference guide
   - Implementation checklist
   - Handler details
   - Next steps for developers

================================================================================
KEY FINDINGS
================================================================================

QUESTION 1: What runtime requirements does federation add?
ANSWER:
  Federation adds requirements through 4 mechanisms:
  
  A. ModuleFederationRuntimePlugin (lines 39-67)
     - Always adds: FederationDataRuntimeModule
     - Conditionally adds: STARTUP_ENTRYPOINT, ENSURE_CHUNK, ENSURE_CHUNK_INCLUDE_ENTRIES
  
  B. EmbedFederationRuntimePlugin (lines 56-90)
     - Adds STARTUP_ENTRYPOINT (if mf_async_startup=true)
     - OR adds STARTUP (if mf_async_startup=false)
  
  C. ConsumeSharedPlugin (lines 473-491)
     - MODULE, MODULE_CACHE, MODULE_FACTORIES_ADD_ONLY
     - SHARE_SCOPE_MAP, INITIALIZE_SHARING, HAS_OWN_PROPERTY
     - ConsumeSharedRuntimeModule
  
  D. ContainerReferencePlugin (lines 107-128)
     - MODULE, MODULE_FACTORIES_ADD_ONLY, HAS_OWN_PROPERTY
     - INITIALIZE_SHARING, SHARE_SCOPE_MAP
     - RemoteRuntimeModule (when ENSURE_CHUNK_HANDLERS needed)

================================================================================

QUESTION 2: How are consumes and remotes chunk handlers registered?
ANSWER:
  Through runtime module generation - handlers are created as JavaScript code:
  
  REMOTES HANDLER:
    File: RemoteRuntimeModule::generate() (remote_runtime_module.rs:40-108)
    Creates: __webpack_require__.f.remotes = function(chunkId, promises) { ... }
    Data: remotesLoadingData with chunkMapping and moduleIdToRemoteDataMapping
    Process: Chain of handleFunction → onExternal → onInitialized → onFactory
    
  CONSUMES HANDLER:
    File: ConsumeSharedRuntimeModule::generate() (consume_shared_runtime_module.rs:39-155)
    Creates: __webpack_require__.f.consumes = function(chunkId, promises) { ... }
    Data: consumesLoadingData with chunkMapping, moduleIdToConsumeDataMapping, initialConsumes
    Process: resolveHandler() with promise chaining via .then() and .catch()
  
  INVOCATION:
    Both handlers called during __webpack_require__.e(chunkId) (ensure chunk)
    Promises collected in array, all coordinated via Promise.all()

================================================================================

QUESTION 3: Is there a "federation-entry-startup" custom requirement?
ANSWER:
  NO. Federation does NOT use a custom "federation-entry-startup" requirement.
  
  Instead, it reuses existing requirements:
  - STARTUP_ENTRYPOINT (when mf_async_startup = true)
  - STARTUP (when mf_async_startup = false)
  
  Why? Because:
  1. Existing infrastructure already exists
  2. Minimal overhead to reuse
  3. Works with both sync and async modes
  
  Could we add one? YES - but would be redundant unless adding special handling
  like Promise.all wrapping for federation dependencies.

================================================================================

QUESTION 4: How does EmbedFederationRuntimeModule interact with startup?
ANSWER:
  EmbedFederationRuntimeModule creates a "prevStartup wrapper" pattern:
  
  Location: embed_federation_runtime_module.rs (Stage 11 - after RemoteRuntimeModule)
  
  Current Behavior:
    1. Saves original __webpack_require__.x (or .X if async)
    2. Replaces it with wrapper function
    3. Wrapper executes federation modules synchronously
    4. Then calls prevStartup()
    5. Uses hasRun flag to execute only once
  
  Code Pattern (lines 97-111):
    var prevStartup = __webpack_require__.x;  // or .X
    var hasRun = false;
    __webpack_require__.x = function() {
      if (!hasRun) {
        hasRun = true;
        // Execute federation modules
      }
      if (typeof prevStartup === 'function') {
        return prevStartup();
      }
    };
  
  Limitation:
    - Federation modules execute SYNCHRONOUSLY
    - Even when STARTUP_ENTRYPOINT (.X) could be async
    - Blocks on federation module loading

================================================================================

QUESTION 5: Can we add custom runtime requirement for federation startup wrapping?
ANSWER:
  YES - Two approaches:
  
  OPTION A (RECOMMENDED): Extend EmbedFederationRuntimeModule
  
    Modify: embed_federation_runtime_module.rs::generate()
    
    Detection:
      - Check if any federation deps depend on chunks
      - If yes AND mf_async_startup=true: use Promise.all
      - If no OR mf_async_startup=false: use sync wrapper
    
    Implementation:
      - Wrap chunk loading in Promise.all([...])
      - Execute federation modules in .then()
      - Return promise chain
    
    Benefits:
      - Minimal changes (one file)
      - Uses existing async capability
      - No new runtime requirement needed
  
  OPTION B: Create new FEDERATION_STARTUP requirement
  
    Would require:
      - New RuntimeGlobal constant
      - New runtime module template
      - Modifications to multiple plugins
      - More infrastructure overhead
    
    Disadvantage:
      - Redundant unless adding more special handling
      - More complex to maintain

================================================================================

QUESTION 6: What runtime modules exist in the MF crate?
ANSWER:
  6 Main Runtime Modules:
  
  1. FederationDataRuntimeModule (federation_data_runtime_module.rs)
     Stage: Normal | Always added | Provides federation config data
  
  2. RemoteRuntimeModule (remote_runtime_module.rs)
     Stage: Attach | Registers __webpack_require__.f.remotes handler
     Added when: ENSURE_CHUNK_HANDLERS required
  
  3. ConsumeSharedRuntimeModule (consume_shared_runtime_module.rs)
     Stage: Attach | Registers __webpack_require__.f.consumes handler
     Added when: ConsumeSharedPlugin active
  
  4. ShareRuntimeModule (share_runtime_module.rs)
     Stage: Normal | Initializes shared scope via __webpack_require__.I
     Added when: SHARE_SCOPE_MAP requirement present
  
  5. ExposeRuntimeModule (expose_runtime_module.rs)
     Stage: Attach | Container initialization data
     Added when: CURRENT_REMOTE_GET_SCOPE required (enhanced mode only)
  
  6. EmbedFederationRuntimeModule (embed_federation_runtime_module.rs)
     Stage: 11 | Wraps startup to execute federation modules first
     Added when: Runtime chunks with federation dependencies

================================================================================
ARCHITECTURE SUMMARY
================================================================================

Hierarchy:
  Entry Chunk Startup
    ↓ (wrapped by)
  EmbedFederationRuntimeModule (Stage 11)
    ├─ Executes federation runtime dependencies
    ├─ Wraps __webpack_require__.x or .X
    └─ Calls prevStartup()
        ↓
    FederationDataRuntimeModule (Stage Normal)
        ├─ Provides federation data
        └─ Used by other modules
    
    RemoteRuntimeModule (Stage 10)
        ├─ Registers __webpack_require__.f.remotes
        └─ Uses FederationDataRuntimeModule
    
    ConsumeSharedRuntimeModule (Stage Attach)
        ├─ Registers __webpack_require__.f.consumes
        └─ Provides consumesLoadingData
    
    ShareRuntimeModule (Stage Normal)
        ├─ Registers __webpack_require__.I (initializeSharing)
        └─ Provides initializeSharingData

Chunk Handler Registration:
  1. Runtime modules generate JavaScript code
  2. Code registers handlers at __webpack_require__.f.*
  3. Handlers called during __webpack_require__.e(chunkId)
  4. Multiple handlers can push promises to array
  5. All promises coordinated via Promise.all()

================================================================================
RECOMMENDATIONS FOR PROMISE.ALL WRAPPING
================================================================================

LOCATION: embed_federation_runtime_module.rs::generate()

DETECTION POINTS:
  1. Analyze collected federation dependency IDs
  2. Check if any depend on chunks (ENSURE_CHUNK requirement)
  3. Determine if async wrapping needed based on:
     - mf_async_startup = true (required)
     - Dependencies have chunk deps (required)
     - Multiple dependencies exist (optional, but beneficial)

IMPLEMENTATION:
  
  Current (Synchronous):
    var prevStartup = __webpack_require__.x;
    __webpack_require__.x = function() {
      if (!hasRun) {
        __webpack_require__(123);  // Synchronously
      }
      return prevStartup();
    };
  
  Proposed (Async with Promise.all):
    var prevStartup = __webpack_require__.X;
    var fedPromise;
    __webpack_require__.X = function() {
      if (!hasRun) {
        fedPromise = Promise.all([
          __webpack_require__.e(1),  // Load chunks
          __webpack_require__.e(2)
        ]).then(function() {
          __webpack_require__(123);  // Execute modules
          return typeof prevStartup === 'function' ? prevStartup() : undefined;
        });
        return fedPromise;
      }
      return fedPromise || prevStartup();
    };

BENEFITS:
  - Federation chunks load in parallel
  - Non-blocking for other modules
  - True async Module Federation startup
  - Promise.all coordinates multiple loads

================================================================================
CRITICAL FILES & LOCATIONS
================================================================================

PRIMARY FILES TO MODIFY:
  1. embed_federation_runtime_module.rs (lines 45-113) - generate() function
  2. module_federation_runtime_plugin.rs (lines 39-67) - requirements function

REFERENCE FILES:
  1. embed_federation_runtime_plugin.rs (lines 56-90) - requirement addition
  2. remote_runtime_module.rs (lines 40-108) - handler registration
  3. consume_shared_runtime_module.rs (lines 39-155) - handler registration
  4. share_runtime_module.rs (lines 32-122) - sharing initialization

GENERATED JAVASCRIPT FILES:
  1. remotesLoading.js - Remotes handler implementation
  2. consumesLoading.js - Consumes handler implementation
  3. consumesCommon.js - Shared consumes utilities
  4. consumesInitial.js - Initial consumes setup
  5. initializeSharing.js - Sharing initialization logic

================================================================================
IMPLEMENTATION CHECKLIST
================================================================================

PHASE 1: DETECTION & ANALYSIS
  [ ] Analyze federation dependency collection in EmbedFederationRuntimeModule
  [ ] Detect chunk dependencies (ENSURE_CHUNK requirement)
  [ ] Determine if async wrapping needed
  [ ] Check mf_async_startup flag

PHASE 2: CODE GENERATION
  [ ] Modify EmbedFederationRuntimeModule::generate()
  [ ] Add Promise.all wrapping for async case
  [ ] Ensure fallback to sync wrapper
  [ ] Handle edge cases (no deps, single dep, multiple deps)

PHASE 3: TESTING
  [ ] Test with mf_async_startup=true + chunk deps
  [ ] Test with mf_async_startup=false (should be sync)
  [ ] Test with no chunk deps (no wrapping)
  [ ] Test error handling in promise chain
  [ ] Use examples/basic for testing

================================================================================
GENERATED DOCUMENTATION
================================================================================

This analysis generated 2 comprehensive documents:

1. MF_RUNTIME_ANALYSIS.md
   - Full architectural analysis
   - 8 major sections
   - Code examples
   - Implementation paths
   - Generated code examples
   
2. MF_RUNTIME_QUICK_REFERENCE.md
   - Quick reference guide
   - Implementation checklist
   - Handler registration details
   - Runtime requirements summary
   - Next steps for developers

Both documents available at:
  /Users/zackjackson/rspack/MF_RUNTIME_ANALYSIS.md
  /Users/zackjackson/rspack/MF_RUNTIME_QUICK_REFERENCE.md

================================================================================
CONCLUSION
================================================================================

Module Federation runtime in rspack uses a sophisticated hierarchical system
of runtime modules that:

1. Add federation-specific runtime requirements through plugins
2. Register chunk handlers for remotes and consumes loading
3. Wrap startup execution to ensure federation modules run first
4. Coordinate async loading through Promise.all in handler chains

The recommended approach for Promise.all wrapping is to extend
EmbedFederationRuntimeModule to detect async needs and wrap federation
module execution in Promise.all when mf_async_startup=true.

This provides true async Module Federation startup without requiring
new runtime infrastructure, using existing async capabilities of
STARTUP_ENTRYPOINT.

================================================================================
