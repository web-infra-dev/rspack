// use std::{default::Default, path::Path};

// use options::SwcCompilerOptionsWithAdditional;
// pub use options::SwcLoaderJsOptions;
// pub use plugin::SwcLoaderPlugin;
use rspack_cacheable::{cacheable, cacheable_dyn};
// use rspack_core::{COLLECTED_TYPESCRIPT_INFO_PARSE_META_KEY, Mode, RunnerContext};
// use rspack_error::{Diagnostic, Error, Result};
use rspack_javascript_compiler::{JavaScriptCompiler, TransformOutput};
use rspack_loader_runner::{Identifier, Loader, LoaderContext};
// pub use rspack_workspace::rspack_swc_core_version;
// use sugar_path::SugarPath;
// use swc_config::{merge::Merge, types::MergingOption};
// use swc_core::{
//   base::config::{InputSourceMap, TransformConfig},
//   common::FileName,
// };
use swc_core::ecma::ast::{Lit, Program};

// use crate::collect_ts_info::collect_typescript_info;

fn is_client_module(program: &Program) -> bool {
  match program {
    Program::Module(m) => {
      has_directive!(m.body.iter().map(|item| item.as_stmt()), "use client")
    }
    Program::Script(s) => has_directive!(s.body.iter().map(Some), "use client"),
  }
}

#[cacheable]
#[derive(Debug)]
pub struct ServerComponentLoader {
  identifier: Identifier,
}

impl ServerComponentLoader {
  pub fn new() -> Result<Self, serde_json::Error> {
    Ok(Self {
      identifier: SERVER_COMPONENT_LOADER_IDENTIFIER.into(),
    })
  }

  /// Panics:
  /// Panics if `identifier` passed in is not starting with `builtin:swc-loader`.
  pub fn with_identifier(mut self, identifier: Identifier) -> Self {
    assert!(identifier.starts_with(SERVER_COMPONENT_LOADER_IDENTIFIER));
    self.identifier = identifier;
    self
  }
}

pub const SERVER_COMPONENT_LOADER_IDENTIFIER: &str = "builtin:server-component-loader";

#[cacheable_dyn]
#[async_trait::async_trait]
impl Loader<RunnerContext> for ServerComponentLoader {
  fn identifier(&self) -> Identifier {
    self.identifier
  }

  #[tracing::instrument("loader:builtin-server-component", skip_all, fields(
    perfetto.track_name = "loader:builtin-server-component",
    perfetto.process_name = "Loader Analysis",
    resource = loader_context.resource(),
  ))]
  async fn run(&self, loader_context: &mut LoaderContext<RunnerContext>) -> Result<()> {
    // TODO: 尝试通过 rspackAst 来解析
    if let Some(content) = loader_context.content() {
      let source = content.into_string_lossy();

      let javascript_compiler = JavaScriptCompiler::new();

      let jsx = module_parser_options
        .and_then(|options| options.get_javascript())
        .and_then(|options| options.jsx)
        .unwrap_or(false);

      javascript_compiler.parse(
        loader_context
          .resource_data()
          .path()
          .map(|p| p.as_str().to_string())
          .unwrap_or_default(),
        source,
        ast::EsVersion::EsNext,
        Syntax::Es(EsSyntax {
          jsx,
          allow_return_outside_function: matches!(
            module_type,
            ModuleType::JsDynamic | ModuleType::JsAuto
          ),
          explicit_resource_management: true,
          import_attributes: true,
          ..Default::default()
        }),
        is_module,
        comments,
      );

      if string.contains("use client") {
        let code = r#"// This file is generated by next-core EcmascriptClientReferenceModule.
import { registerClientReference } from "react-server-dom-turbopack/server";

"#;
        loader_context.finish_with(code);
      }
    }
    Ok(())
  }
}
