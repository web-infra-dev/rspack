var hasSymbol = typeof Symbol === "function";
var webpackQueues = hasSymbol ? Symbol("webpack queues") : "__webpack_queues__";
var webpackExports = <%- ASYNC_MODULE_EXPORT_SYMBOL %> = hasSymbol ? Symbol("webpack exports") : "<%- EXPORTS %>";
var webpackError = hasSymbol ? Symbol("webpack error") : "__webpack_error__";
var webpackDone = hasSymbol ? Symbol("webpack done") : "__webpack_done__";
var webpackDefer = <%- MAKE_DEFERRED_NAMESPACE_OBJECT_SYMBOL %> = hasSymbol ? Symbol("webpack defer") : "__webpack_defer__";
var resolveQueue = <%- basicFunction("queue") %> {
  if (queue && queue.d < 1) {
    queue.d = 1;
    queue.forEach(<%- expressionFunction("fn.r--", "fn") %>);
		queue.forEach(<%- expressionFunction("fn.r-- ? fn.r++ : fn()", "fn") %>);
	}
}
var wrapDeps = <%- basicFunction("deps") %> {
	return deps.map(<%- basicFunction("dep") %> {
		if (dep !== null && typeof dep === "object") {
			if(!dep[webpackQueues] && dep[webpackDefer]) {
				var asyncDeps = dep[webpackDefer];
				var hasUnresolvedAsyncSubgraph = asyncDeps.some(<%- basicFunction("id") %> {
					var cache = __webpack_module_cache__[id];
					return !cache || cache[webpackDone] === false;
				});
				if (hasUnresolvedAsyncSubgraph) {
					var d = dep;
					dep = {
						then(callback) {
							Promise.all(asyncDeps.map(__webpack_require__)).then(<%- returningFunction("callback(d)", "") %>)
						}
					};
				} else return dep;
			}
			if (dep[webpackQueues]) return dep;
			if (dep.then) {
				var queue = [];
				queue.d = 0;
				dep.then(<%- basicFunction("r") %> {
					obj[webpackExports] = r;
					resolveQueue(queue);
				},<%- basicFunction("e") %> {
					obj[webpackError] = e;
					resolveQueue(queue);
				});
				var obj = {};
				obj[webpackDefer] = false;
				obj[webpackQueues] = <%- expressionFunction("fn(queue)", "fn") %>;
				return obj;
			}
		}
		var ret = {};
		ret[webpackQueues] = <%- emptyFunction() %>;
		ret[webpackExports] = dep;
		return ret;
	});
};
<%- ASYNC_MODULE %> = <%- basicFunction("module, body, hasAwait") %> {
	var queue;
	hasAwait && ((queue = []).d = -1);
	var depQueues = new Set();
	var exports = module.exports;
	var currentDeps;
	var outerResolve;
	var reject;
	var promise = new Promise(<%- basicFunction("resolve, rej") %> {
		reject = rej;
		outerResolve = resolve;
	});
	promise[webpackExports] = exports;
	promise[webpackQueues] = <%- basicFunction("fn") %> { queue && fn(queue), depQueues.forEach(fn), promise["catch"](<%- emptyFunction() %>); };
	module.exports = promise;
	var handle = <%- basicFunction("deps") %> {
		currentDeps = wrapDeps(deps);
		var fn;
		var getResult = <%- basicFunction("") %> {
			return currentDeps.map(<%- basicFunction("d") %> {
				if(d[webpackDefer]) return d;
				if (d[webpackError]) throw d[webpackError];
				return d[webpackExports];
			});
		}
		var promise = new Promise(<%- basicFunction("resolve") %> {
			fn = <%- expressionFunction("resolve(getResult)", "") %>;
			fn.r = 0;
			var fnQueue = <%- expressionFunction("q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn)))", "q") %>;
			currentDeps.map(<%- expressionFunction("dep[webpackDefer] || dep[webpackQueues](fnQueue)", "dep") %>);
		});
		return fn.r ? promise : getResult();
	};
	var done = <%- expressionFunction("(err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue), promise[webpackDone] = true", "err") %>;
	body(handle, done);
	queue && queue.d < 0 && (queue.d = 0);
};