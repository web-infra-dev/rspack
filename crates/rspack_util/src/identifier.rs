use std::{borrow::Cow, path::Path};

use once_cell::sync::Lazy;
use regex::Regex;
use sugar_path::{AsPath, SugarPath};

static SEGMENTS_SPLIT_REGEXP: Lazy<Regex> = Lazy::new(|| Regex::new(r"([|!])").expect("TODO:"));
static WINDOWS_ABS_PATH_REGEXP: Lazy<Regex> =
  Lazy::new(|| Regex::new(r"^[a-zA-Z]:[/\\]").expect("TODO:"));
static WINDOWS_PATH_SEPARATOR_REGEXP: Lazy<Regex> =
  Lazy::new(|| Regex::new(r"[/\\]").expect("TODO:"));
pub fn make_paths_relative(context: &str, identifier: &str) -> String {
  SEGMENTS_SPLIT_REGEXP
    .split(identifier)
    .map(|s| absolute_to_request(context, s))
    // .map(|s| s.as_ref())
    .collect::<Vec<_>>()
    .join("")
}

pub fn absolute_to_request<'b>(context: &str, maybe_absolute_path: &'b str) -> Cow<'b, str> {
  // Align with https://github.com/webpack/webpack/blob/4b4ca3bb53f36a5b8fc6bc1bd976ed7af161bd80/lib/util/identifier.js#L30
  if maybe_absolute_path.starts_with('/') {
    if maybe_absolute_path.len() > 1 && maybe_absolute_path.ends_with('/') {
      // this 'path' is actually a regexp generated by dynamic requires.
      // Don't treat it as an absolute path.
      return Cow::Borrowed(maybe_absolute_path);
    }

    let query_split_pos = maybe_absolute_path.find('?').map_or(-1i32, |p| p as i32);
    let resource = if query_split_pos == -1 {
      maybe_absolute_path
    } else {
      &maybe_absolute_path[0..query_split_pos as usize]
    };
    let resource = {
      let tmp = Path::new(resource).relative(context);
      let tmp_path = tmp.to_string_lossy();
      relative_path_to_request(&tmp_path).to_string()
    };

    return if query_split_pos == -1 {
      Cow::Owned(resource)
    } else {
      Cow::Owned(format!(
        "{}{}",
        resource,
        &maybe_absolute_path[query_split_pos as usize..]
      ))
    };
  }

  if WINDOWS_ABS_PATH_REGEXP.is_match(maybe_absolute_path) {
    let query_split_pos = maybe_absolute_path.find('?').map_or(-1i32, |p| p as i32);
    let resource = if query_split_pos == -1 {
      maybe_absolute_path
    } else {
      &maybe_absolute_path[0..query_split_pos as usize]
    };
    let mut resource = resource
      .as_path()
      .relative(context)
      .to_string_lossy()
      .to_string();
    if !WINDOWS_ABS_PATH_REGEXP.is_match(&resource) {
      resource =
        relative_path_to_request(&WINDOWS_PATH_SEPARATOR_REGEXP.replace_all(&resource, "/"))
          .to_string();
    }

    return if query_split_pos == -1 {
      Cow::Owned(resource)
    } else {
      Cow::Owned(format!(
        "{}{}",
        resource,
        &maybe_absolute_path[query_split_pos as usize..]
      ))
    };
  }

  // not an absolute path
  Cow::Borrowed(maybe_absolute_path)
}

pub fn request_to_absolute<'rel>(context: &str, relative_path: &'rel str) -> Cow<'rel, str> {
  if relative_path.starts_with("./") || relative_path.starts_with("../") {
    Cow::Owned(
      Path::new(context)
        .join(relative_path)
        .to_string_lossy()
        .to_string(),
    )
  } else {
    Cow::Borrowed(relative_path)
  }
}

pub fn relative_path_to_request(rel: &str) -> Cow<str> {
  if rel.is_empty() {
    Cow::Borrowed("./.")
  } else if rel == ".." {
    Cow::Borrowed("../.")
  } else if rel.starts_with("../") {
    Cow::Borrowed(rel)
  } else {
    Cow::Owned(format!("./{rel}"))
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  #[test]
  fn test_make_paths_relative() {
    let test_cases = vec![
      (
        "/some/dir/",
        "/some/dir/to/somewhere|some/other/dir!../more/dir",
        "./to/somewhere|some/other/dir!../more/dir",
      ),
      // (
      //   "/dir/",
      //   "/dir/to/somewhere|some/other/dir!../more/dir",
      //   "./to/somewhere|some/other/dir!../more/dir",
      // ),
      // (
      //   "/",
      //   "/dir/to/somewhere|some/other/dir!../more/dir",
      //   "./dir/to/somewhere|some/other/dir!../more/dir",
      // ),
      // (
      //   "c:\\some\\dir\\",
      //   "c:\\some\\dir\\to\\somewhere|some/other/dir!../more/dir",
      //   "./to/somewhere|some/other/dir!../more/dir",
      // ),
      // (
      //   "c:\\some\\dir\\",
      //   "C:\\some\\dir\\to\\somewhere|some/other/dir!../more/dir",
      //   "./to/somewhere|some/other/dir!../more/dir",
      // ),
      // (
      //   "C:\\some\\dir",
      //   "C:\\some\\dir\\to\\somewhere|some/other/dir!../more/dir",
      //   "./to/somewhere|some/other/dir!../more/dir",
      // ),
      // (
      //   "C:\\\\some\\dir",
      //   "c:\\some\\\\dir\\to\\\\somewhere|some/other/dir!../more/dir",
      //   "./to/somewhere|some/other/dir!../more/dir",
      // ),
      // (
      //   "/dir",
      //   "/dir/to/somewhere??ref-123",
      //   "./to/somewhere??ref-123",
      // ),
    ];
    for (context, path_construct, expected) in test_cases {
      let result = make_paths_relative(context, path_construct);
      assert_eq!(result, expected);
    }
  }
}
