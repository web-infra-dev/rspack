use std::{borrow::Cow, path::Path};

use once_cell::sync::Lazy;
use regex::Regex;
use sugar_path::{AsPath, SugarPath};

static SEGMENTS_SPLIT_REGEXP: Lazy<Regex> = Lazy::new(|| Regex::new(r"([|!])").expect("TODO:"));
static WINDOWS_ABS_PATH_REGEXP: Lazy<Regex> =
  Lazy::new(|| Regex::new(r"^[a-zA-Z]:[/\\]").expect("TODO:"));
static WINDOWS_PATH_SEPARATOR_REGEXP: Lazy<Regex> =
  Lazy::new(|| Regex::new(r"[/\\]").expect("TODO:"));
pub fn make_paths_relative(context: &str, identifier: &str) -> String {
  SEGMENTS_SPLIT_REGEXP
    .split(identifier)
    .map(|s| absolute_to_request(context, s))
    // .map(|s| s.as_ref())
    .collect::<Vec<_>>()
    .join("")
}

pub fn absolute_to_request<'b>(context: &str, maybe_absolute_path: &'b str) -> Cow<'b, str> {
  // Align with https://github.com/webpack/webpack/blob/4b4ca3bb53f36a5b8fc6bc1bd976ed7af161bd80/lib/util/identifier.js#L30
  if maybe_absolute_path.starts_with('/') {
    if maybe_absolute_path.len() > 1 && maybe_absolute_path.ends_with('/') {
      // this 'path' is actually a regexp generated by dynamic requires.
      // Don't treat it as an absolute path.
      return Cow::Borrowed(maybe_absolute_path);
    }

    let query_split_pos = maybe_absolute_path.find('?').map_or(-1i32, |p| p as i32);
    let resource = if query_split_pos == -1 {
      maybe_absolute_path
    } else {
      &maybe_absolute_path[0..query_split_pos as usize]
    };
    let resource = {
      let tmp = Path::new(resource).relative(context);
      let tmp_path = tmp.to_string_lossy();
      relative_path_to_request(&tmp_path).to_string()
    };

    return if query_split_pos == -1 {
      Cow::Owned(resource)
    } else {
      Cow::Owned(format!(
        "{}{}",
        resource,
        &maybe_absolute_path[query_split_pos as usize..]
      ))
    };
  }

  if WINDOWS_ABS_PATH_REGEXP.is_match(maybe_absolute_path) {
    let query_split_pos = maybe_absolute_path.find('?').map_or(-1i32, |p| p as i32);
    let resource = if query_split_pos == -1 {
      maybe_absolute_path
    } else {
      &maybe_absolute_path[0..query_split_pos as usize]
    };
    let mut resource = resource
      .as_path()
      .relative(context)
      .to_string_lossy()
      .to_string();
    if !WINDOWS_ABS_PATH_REGEXP.is_match(&resource) {
      resource =
        relative_path_to_request(&WINDOWS_PATH_SEPARATOR_REGEXP.replace_all(&resource, "/"))
          .to_string();
    }

    return if query_split_pos == -1 {
      Cow::Owned(resource)
    } else {
      Cow::Owned(format!(
        "{}{}",
        resource,
        &maybe_absolute_path[query_split_pos as usize..]
      ))
    };
  }

  // not an absolute path
  Cow::Borrowed(maybe_absolute_path)
}

pub fn request_to_absolute<'ctx, 'rel>(
  context: &'ctx str,
  relative_path: &'rel str,
) -> Cow<'rel, str> {
  if relative_path.starts_with("./") || relative_path.starts_with("../") {
    Cow::Owned(
      Path::new(context)
        .join(relative_path)
        .to_string_lossy()
        .to_string(),
    )
  } else {
    Cow::Borrowed(relative_path)
  }
}

pub fn relative_path_to_request(rel: &str) -> Cow<str> {
  if rel.is_empty() {
    Cow::Borrowed("./.")
  } else if rel == ".." {
    Cow::Borrowed("../.")
  } else if rel.starts_with("../") {
    Cow::Borrowed(rel)
  } else {
    Cow::Owned(format!("./{}", rel))
  }
}
