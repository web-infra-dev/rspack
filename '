use std::{
  borrow::Cow,
  fmt::Debug,
  hash::{BuildHasherDefault, Hash},
  sync::{
    atomic::{AtomicUsize, Ordering},
    Arc, Mutex,
  },
};

use bitflags::bitflags;
use dashmap::DashMap;
use derivative::Derivative;
use oxc_resolver::ResolveOptions;
use rspack_error::{error, Diagnosable, Diagnostic, Result, Severity};
use rspack_hash::RspackHash;
use rspack_identifier::Identifiable;
use rspack_loader_runner::{run_loaders, Content, ResourceData};
use rspack_sources::{
  BoxSource, CachedSource, OriginalSource, RawSource, Source, SourceExt, SourceMap,
  SourceMapSource, WithoutOriginalOptions,
};
use rustc_hash::FxHashSet as HashSet;
use rustc_hash::FxHasher;
use serde_json::json;

use crate::{
  add_connection_states, contextify, get_context, AsyncDependenciesBlockIdentifier, BoxLoader,
  BoxModule, BuildContext, BuildInfo, BuildMeta, BuildResult, CodeGenerationResult, Compilation,
  CompilerOptions, ConnectionState, Context, DependenciesBlock, DependencyId, DependencyTemplate,
  FactoryMeta, GenerateContext, GeneratorOptions, LibIdentOptions,
  LoaderRunnerPluginProcessResource, Module, ModuleDependency, ModuleGraph, ModuleIdentifier,
  ModuleType, ParseContext, ParseResult, ParserAndGenerator, ParserOptions, Resolve, RuntimeSpec,
  SourceType,
};
pub struct RootModuleContext {
  id: ModuleIdentifier,
  readable_identifier: String,
  name_for_condition: Option<Box<str>>,
  lib_indent: Option<String>,
  resolve_options: Option<Box<ResolveOptions>>,
  code_generation_dependencies: Option<Vec<Box<dyn ModuleDependency>>>,
  presentational_dependencies: Option<Vec<Box<dyn DependencyTemplate>>>,
  context: Option<Box<Context>>,
  side_effect_connection_state: ConnectionState,
}

pub struct ConcatenatedInnerModule {
  id: ModuleIdentifier,
  size: usize,
  original_source: Option<BoxSource>,
}

#[derive(Derivative)]
#[derivative(Debug)]
pub struct ConcatenatedModule {
  id: ModuleIdentifier,
  root_module_ctxt: RootModuleContext,
  modules: Vec<ConcatenatedInnerModule>,
  runtime: RuntimeSpec,
  factory_meta: Option<FactoryMeta>,

  blocks: Vec<AsyncDependenciesBlockIdentifier>,
  dependencies: Vec<DependencyId>,

  cached_source_sizes: DashMap<SourceType, f64, BuildHasherDefault<FxHasher>>,

  diagnostics: Mutex<Vec<Diagnostic>>,
}

impl ConcatenatedModule {
  pub fn new(
    id: ModuleIdentifier,
    root_module_ctxt: RootModuleContext,
    modules: Vec<ConcatenatedInnerModule>,
    runtime: RuntimeSpec,
    factory_meta: Option<FactoryMeta>,
  ) -> Self {
    Self {
      id,
      root_module_ctxt,
      modules,
      runtime,
      factory_meta,
      dependencies: vec![],
      blocks: vec![],
      cached_source_sizes: DashMap::default(),
      diagnostics: Mutex::new(vec![]),
    }
  }

  pub fn id(&self) -> ModuleIdentifier {
    self.id
  }

  fn get_modules(&self) -> Vec<ModuleIdentifier> {
    self.modules.iter().cloned().collect::<Vec<_>>()
  }
}

impl Identifiable for ConcatenatedModule {
  #[inline]
  fn identifier(&self) -> ModuleIdentifier {
    self.id
  }
}

impl DependenciesBlock for ConcatenatedModule {
  fn add_block_id(&mut self, block: AsyncDependenciesBlockIdentifier) {
    self.blocks.push(block)
  }

  fn get_blocks(&self) -> &[AsyncDependenciesBlockIdentifier] {
    &self.blocks
  }

  fn add_dependency_id(&mut self, dependency: DependencyId) {
    self.dependencies.push(dependency)
  }

  fn get_dependencies(&self) -> &[DependencyId] {
    &self.dependencies
  }
}

#[async_trait::async_trait]
impl Module for ConcatenatedModule {
  fn module_type(&self) -> &ModuleType {
    // https://github.com/webpack/webpack/blob/1f99ad6367f2b8a6ef17cce0e058f7a67fb7db18/lib/optimize/ConcatenatedModule.js#L688
    &ModuleType::JsEsm
  }
  fn source_types(&self) -> &[SourceType] {
    &[SourceType::JavaScript]
  }

  fn original_source(&self) -> Option<&dyn Source> {
    None
  }

  fn readable_identifier(&self, context: &Context) -> Cow<str> {
    Cow::Owned(format!(
      "{} + {} modules",
      self.root_module_ctxt.readable_identifier,
      self.modules.len() - 1
    ))
  }

  fn size(&self, source_type: &SourceType) -> f64 {
    if let Some(size_ref) = self.cached_source_sizes.get(source_type) {
      *size_ref
    } else {
      let size = self.modules.iter().fold(0, |acc, cur| acc + cur.size);
      self.cached_source_sizes.insert(*source_type, size);
      size
    }
  }

  async fn build(&mut self, build_context: BuildContext<'_>) -> Result<BuildResult> {
    self.clear_diagnostics();

    let mut build_info = BuildInfo::default();
    let mut build_meta = BuildMeta::default();

    build_context.plugin_driver.before_loaders(self).await?;

    let loader_result = run_loaders(
      &self.loaders,
      &self.resource_data,
      &[Box::new(LoaderRunnerPluginProcessResource {
        plugin_driver: build_context.plugin_driver.clone(),
      })],
      build_context.compiler_context,
    )
    .await;
    let (loader_result, ds) = match loader_result {
      Ok(r) => r.split_into_parts(),
      Err(e) => {
        let d = Diagnostic::from(e);
        self.source = NormalModuleSource::BuiltFailed(d.clone());
        self.add_diagnostic(d);
        let mut hasher = RspackHash::from(&build_context.compiler_options.output);
        self.update_hash(&mut hasher);
        build_meta.hash(&mut hasher);
        build_info.hash = Some(hasher.digest(&build_context.compiler_options.output.hash_digest));
        return Ok(BuildResult {
          build_info,
          build_meta: Default::default(),
          dependencies: Vec::new(),
          blocks: Vec::new(),
          analyze_result: Default::default(),
        });
      }
    };
    self.add_diagnostics(ds);

    let content = if self.module_type().is_binary() {
      Content::Buffer(loader_result.content.into_bytes())
    } else {
      Content::String(loader_result.content.into_string_lossy())
    };
    let original_source = self.create_source(content, loader_result.source_map)?;
    let mut code_generation_dependencies: Vec<Box<dyn ModuleDependency>> = Vec::new();

    let (
      ParseResult {
        source,
        dependencies,
        blocks,
        presentational_dependencies,
        analyze_result,
      },
      ds,
    ) = self
      .parser_and_generator
      .parse(ParseContext {
        source: original_source.clone(),
        module_identifier: self.identifier(),
        module_parser_options: self.parser_options.as_ref(),
        module_type: &self.module_type,
        module_user_request: &self.user_request,
        loaders: &self.loaders,
        resource_data: &self.resource_data,
        compiler_options: build_context.compiler_options,
        additional_data: loader_result.additional_data,
        code_generation_dependencies: &mut code_generation_dependencies,
        build_info: &mut build_info,
        build_meta: &mut build_meta,
      })?
      .split_into_parts();
    self.add_diagnostics(ds);
    // Only side effects used in code_generate can stay here
    // Other side effects should be set outside use_cache
    self.original_source = Some(source.clone());
    self.source = NormalModuleSource::new_built(source, self.clone_diagnostics());
    self.code_generation_dependencies = Some(code_generation_dependencies);
    self.presentational_dependencies = Some(presentational_dependencies);

    let mut hasher = RspackHash::from(&build_context.compiler_options.output);
    self.update_hash(&mut hasher);
    build_meta.hash(&mut hasher);

    build_info.hash = Some(hasher.digest(&build_context.compiler_options.output.hash_digest));
    build_info.cacheable = loader_result.cacheable;
    build_info.file_dependencies = loader_result.file_dependencies;
    build_info.context_dependencies = loader_result.context_dependencies;
    build_info.missing_dependencies = loader_result.missing_dependencies;
    build_info.build_dependencies = loader_result.build_dependencies;
    build_info.asset_filenames = loader_result.asset_filenames;

    Ok(BuildResult {
      build_info,
      build_meta,
      dependencies,
      blocks,
      analyze_result,
    })
  }

  fn code_generation(
    &self,
    compilation: &Compilation,
    runtime: Option<&RuntimeSpec>,
  ) -> Result<CodeGenerationResult> {
    if let NormalModuleSource::BuiltSucceed(source) = &self.source {
      let mut code_generation_result = CodeGenerationResult::default();
      for source_type in self.source_types() {
        let generation_result = self.parser_and_generator.generate(
          source,
          self,
          &mut GenerateContext {
            compilation,
            module_generator_options: self.generator_options.as_ref(),
            runtime_requirements: &mut code_generation_result.runtime_requirements,
            data: &mut code_generation_result.data,
            requested_source_type: *source_type,
            runtime,
          },
        )?;
        code_generation_result.add(*source_type, CachedSource::new(generation_result).boxed());
      }
      code_generation_result.set_hash(
        &compilation.options.output.hash_function,
        &compilation.options.output.hash_digest,
        &compilation.options.output.hash_salt,
      );
      Ok(code_generation_result)
    } else if let NormalModuleSource::BuiltFailed(error_message) = &self.source {
      let mut code_generation_result = CodeGenerationResult::default();

      // If the module build failed and the module is able to emit JavaScript source,
      // we should emit an error message to the runtime, otherwise we do nothing.
      if self.source_types().contains(&SourceType::JavaScript) {
        let error = error_message.render_report(compilation.options.stats.colors)?;
        code_generation_result.add(
          SourceType::JavaScript,
          RawSource::from(format!("throw new Error({});\n", json!(error))).boxed(),
        );
      }
      code_generation_result.set_hash(
        &compilation.options.output.hash_function,
        &compilation.options.output.hash_digest,
        &compilation.options.output.hash_salt,
      );
      Ok(code_generation_result)
    } else {
      Err(error!(
        "Failed to generate code because ast or source is not set for module {}",
        self.request
      ))
    }
  }

  fn name_for_condition(&self) -> Option<Box<str>> {
    self.root_module_ctxt.name_for_condition
  }

  fn lib_ident(&self, options: LibIdentOptions) -> Option<Cow<str>> {
    self
      .root_module_ctxt
      .lib_indent
      .map(|item| Cow::Owned(item))
  }

  fn get_resolve_options(&self) -> Option<Box<Resolve>> {
    self.root_module_ctxt.resolve_options.clone()
  }

  fn get_code_generation_dependencies(&self) -> Option<&[Box<dyn ModuleDependency>]> {
    self.root_module_ctxt.code_generation_dependencies.as_ref()
  }

  fn get_presentational_dependencies(&self) -> Option<&[Box<dyn DependencyTemplate>]> {
    self.root_module_ctxt.presentational_dependencies.as_ref()
  }

  fn get_context(&self) -> Option<Box<Context>> {
    self.root_module_ctxt.context.clone()
  }

  // Port from https://github.com/webpack/webpack/blob/main/lib/ConcatenatedModule.js#L1120
  fn get_side_effects_connection_state(
    &self,
    module_graph: &ModuleGraph,
    module_chain: &mut HashSet<ModuleIdentifier>,
  ) -> ConnectionState {
    self.root_module_ctxt.side_effect_connection_state
  }
}

impl Diagnosable for ConcatenatedModule {
  fn add_diagnostic(&self, diagnostic: Diagnostic) {
    self
      .diagnostics
      .lock()
      .expect("should be able to lock diagnostics")
      .push(diagnostic);
  }

  fn add_diagnostics(&self, mut diagnostics: Vec<Diagnostic>) {
    self
      .diagnostics
      .lock()
      .expect("should be able to lock diagnostics")
      .append(&mut diagnostics);
  }

  fn clone_diagnostics(&self) -> Vec<Diagnostic> {
    self
      .diagnostics
      .lock()
      .expect("should be able to lock diagnostics")
      .iter()
      .cloned()
      .collect()
  }
}

impl PartialEq for ConcatenatedModule {
  fn eq(&self, other: &Self) -> bool {
    self.identifier() == other.identifier()
  }
}

impl Eq for ConcatenatedModule {}

impl ConcatenatedModule {
  fn clear_diagnostics(&mut self) {
    self
      .diagnostics
      .lock()
      .expect("should be able to lock diagnostics")
      .clear()
  }
}

impl Hash for ConcatenatedModule {
  fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
    "__rspack_internal__ConcatenatedModule".hash(state);
    for module in self.modules {

    if let Some(original_source) = &self.original_source {
      original_source.hash(state);
    }
        }

  }
}
